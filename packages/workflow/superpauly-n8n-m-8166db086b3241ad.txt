Directory structure:
└── workflow/
    ├── README.md
    ├── eslint.config.mjs
    ├── jest.config.js
    ├── package.json
    ├── tsconfig.build.cjs.json
    ├── tsconfig.build.esm.json
    ├── tsconfig.json
    ├── vitest.config.ts
    ├── src/
    │   ├── augment-object.ts
    │   ├── constants.ts
    │   ├── cron.ts
    │   ├── data-store.types.ts
    │   ├── deferred-promise.ts
    │   ├── evaluation-helpers.ts
    │   ├── execution-status.ts
    │   ├── expression-evaluator-proxy.ts
    │   ├── expression-sandboxing.ts
    │   ├── expression.ts
    │   ├── from-ai-parse-utils.ts
    │   ├── global-state.ts
    │   ├── index.ts
    │   ├── interfaces.ts
    │   ├── logger-proxy.ts
    │   ├── message-event-bus.ts
    │   ├── metadata-utils.ts
    │   ├── node-helpers.ts
    │   ├── node-reference-parser-utils.ts
    │   ├── observable-object.ts
    │   ├── result.ts
    │   ├── telemetry-helpers.ts
    │   ├── tool-helpers.ts
    │   ├── type-guards.ts
    │   ├── type-validation.ts
    │   ├── types.d.ts
    │   ├── utils.ts
    │   ├── versioned-node-type.ts
    │   ├── workflow-data-proxy-env-provider.ts
    │   ├── workflow-data-proxy-helpers.ts
    │   ├── workflow-data-proxy.ts
    │   ├── workflow.ts
    │   ├── common/
    │   │   ├── get-child-nodes.ts
    │   │   ├── get-connected-nodes.ts
    │   │   ├── get-node-by-name.ts
    │   │   ├── get-parent-nodes.ts
    │   │   ├── index.ts
    │   │   └── map-connections-by-destination.ts
    │   ├── errors/
    │   │   ├── cli-subworkflow-operation.error.ts
    │   │   ├── db-connection-timeout-error.ts
    │   │   ├── ensure-error.ts
    │   │   ├── execution-cancelled.error.ts
    │   │   ├── expression-extension.error.ts
    │   │   ├── expression.error.ts
    │   │   ├── index.ts
    │   │   ├── node-api.error.ts
    │   │   ├── node-operation.error.ts
    │   │   ├── node-ssl.error.ts
    │   │   ├── subworkflow-operation.error.ts
    │   │   ├── trigger-close.error.ts
    │   │   ├── webhook-taken.error.ts
    │   │   ├── workflow-activation.error.ts
    │   │   ├── workflow-deactivation.error.ts
    │   │   ├── workflow-operation.error.ts
    │   │   ├── abstract/
    │   │   │   ├── execution-base.error.ts
    │   │   │   └── node.error.ts
    │   │   └── base/
    │   │       ├── base.error.ts
    │   │       ├── operational.error.ts
    │   │       ├── unexpected.error.ts
    │   │       └── user.error.ts
    │   ├── expressions/
    │   │   └── expression-helpers.ts
    │   ├── extensions/
    │   │   ├── array-extensions.ts
    │   │   ├── boolean-extensions.ts
    │   │   ├── date-extensions.ts
    │   │   ├── expression-extension.ts
    │   │   ├── expression-parser.ts
    │   │   ├── extended-functions.ts
    │   │   ├── extensions.ts
    │   │   ├── index.ts
    │   │   ├── number-extensions.ts
    │   │   ├── object-extensions.ts
    │   │   ├── string-extensions.ts
    │   │   └── utils.ts
    │   ├── graph/
    │   │   └── graph-utils.ts
    │   ├── native-methods/
    │   │   ├── array.methods.ts
    │   │   ├── boolean.methods.ts
    │   │   ├── index.ts
    │   │   ├── number.methods.ts
    │   │   ├── object.methods.ts
    │   │   └── string.methods.ts
    │   └── node-parameters/
    │       ├── filter-parameter.ts
    │       ├── parameter-type-validation.ts
    │       ├── path-utils.ts
    │       └── rename-node-utils.ts
    └── test/
        ├── augment-object.test.ts
        ├── common.test.ts
        ├── cron.test.ts
        ├── deferred-promise.test.ts
        ├── expression-sandboxing.test.ts
        ├── expression.test.ts
        ├── filter-parameter.test.ts
        ├── from-ai-parse-utils.test.ts
        ├── helpers.ts
        ├── metadata-utils.test.ts
        ├── node-errors.test.ts
        ├── node-helpers.conditions.test.ts
        ├── node-helpers.test.ts
        ├── node-reference-parser-utils.test.ts
        ├── node-types.ts
        ├── observable-object.test.ts
        ├── rename-node-utils.test.ts
        ├── telemetry-helpers.test.ts
        ├── tool-helpers.test.ts
        ├── type-validation.test.ts
        ├── utils.test.ts
        ├── workflow-data-proxy-env-provider.test.ts
        ├── workflow-data-proxy.test.ts
        ├── workflow.test.ts
        ├── errors/
        │   ├── node.error.test.ts
        │   ├── workflow-activation.error.test.ts
        │   └── base/
        │       ├── operational.error.test.ts
        │       ├── unexpected.error.test.ts
        │       └── user.error.test.ts
        ├── ExpressionExtensions/
        │   ├── array-extensions.test.ts
        │   ├── boolean-extensions.test.ts
        │   ├── date-extensions.test.ts
        │   ├── expression-extension.test.ts
        │   ├── generic-extensions.test.ts
        │   ├── helpers.ts
        │   ├── number-extensions.test.ts
        │   ├── object-extensions.test.ts
        │   └── string-extensions.test.ts
        ├── ExpressionFixtures/
        │   └── base.ts
        ├── expressions/
        │   └── expression-helpers.test.ts
        ├── fixtures/
        │   └── WorkflowDataProxy/
        │       ├── agentInfo_run.json
        │       ├── agentInfo_workflow.json
        │       ├── base_run.json
        │       ├── base_workflow.json
        │       ├── errors_run.json
        │       ├── errors_workflow.json
        │       ├── from_ai_multiple_items_run.json
        │       ├── from_ai_multiple_items_workflow.json
        │       ├── multiple_inputs_run.json
        │       ├── multiple_inputs_workflow.json
        │       ├── multiple_outputs_run.json
        │       ├── multiple_outputs_workflow.json
        │       ├── partial_data_run.json
        │       ├── partial_data_workflow.json
        │       ├── pindata_paireditem_run.json
        │       ├── pindata_paireditem_workflow.json
        │       ├── pindata_run.json
        │       ├── pindata_workflow.json
        │       ├── rawParameter_run.json
        │       └── rawParameter_workflow.json
        ├── graph/
        │   └── graph-utils.test.ts
        └── node-parameters/
            ├── parameter-type-validation.test.ts
            └── path-utils.test.ts

================================================
FILE: packages/workflow/README.md
================================================
![n8n.io - Workflow Automation](https://user-images.githubusercontent.com/65276001/173571060-9f2f6d7b-bac0-43b6-bdb2-001da9694058.png)

# n8n-workflow

Workflow base code for n8n

```
npm install n8n-workflow
```

## License

You can find the license information [here](https://github.com/n8n-io/n8n/blob/master/README.md#license)



================================================
FILE: packages/workflow/eslint.config.mjs
================================================
import { defineConfig } from 'eslint/config';
import { baseConfig } from '@n8n/eslint-config/base';

export default defineConfig(
	baseConfig,
	{
		rules: {
			'unicorn/filename-case': ['error', { case: 'kebabCase' }],
			complexity: ['error', 23],

			// TODO: remove these
			'no-empty': 'warn',
			'id-denylist': 'warn',
			'no-fallthrough': 'warn',
			'no-useless-escape': 'warn',
			'import-x/order': 'warn',
			'no-extra-boolean-cast': 'warn',
			'no-case-declarations': 'warn',
			'no-prototype-builtins': 'warn',
			'@typescript-eslint/naming-convention': 'warn',
			'@typescript-eslint/no-base-to-string': 'warn',
			'@typescript-eslint/no-redundant-type-constituents': 'warn',
			'@typescript-eslint/prefer-nullish-coalescing': 'warn',
			'@typescript-eslint/prefer-optional-chain': 'warn',
			'@typescript-eslint/return-await': ['error', 'always'],
			'@typescript-eslint/no-empty-object-type': 'warn',
			'@typescript-eslint/no-unsafe-function-type': 'warn',
			'@typescript-eslint/no-duplicate-type-constituents': 'warn',
			'@typescript-eslint/no-unsafe-call': 'warn',
		},
	},
	{
		files: ['**/*.test.ts'],
		rules: {
			// TODO: remove these
			'prefer-const': 'warn',
			'@typescript-eslint/no-unused-expressions': 'warn',
			'@typescript-eslint/no-explicit-any': 'warn',
			'@typescript-eslint/no-unsafe-member-access': 'warn',
			'@typescript-eslint/no-unsafe-assignment': 'warn',
			'@typescript-eslint/no-unsafe-return': 'warn',
			'@typescript-eslint/ban-ts-comment': ['warn', { 'ts-ignore': true }],
		},
	},
);



================================================
FILE: packages/workflow/jest.config.js
================================================
/** @type {import('jest').Config} */
module.exports = {
	...require('../../jest.config'),
};



================================================
FILE: packages/workflow/package.json
================================================
{
  "name": "n8n-workflow",
  "version": "1.107.0",
  "description": "Workflow base code of n8n",
  "types": "dist/esm/index.d.ts",
  "module": "dist/esm/index.js",
  "main": "dist/cjs/index.js",
  "exports": {
    ".": {
      "types": "./dist/esm/index.d.ts",
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js"
    },
    "./common": {
      "types": "./dist/esm/common/index.d.ts",
      "import": "./dist/esm/common/index.js",
      "require": "./dist/cjs/common/index.js"
    },
    "./*": "./*"
  },
  "scripts": {
    "clean": "rimraf dist .turbo",
    "dev": "pnpm watch",
    "typecheck": "tsc --noEmit",
    "build:vite": "vite build",
    "build": "tsc --build tsconfig.build.esm.json tsconfig.build.cjs.json",
    "format": "biome format --write .",
    "format:check": "biome ci .",
    "lint": "eslint src --quiet",
    "lint:fix": "eslint src --fix",
    "watch": "tsc --build tsconfig.build.esm.json tsconfig.build.cjs.json --watch",
    "test": "vitest run",
    "test:dev": "vitest --watch"
  },
  "files": [
    "dist/**/*"
  ],
  "devDependencies": {
    "@langchain/core": "catalog:",
    "@n8n/config": "workspace:*",
    "@n8n/typescript-config": "workspace:*",
    "@n8n/vitest-config": "workspace:*",
    "@types/express": "catalog:",
    "@types/jmespath": "^0.15.0",
    "@types/lodash": "catalog:",
    "@types/luxon": "3.2.0",
    "@types/md5": "^2.3.5",
    "@types/xml2js": "catalog:",
    "vitest": "catalog:",
    "vitest-mock-extended": "catalog:"
  },
  "dependencies": {
    "@n8n/errors": "workspace:^",
    "@n8n/tournament": "1.0.6",
    "ast-types": "0.15.2",
    "callsites": "catalog:",
    "esprima-next": "5.8.4",
    "form-data": "catalog:",
    "jmespath": "0.16.0",
    "js-base64": "catalog:",
    "jssha": "3.3.1",
    "lodash": "catalog:",
    "luxon": "catalog:",
    "md5": "2.3.0",
    "recast": "0.22.0",
    "title-case": "3.0.3",
    "transliteration": "2.3.5",
    "xml2js": "catalog:",
    "zod": "catalog:"
  }
}



================================================
FILE: packages/workflow/tsconfig.build.cjs.json
================================================
{
	"extends": ["./tsconfig.json", "@n8n/typescript-config/modern/tsconfig.cjs.json"],
	"compilerOptions": {
		"rootDir": "src",
		"outDir": "dist/cjs",
		"tsBuildInfoFile": "dist/cjs/typecheck.tsbuildinfo"
	},
	"include": ["src/**/*.ts"],
	"exclude": ["node_modules"]
}



================================================
FILE: packages/workflow/tsconfig.build.esm.json
================================================
{
	"extends": ["./tsconfig.json"],
	"compilerOptions": {
		"rootDir": "src",
		"outDir": "dist/esm",
		"tsBuildInfoFile": "dist/esm/typecheck.tsbuildinfo"
	},
	"include": ["src/**/*.ts"],
	"exclude": ["node_modules"]
}



================================================
FILE: packages/workflow/tsconfig.json
================================================
{
	"extends": "@n8n/typescript-config/modern/tsconfig.json",
	"compilerOptions": {
		"rootDir": ".",
		"noUncheckedIndexedAccess": false,
		"types": ["vite/client", "vitest/globals"]
	},
	"include": ["src/**/*.ts", "test/**/*.ts", "vitest.config.ts"],
	"exclude": ["node_modules"]
}



================================================
FILE: packages/workflow/vitest.config.ts
================================================
import { createVitestConfig } from '@n8n/vitest-config/node';

export default createVitestConfig({ include: ['test/**/*.test.ts'] });



================================================
FILE: packages/workflow/src/augment-object.ts
================================================
import type { IDataObject } from './interfaces';

const defaultPropertyDescriptor = Object.freeze({ enumerable: true, configurable: true });

// eslint-disable-next-line @typescript-eslint/unbound-method
const { hasOwnProperty } = Object.prototype;

const augmentedObjects = new WeakSet<object>();

function augment<T>(value: T): T {
	if (typeof value !== 'object' || value === null || value instanceof RegExp) return value;
	if (value instanceof Date) return new Date(value.valueOf()) as T;
	if (value instanceof Uint8Array) return value.slice() as T;

	if (Array.isArray(value)) return augmentArray(value) as T;

	return augmentObject(value) as T;
}

export function augmentArray<T>(data: T[]): T[] {
	if (augmentedObjects.has(data)) return data;

	let newData: unknown[] | undefined = undefined;

	function getData(): unknown[] {
		if (newData === undefined) {
			newData = [...data];
		}
		return newData;
	}

	const proxy = new Proxy(data, {
		deleteProperty(_target, key: string) {
			return Reflect.deleteProperty(getData(), key);
		},
		get(target, key: string, receiver): unknown {
			if (key === 'constructor') return Array;
			const value = Reflect.get(newData ?? target, key, receiver) as unknown;
			const newValue = augment(value);
			if (newValue !== value) {
				newData = getData();
				Reflect.set(newData, key, newValue);
				return newValue;
			}
			return value;
		},
		getOwnPropertyDescriptor(target, key) {
			if (newData === undefined) {
				return Reflect.getOwnPropertyDescriptor(target, key);
			}

			if (key === 'length') {
				return Reflect.getOwnPropertyDescriptor(newData, key);
			}

			return Object.getOwnPropertyDescriptor(data, key) ?? defaultPropertyDescriptor;
		},
		has(target, key) {
			return Reflect.has(newData ?? target, key);
		},
		ownKeys(target) {
			return Reflect.ownKeys(newData ?? target);
		},
		set(_target, key: string, newValue: unknown) {
			// Always proxy all objects. Like that we can check in get simply if it
			// is a proxy and it does then not matter if it was already there from the
			// beginning and it got proxied at some point or set later and so theoretically
			// does not have to get proxied
			return Reflect.set(getData(), key, augment(newValue));
		},
	});

	augmentedObjects.add(proxy);
	return proxy;
}

export function augmentObject<T extends object>(data: T): T {
	if (augmentedObjects.has(data)) return data;

	const newData = {} as IDataObject;
	const deletedProperties = new Set<string | symbol>();

	const proxy = new Proxy(data, {
		get(target, key: string, receiver): unknown {
			if (key === 'constructor') return Object;

			if (deletedProperties.has(key)) {
				return undefined;
			}

			if (hasOwnProperty.call(newData, key)) {
				return newData[key];
			}

			const value = Reflect.get(target, key, receiver);

			if (typeof value !== 'object' || value === null) return value;
			if (value instanceof RegExp) return value.toString();
			if ('toJSON' in value && typeof value.toJSON === 'function') return value.toJSON() as T;

			const newValue = augment(value);
			if (newValue !== value) {
				Object.assign(newData, { [key]: newValue });
				return newValue;
			}

			return value;
		},
		deleteProperty(_target, key: string) {
			if (hasOwnProperty.call(newData, key)) {
				delete newData[key];
			}
			if (hasOwnProperty.call(data, key)) {
				deletedProperties.add(key);
			}

			return true;
		},
		set(target, key: string, newValue: unknown) {
			if (newValue === undefined) {
				if (key in newData) {
					delete newData[key];
				}
				if (key in target) {
					deletedProperties.add(key);
				}
				return true;
			}

			newData[key] = newValue as IDataObject;

			if (deletedProperties.has(key)) {
				deletedProperties.delete(key);
			}

			return true;
		},
		has(_target, key) {
			if (deletedProperties.has(key)) return false;
			const target = hasOwnProperty.call(newData, key) ? newData : data;
			return Reflect.has(target, key);
		},
		ownKeys(target) {
			const originalKeys = Reflect.ownKeys(target);
			const newKeys = Object.keys(newData);
			return [...new Set([...originalKeys, ...newKeys])].filter(
				(key) => !deletedProperties.has(key),
			);
		},

		getOwnPropertyDescriptor(_target, key) {
			if (deletedProperties.has(key)) return undefined;
			const target = hasOwnProperty.call(newData, key) ? newData : data;
			return Object.getOwnPropertyDescriptor(target, key);
		},
	});

	augmentedObjects.add(proxy);
	return proxy;
}



================================================
FILE: packages/workflow/src/constants.ts
================================================
export const DIGITS = '0123456789';
export const UPPERCASE_LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
export const LOWERCASE_LETTERS = UPPERCASE_LETTERS.toLowerCase();
export const ALPHABET = [DIGITS, UPPERCASE_LETTERS, LOWERCASE_LETTERS].join('');

export const BINARY_ENCODING = 'base64';
export const WAIT_INDEFINITELY = new Date('3000-01-01T00:00:00.000Z');

export const LOG_LEVELS = ['silent', 'error', 'warn', 'info', 'debug'] as const;

export const CODE_LANGUAGES = ['javaScript', 'python', 'json', 'html'] as const;
export const CODE_EXECUTION_MODES = ['runOnceForAllItems', 'runOnceForEachItem'] as const;

// Arbitrary value to represent an empty credential value
export const CREDENTIAL_EMPTY_VALUE = '__n8n_EMPTY_VALUE_7b1af746-3729-4c60-9b9b-e08eb29e58da';

export const FORM_TRIGGER_PATH_IDENTIFIER = 'n8n-form';

export const UNKNOWN_ERROR_MESSAGE = 'There was an unknown issue while executing the node';
export const UNKNOWN_ERROR_DESCRIPTION =
	'Double-check the node configuration and the service it connects to. Check the error details below and refer to the <a href="https://docs.n8n.io" target="_blank">n8n documentation</a> to troubleshoot the issue.';
export const UNKNOWN_ERROR_MESSAGE_CRED = 'UNKNOWN ERROR';

//n8n-nodes-base
export const STICKY_NODE_TYPE = 'n8n-nodes-base.stickyNote';
export const NO_OP_NODE_TYPE = 'n8n-nodes-base.noOp';
export const HTTP_REQUEST_NODE_TYPE = 'n8n-nodes-base.httpRequest';
export const WEBHOOK_NODE_TYPE = 'n8n-nodes-base.webhook';
export const MANUAL_TRIGGER_NODE_TYPE = 'n8n-nodes-base.manualTrigger';
export const EVALUATION_TRIGGER_NODE_TYPE = 'n8n-nodes-base.evaluationTrigger';
export const EVALUATION_NODE_TYPE = 'n8n-nodes-base.evaluation';
export const ERROR_TRIGGER_NODE_TYPE = 'n8n-nodes-base.errorTrigger';
export const START_NODE_TYPE = 'n8n-nodes-base.start';
export const EXECUTE_WORKFLOW_NODE_TYPE = 'n8n-nodes-base.executeWorkflow';
export const EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE = 'n8n-nodes-base.executeWorkflowTrigger';
export const CODE_NODE_TYPE = 'n8n-nodes-base.code';
export const FUNCTION_NODE_TYPE = 'n8n-nodes-base.function';
export const FUNCTION_ITEM_NODE_TYPE = 'n8n-nodes-base.functionItem';
export const MERGE_NODE_TYPE = 'n8n-nodes-base.merge';
export const AI_TRANSFORM_NODE_TYPE = 'n8n-nodes-base.aiTransform';
export const FORM_NODE_TYPE = 'n8n-nodes-base.form';
export const FORM_TRIGGER_NODE_TYPE = 'n8n-nodes-base.formTrigger';
export const CHAT_TRIGGER_NODE_TYPE = '@n8n/n8n-nodes-langchain.chatTrigger';
export const WAIT_NODE_TYPE = 'n8n-nodes-base.wait';
export const RESPOND_TO_WEBHOOK_NODE_TYPE = 'n8n-nodes-base.respondToWebhook';
export const HTML_NODE_TYPE = 'n8n-nodes-base.html';
export const MAILGUN_NODE_TYPE = 'n8n-nodes-base.mailgun';
export const POSTGRES_NODE_TYPE = 'n8n-nodes-base.postgres';
export const MYSQL_NODE_TYPE = 'n8n-nodes-base.mySql';

export const STARTING_NODE_TYPES = [
	MANUAL_TRIGGER_NODE_TYPE,
	EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE,
	ERROR_TRIGGER_NODE_TYPE,
	START_NODE_TYPE,
	EVALUATION_TRIGGER_NODE_TYPE,
];

export const SCRIPTING_NODE_TYPES = [
	FUNCTION_NODE_TYPE,
	FUNCTION_ITEM_NODE_TYPE,
	CODE_NODE_TYPE,
	AI_TRANSFORM_NODE_TYPE,
];

export const ADD_FORM_NOTICE = 'addFormPage';

/**
 * Nodes whose parameter values may refer to other nodes without expressions.
 * Their content may need to be updated when the referenced node is renamed.
 */
export const NODES_WITH_RENAMABLE_CONTENT = new Set([
	CODE_NODE_TYPE,
	FUNCTION_NODE_TYPE,
	FUNCTION_ITEM_NODE_TYPE,
	AI_TRANSFORM_NODE_TYPE,
]);
export const NODES_WITH_RENAMABLE_FORM_HTML_CONTENT = new Set([FORM_NODE_TYPE]);
export const NODES_WITH_RENAMEABLE_TOPLEVEL_HTML_CONTENT = new Set([
	MAILGUN_NODE_TYPE,
	HTML_NODE_TYPE,
]);

//@n8n/n8n-nodes-langchain
export const MANUAL_CHAT_TRIGGER_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.manualChatTrigger';
export const AGENT_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.agent';
export const CHAIN_LLM_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.chainLlm';
export const OPENAI_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.openAi';
export const CHAIN_SUMMARIZATION_LANGCHAIN_NODE_TYPE =
	'@n8n/n8n-nodes-langchain.chainSummarization';
export const AGENT_TOOL_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.agentTool';
export const CODE_TOOL_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.toolCode';
export const WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.toolWorkflow';
export const HTTP_REQUEST_TOOL_LANGCHAIN_NODE_TYPE = '@n8n/n8n-nodes-langchain.toolHttpRequest';

export const LANGCHAIN_CUSTOM_TOOLS = [
	CODE_TOOL_LANGCHAIN_NODE_TYPE,
	WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE,
	HTTP_REQUEST_TOOL_LANGCHAIN_NODE_TYPE,
];

export const SEND_AND_WAIT_OPERATION = 'sendAndWait';
export const AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT = 'codeGeneratedForPrompt';
export const AI_TRANSFORM_JS_CODE = 'jsCode';

/**
 * Key for an item standing in for a manual execution data item too large to be
 * sent live via pubsub. See {@link TRIMMED_TASK_DATA_CONNECTIONS} in constants
 * in `cli` package.
 */
export const TRIMMED_TASK_DATA_CONNECTIONS_KEY = '__isTrimmedManualExecutionDataItem';

export const OPEN_AI_API_CREDENTIAL_TYPE = 'openAiApi';
export const FREE_AI_CREDITS_ERROR_TYPE = 'free_ai_credits_request_error';
export const FREE_AI_CREDITS_USED_ALL_CREDITS_ERROR_CODE = 400;

export const FROM_AI_AUTO_GENERATED_MARKER = '/*n8n-auto-generated-fromAI-override*/';

export const PROJECT_ROOT = '0';

export const WAITING_FORMS_EXECUTION_STATUS = 'n8n-execution-status';

export const CHAT_WAIT_USER_REPLY = 'waitUserReply';



================================================
FILE: packages/workflow/src/cron.ts
================================================
import type { CronExpression } from './interfaces';
import { randomInt } from './utils';

interface BaseTriggerTime<T extends string> {
	mode: T;
}

interface CustomTrigger extends BaseTriggerTime<'custom'> {
	cronExpression: CronExpression;
}

interface EveryX<U extends string> extends BaseTriggerTime<'everyX'> {
	unit: U;
	value: number;
}

type EveryMinute = BaseTriggerTime<'everyMinute'>;
type EveryXMinutes = EveryX<'minutes'>;

interface EveryHour extends BaseTriggerTime<'everyHour'> {
	minute: number; // 0 - 59
}
type EveryXHours = EveryX<'hours'>;

interface EveryDay extends BaseTriggerTime<'everyDay'> {
	hour: number; // 0 - 23
	minute: number; // 0 - 59
}

interface EveryWeek extends BaseTriggerTime<'everyWeek'> {
	hour: number; // 0 - 23
	minute: number; // 0 - 59
	weekday: number; // 0 - 6(Sun - Sat)
}

interface EveryMonth extends BaseTriggerTime<'everyMonth'> {
	hour: number; // 0 - 23
	minute: number; // 0 - 59
	dayOfMonth: number; // 1 - 31
}

export type TriggerTime =
	| CustomTrigger
	| EveryMinute
	| EveryXMinutes
	| EveryHour
	| EveryXHours
	| EveryDay
	| EveryWeek
	| EveryMonth;

export const toCronExpression = (item: TriggerTime): CronExpression => {
	const randomSecond = randomInt(60);

	if (item.mode === 'everyMinute') return `${randomSecond} * * * * *`;
	if (item.mode === 'everyHour') return `${randomSecond} ${item.minute} * * * *`;

	if (item.mode === 'everyX') {
		if (item.unit === 'minutes') return `${randomSecond} */${item.value} * * * *`;

		const randomMinute = randomInt(60);
		if (item.unit === 'hours') return `${randomSecond} ${randomMinute} */${item.value} * * *`;
	}
	if (item.mode === 'everyDay') return `${randomSecond} ${item.minute} ${item.hour} * * *`;
	if (item.mode === 'everyWeek')
		return `${randomSecond} ${item.minute} ${item.hour} * * ${item.weekday}`;

	if (item.mode === 'everyMonth')
		return `${randomSecond} ${item.minute} ${item.hour} ${item.dayOfMonth} * *`;

	return item.cronExpression.trim() as CronExpression;
};



================================================
FILE: packages/workflow/src/data-store.types.ts
================================================
export type DataStoreColumnType = 'string' | 'number' | 'boolean' | 'date';

export type DataStoreColumn = {
	id: string;
	name: string;
	type: DataStoreColumnType;
	index: number;
	dataTableId: string;
};

export type DataStore = {
	id: string;
	name: string;
	columns: DataStoreColumn[];
	createdAt: Date;
	updatedAt: Date;
	projectId: string;
};

export type CreateDataStoreColumnOptions = Pick<DataStoreColumn, 'name' | 'type'> &
	Partial<Pick<DataStoreColumn, 'index'>>;

export type CreateDataStoreOptions = Pick<DataStore, 'name'> & {
	columns: CreateDataStoreColumnOptions[];
};

export type UpdateDataStoreOptions = { name: string };

export type ListDataStoreOptions = {
	filter?: Record<string, string | string[]>;
	sortBy?:
		| 'name:asc'
		| 'name:desc'
		| 'createdAt:asc'
		| 'createdAt:desc'
		| 'updatedAt:asc'
		| 'updatedAt:desc'
		| 'sizeBytes:asc'
		| 'sizeBytes:desc';
	take?: number;
	skip?: number;
};

export type ListDataStoreContentFilter = {
	type: 'and' | 'or';
	filters: Array<{
		columnName: string;
		condition: 'eq' | 'neq' | 'like' | 'ilike' | 'gt' | 'gte' | 'lt' | 'lte';
		value: DataStoreColumnJsType;
	}>;
};

export type ListDataStoreRowsOptions = {
	filter?: ListDataStoreContentFilter;
	sortBy?: [string, 'ASC' | 'DESC'];
	take?: number;
	skip?: number;
};

export type UpdateDataStoreRowsOptions = {
	filter: Record<string, DataStoreColumnJsType>;
	data: DataStoreRow;
};

export type UpsertDataStoreRowsOptions = {
	rows: DataStoreRows;
	matchFields: string[];
};

export type MoveDataStoreColumnOptions = {
	targetIndex: number;
};

export type AddDataStoreColumnOptions = Pick<DataStoreColumn, 'name' | 'type'> &
	Partial<Pick<DataStoreColumn, 'index'>>;

export type DataStoreColumnJsType = string | number | boolean | Date | null;

export const DATA_TABLE_SYSTEM_COLUMNS = ['id', 'createdAt', 'updatedAt'] as const;

export type DataStoreRowReturnBase = {
	id: number;
	createdAt: Date;
	updatedAt: Date;
};
export type DataStoreRow = Record<string, DataStoreColumnJsType>;
export type DataStoreRows = DataStoreRow[];
export type DataStoreRowReturn = DataStoreRow & DataStoreRowReturnBase;
export type DataStoreRowsReturn = DataStoreRowReturn[];

// APIs for a data store service operating on a specific projectId
export interface IDataStoreProjectAggregateService {
	getProjectId(): string;

	createDataStore(options: CreateDataStoreOptions): Promise<DataStore>;

	getManyAndCount(options: ListDataStoreOptions): Promise<{ count: number; data: DataStore[] }>;

	deleteDataStoreAll(): Promise<boolean>;
}
// APIs for a data store service operating on a specific projectId and dataStoreId
export interface IDataStoreProjectService {
	updateDataStore(options: UpdateDataStoreOptions): Promise<boolean>;

	deleteDataStore(): Promise<boolean>;

	getColumns(): Promise<DataStoreColumn[]>;

	addColumn(options: AddDataStoreColumnOptions): Promise<DataStoreColumn>;

	moveColumn(columnId: string, options: MoveDataStoreColumnOptions): Promise<boolean>;

	deleteColumn(columnId: string): Promise<boolean>;

	getManyRowsAndCount(
		dto: Partial<ListDataStoreRowsOptions>,
	): Promise<{ count: number; data: DataStoreRowsReturn }>;

	insertRows(rows: DataStoreRows): Promise<DataStoreRowReturn[]>;

	updateRows(options: UpdateDataStoreRowsOptions): Promise<DataStoreRowReturn[]>;

	upsertRows(options: UpsertDataStoreRowsOptions): Promise<DataStoreRowReturn[]>;

	deleteRows(ids: number[]): Promise<boolean>;
}



================================================
FILE: packages/workflow/src/deferred-promise.ts
================================================
type ResolveFn<T> = (result: T | PromiseLike<T>) => void;
type RejectFn = (error: Error) => void;

export interface IDeferredPromise<T> {
	promise: Promise<T>;
	resolve: ResolveFn<T>;
	reject: RejectFn;
}

export function createDeferredPromise<T = void>(): IDeferredPromise<T> {
	const deferred: Partial<IDeferredPromise<T>> = {};
	deferred.promise = new Promise<T>((resolve, reject) => {
		deferred.resolve = resolve;
		deferred.reject = reject;
	});
	return deferred as IDeferredPromise<T>;
}



================================================
FILE: packages/workflow/src/evaluation-helpers.ts
================================================
/**
 * Evaluation-related utility functions
 *
 * This file contains utilities that need to be shared between different packages
 * to avoid circular dependencies. For example, the evaluation test-runner (in CLI package)
 * and the Evaluation node (in nodes-base package) both need to know which metrics
 * require AI model connections, but they can't import from each other directly.
 *
 * By placing shared utilities here in the workflow package (which both packages depend on),
 * we avoid circular dependency issues.
 */

/**
 * Default metric type used in evaluations
 */
export const DEFAULT_EVALUATION_METRIC = 'correctness';

/**
 * Determines if a given evaluation metric requires an AI model connection
 * @param metric The metric name to check
 * @returns true if the metric requires an AI model connection
 */
export function metricRequiresModelConnection(metric: string): boolean {
	return ['correctness', 'helpfulness'].includes(metric);
}



================================================
FILE: packages/workflow/src/execution-status.ts
================================================
export const ExecutionStatusList = [
	'canceled',
	'crashed',
	'error',
	'new',
	'running',
	'success',
	'unknown',
	'waiting',
] as const;

export type ExecutionStatus = (typeof ExecutionStatusList)[number];



================================================
FILE: packages/workflow/src/expression-evaluator-proxy.ts
================================================
import { Tournament } from '@n8n/tournament';

import { PrototypeSanitizer } from './expression-sandboxing';

type Evaluator = (expr: string, data: unknown) => string | null | (() => unknown);
type ErrorHandler = (error: Error) => void;

const errorHandler: ErrorHandler = () => {};
const tournamentEvaluator = new Tournament(errorHandler, undefined, undefined, {
	before: [],
	after: [PrototypeSanitizer],
});
const evaluator: Evaluator = tournamentEvaluator.execute.bind(tournamentEvaluator);

export const setErrorHandler = (handler: ErrorHandler) => {
	tournamentEvaluator.errorHandler = handler;
};

export const evaluateExpression: Evaluator = (expr, data) => {
	return evaluator(expr, data);
};



================================================
FILE: packages/workflow/src/expression-sandboxing.ts
================================================
import { type ASTAfterHook, astBuilders as b, astVisit } from '@n8n/tournament';

import { ExpressionError } from './errors';
import { isSafeObjectProperty } from './utils';

export const sanitizerName = '__sanitize';
const sanitizerIdentifier = b.identifier(sanitizerName);

export const PrototypeSanitizer: ASTAfterHook = (ast, dataNode) => {
	astVisit(ast, {
		visitMemberExpression(path) {
			this.traverse(path);
			const node = path.node;
			if (!node.computed) {
				// This is static, so we're safe to error here
				if (node.property.type !== 'Identifier') {
					throw new ExpressionError(
						`Unknown property type ${node.property.type} while sanitising expression`,
					);
				}

				if (!isSafeObjectProperty(node.property.name)) {
					throw new ExpressionError(
						`Cannot access "${node.property.name}" due to security concerns`,
					);
				}
			} else if (node.property.type === 'StringLiteral' || node.property.type === 'Literal') {
				// Check any static strings against our forbidden list
				if (!isSafeObjectProperty(node.property.value as string)) {
					throw new ExpressionError(
						`Cannot access "${node.property.value as string}" due to security concerns`,
					);
				}
			} else if (!node.property.type.endsWith('Literal')) {
				// This isn't a literal value, so we need to wrap it
				path.replace(
					b.memberExpression(
						// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
						node.object as any,
						// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
						b.callExpression(b.memberExpression(dataNode, sanitizerIdentifier), [
							// eslint-disable-next-line @typescript-eslint/no-explicit-any
							node.property as any,
						]),
						true,
					),
				);
			}
		},
	});
};

export const sanitizer = (value: unknown): unknown => {
	if (!isSafeObjectProperty(value as string)) {
		throw new ExpressionError(`Cannot access "${value as string}" due to security concerns`);
	}
	return value;
};



================================================
FILE: packages/workflow/src/expression.ts
================================================
import { DateTime, Duration, Interval } from 'luxon';

import { ApplicationError } from '@n8n/errors';
import { ExpressionExtensionError } from './errors/expression-extension.error';
import { ExpressionError } from './errors/expression.error';
import { evaluateExpression, setErrorHandler } from './expression-evaluator-proxy';
import { sanitizer, sanitizerName } from './expression-sandboxing';
import { isExpression } from './expressions/expression-helpers';
import { extend, extendOptional } from './extensions';
import { extendSyntax } from './extensions/expression-extension';
import { extendedFunctions } from './extensions/extended-functions';
import { getGlobalState } from './global-state';
import type {
	IDataObject,
	IExecuteData,
	INode,
	INodeExecutionData,
	INodeParameterResourceLocator,
	INodeParameters,
	IRunExecutionData,
	IWorkflowDataProxyAdditionalKeys,
	IWorkflowDataProxyData,
	NodeParameterValue,
	NodeParameterValueType,
	WorkflowExecuteMode,
} from './interfaces';
import type { Workflow } from './workflow';
import { WorkflowDataProxy } from './workflow-data-proxy';

const IS_FRONTEND_IN_DEV_MODE =
	typeof process === 'object' &&
	Object.keys(process).length === 1 &&
	'env' in process &&
	Object.keys(process.env).length === 0;

const IS_FRONTEND = typeof process === 'undefined' || IS_FRONTEND_IN_DEV_MODE;

const isSyntaxError = (error: unknown): error is SyntaxError =>
	error instanceof SyntaxError || (error instanceof Error && error.name === 'SyntaxError');

const isExpressionError = (error: unknown): error is ExpressionError =>
	error instanceof ExpressionError || error instanceof ExpressionExtensionError;

const isTypeError = (error: unknown): error is TypeError =>
	error instanceof TypeError || (error instanceof Error && error.name === 'TypeError');

// Make sure that error get forwarded
setErrorHandler((error: Error) => {
	if (isExpressionError(error)) throw error;
});

export class Expression {
	constructor(private readonly workflow: Workflow) {}

	static resolveWithoutWorkflow(expression: string, data: IDataObject = {}) {
		return evaluateExpression(expression, data);
	}

	/**
	 * Converts an object to a string in a way to make it clear that
	 * the value comes from an object
	 *
	 */
	convertObjectValueToString(value: object): string {
		if (value instanceof DateTime && value.invalidReason !== null) {
			throw new ApplicationError('invalid DateTime');
		}

		if (value === null) {
			return 'null';
		}

		let typeName = value.constructor.name ?? 'Object';
		if (DateTime.isDateTime(value)) {
			typeName = 'DateTime';
		}

		let result = '';
		if (value instanceof Date) {
			// We don't want to use JSON.stringify for dates since it disregards workflow timezone
			result = DateTime.fromJSDate(value, {
				zone: this.workflow.settings?.timezone ?? getGlobalState().defaultTimezone,
			}).toISO();
		} else if (DateTime.isDateTime(value)) {
			result = value.toString();
		} else {
			result = JSON.stringify(value);
		}

		result = result
			.replace(/,"/g, ', "') // spacing for
			.replace(/":/g, '": '); // readability

		return `[${typeName}: ${result}]`;
	}

	/**
	 * Resolves the parameter value.  If it is an expression it will execute it and
	 * return the result. For everything simply the supplied value will be returned.
	 *
	 * @param {(IRunExecutionData | null)} runExecutionData
	 * @param {boolean} [returnObjectAsString=false]
	 */
	// TODO: Clean that up at some point and move all the options into an options object
	// eslint-disable-next-line complexity
	resolveSimpleParameterValue(
		parameterValue: NodeParameterValue,
		siblingParameters: INodeParameters,
		runExecutionData: IRunExecutionData | null,
		runIndex: number,
		itemIndex: number,
		activeNodeName: string,
		connectionInputData: INodeExecutionData[],
		mode: WorkflowExecuteMode,
		additionalKeys: IWorkflowDataProxyAdditionalKeys,
		executeData?: IExecuteData,
		returnObjectAsString = false,
		selfData = {},
		contextNodeName?: string,
	): NodeParameterValue | INodeParameters | NodeParameterValue[] | INodeParameters[] {
		// Check if it is an expression
		if (!isExpression(parameterValue)) {
			// Is no expression so return value
			return parameterValue;
		}

		// Is an expression

		// Remove the equal sign

		parameterValue = parameterValue.substr(1);

		// Generate a data proxy which allows to query workflow data
		const dataProxy = new WorkflowDataProxy(
			this.workflow,
			runExecutionData,
			runIndex,
			itemIndex,
			activeNodeName,
			connectionInputData,
			siblingParameters,
			mode,
			additionalKeys,
			executeData,
			-1,
			selfData,
			contextNodeName,
		);
		const data = dataProxy.getDataProxy();

		// Support only a subset of process properties
		data.process =
			typeof process !== 'undefined'
				? {
						arch: process.arch,
						env: process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE === 'true' ? {} : process.env,
						platform: process.platform,
						pid: process.pid,
						ppid: process.ppid,
						release: process.release,
						version: process.pid,
						versions: process.versions,
					}
				: {};

		/**
		 * Denylist
		 */

		data.document = {};
		data.global = {};
		data.window = {};
		data.Window = {};
		data.this = {};
		data.globalThis = {};
		data.self = {};

		// Alerts
		data.alert = {};
		data.prompt = {};
		data.confirm = {};

		// Prevent Remote Code Execution
		data.eval = {};
		data.uneval = {};
		data.setTimeout = {};
		data.setInterval = {};
		data.Function = {};

		// Prevent requests
		data.fetch = {};
		data.XMLHttpRequest = {};

		// Prevent control abstraction
		data.Promise = {};
		data.Generator = {};
		data.GeneratorFunction = {};
		data.AsyncFunction = {};
		data.AsyncGenerator = {};
		data.AsyncGeneratorFunction = {};

		// Prevent WASM
		data.WebAssembly = {};

		// Prevent Reflection
		data.Reflect = {};
		data.Proxy = {};

		// Deprecated
		data.escape = {};
		data.unescape = {};

		/**
		 * Allowlist
		 */

		// Dates
		data.Date = Date;
		data.DateTime = DateTime;
		data.Interval = Interval;
		data.Duration = Duration;

		// Objects
		data.Object = Object;

		// Arrays
		data.Array = Array;
		data.Int8Array = Int8Array;
		data.Uint8Array = Uint8Array;
		data.Uint8ClampedArray = Uint8ClampedArray;
		data.Int16Array = Int16Array;
		data.Uint16Array = Uint16Array;
		data.Int32Array = Int32Array;
		data.Uint32Array = Uint32Array;
		data.Float32Array = Float32Array;
		data.Float64Array = Float64Array;
		data.BigInt64Array = typeof BigInt64Array !== 'undefined' ? BigInt64Array : {};
		data.BigUint64Array = typeof BigUint64Array !== 'undefined' ? BigUint64Array : {};

		// Collections
		data.Map = typeof Map !== 'undefined' ? Map : {};
		data.WeakMap = typeof WeakMap !== 'undefined' ? WeakMap : {};
		data.Set = typeof Set !== 'undefined' ? Set : {};
		data.WeakSet = typeof WeakSet !== 'undefined' ? WeakSet : {};

		// Errors
		data.Error = Error;
		data.TypeError = TypeError;
		data.SyntaxError = SyntaxError;
		data.EvalError = EvalError;
		data.RangeError = RangeError;
		data.ReferenceError = ReferenceError;
		data.URIError = URIError;

		// Internationalization
		data.Intl = typeof Intl !== 'undefined' ? Intl : {};

		// Text
		// eslint-disable-next-line id-denylist
		data.String = String;
		data.RegExp = RegExp;

		// Math
		data.Math = Math;
		// eslint-disable-next-line id-denylist
		data.Number = Number;
		data.BigInt = typeof BigInt !== 'undefined' ? BigInt : {};
		data.Infinity = Infinity;
		data.NaN = NaN;
		data.isFinite = Number.isFinite;
		data.isNaN = Number.isNaN;
		data.parseFloat = parseFloat;
		data.parseInt = parseInt;

		// Structured data
		data.JSON = JSON;
		data.ArrayBuffer = typeof ArrayBuffer !== 'undefined' ? ArrayBuffer : {};
		data.SharedArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : {};
		data.Atomics = typeof Atomics !== 'undefined' ? Atomics : {};
		data.DataView = typeof DataView !== 'undefined' ? DataView : {};

		data.encodeURI = encodeURI;
		data.encodeURIComponent = encodeURIComponent;
		data.decodeURI = decodeURI;
		data.decodeURIComponent = decodeURIComponent;

		// Other
		// eslint-disable-next-line id-denylist
		data.Boolean = Boolean;
		data.Symbol = Symbol;

		// expression extensions
		data.extend = extend;
		data.extendOptional = extendOptional;

		data[sanitizerName] = sanitizer;

		Object.assign(data, extendedFunctions);

		const constructorValidation = new RegExp(/\.\s*constructor/gm);
		if (parameterValue.match(constructorValidation)) {
			throw new ExpressionError('Expression contains invalid constructor function call', {
				causeDetailed: 'Constructor override attempt is not allowed due to security concerns',
				runIndex,
				itemIndex,
			});
		}

		// Execute the expression
		const extendedExpression = extendSyntax(parameterValue);
		const returnValue = this.renderExpression(extendedExpression, data);
		if (typeof returnValue === 'function') {
			if (returnValue.name === '$') throw new ApplicationError('invalid syntax');

			if (returnValue.name === 'DateTime')
				throw new ApplicationError('this is a DateTime, please access its methods');

			throw new ApplicationError('this is a function, please add ()');
		} else if (typeof returnValue === 'string') {
			return returnValue;
		} else if (returnValue !== null && typeof returnValue === 'object') {
			if (returnObjectAsString) {
				return this.convertObjectValueToString(returnValue);
			}
		}

		return returnValue;
	}

	private renderExpression(expression: string, data: IWorkflowDataProxyData) {
		try {
			return evaluateExpression(expression, data);
		} catch (error) {
			if (isExpressionError(error)) throw error;

			if (isSyntaxError(error)) throw new ApplicationError('invalid syntax');

			if (isTypeError(error) && IS_FRONTEND && error.message.endsWith('is not a function')) {
				const match = error.message.match(/(?<msg>[^.]+is not a function)/);

				if (!match?.groups?.msg) return null;

				throw new ApplicationError(match.groups.msg);
			}
		}

		return null;
	}

	/**
	 * Resolves value of parameter. But does not work for workflow-data.
	 *
	 * @param {(string | undefined)} parameterValue
	 */
	getSimpleParameterValue(
		node: INode,
		parameterValue: string | boolean | undefined,
		mode: WorkflowExecuteMode,
		additionalKeys: IWorkflowDataProxyAdditionalKeys,
		executeData?: IExecuteData,
		defaultValue?: boolean | number | string | unknown[],
	): boolean | number | string | undefined | unknown[] {
		if (parameterValue === undefined) {
			// Value is not set so return the default
			return defaultValue;
		}

		// Get the value of the node (can be an expression)
		const runIndex = 0;
		const itemIndex = 0;
		const connectionInputData: INodeExecutionData[] = [];
		const runData: IRunExecutionData = {
			resultData: {
				runData: {},
			},
		};

		return this.getParameterValue(
			parameterValue,
			runData,
			runIndex,
			itemIndex,
			node.name,
			connectionInputData,
			mode,
			additionalKeys,
			executeData,
		) as boolean | number | string | undefined;
	}

	/**
	 * Resolves value of complex parameter. But does not work for workflow-data.
	 *
	 * @param {(NodeParameterValue | INodeParameters | NodeParameterValue[] | INodeParameters[])} parameterValue
	 * @param {(NodeParameterValue | INodeParameters | NodeParameterValue[] | INodeParameters[] | undefined)} [defaultValue]
	 */
	getComplexParameterValue(
		node: INode,
		parameterValue: NodeParameterValue | INodeParameters | NodeParameterValue[] | INodeParameters[],
		mode: WorkflowExecuteMode,
		additionalKeys: IWorkflowDataProxyAdditionalKeys,
		executeData?: IExecuteData,
		defaultValue: NodeParameterValueType | undefined = undefined,
		selfData = {},
	): NodeParameterValueType | undefined {
		if (parameterValue === undefined) {
			// Value is not set so return the default
			return defaultValue;
		}

		// Get the value of the node (can be an expression)
		const runIndex = 0;
		const itemIndex = 0;
		const connectionInputData: INodeExecutionData[] = [];
		const runData: IRunExecutionData = {
			resultData: {
				runData: {},
			},
		};

		// Resolve the "outer" main values
		const returnData = this.getParameterValue(
			parameterValue,
			runData,
			runIndex,
			itemIndex,
			node.name,
			connectionInputData,
			mode,
			additionalKeys,
			executeData,
			false,
			selfData,
		);

		// Resolve the "inner" values
		return this.getParameterValue(
			returnData,
			runData,
			runIndex,
			itemIndex,
			node.name,
			connectionInputData,
			mode,
			additionalKeys,
			executeData,
			false,
			selfData,
		);
	}

	/**
	 * Returns the resolved node parameter value. If it is an expression it will execute it and
	 * return the result. If the value to resolve is an array or object it will do the same
	 * for all of the items and values.
	 *
	 * @param {(NodeParameterValue | INodeParameters | NodeParameterValue[] | INodeParameters[])} parameterValue
	 * @param {(IRunExecutionData | null)} runExecutionData
	 * @param {boolean} [returnObjectAsString=false]
	 */
	// TODO: Clean that up at some point and move all the options into an options object
	getParameterValue(
		parameterValue: NodeParameterValueType | INodeParameterResourceLocator,
		runExecutionData: IRunExecutionData | null,
		runIndex: number,
		itemIndex: number,
		activeNodeName: string,
		connectionInputData: INodeExecutionData[],
		mode: WorkflowExecuteMode,
		additionalKeys: IWorkflowDataProxyAdditionalKeys,
		executeData?: IExecuteData,
		returnObjectAsString = false,
		selfData = {},
		contextNodeName?: string,
	): NodeParameterValueType {
		// Helper function which returns true when the parameter is a complex one or array
		const isComplexParameter = (value: NodeParameterValueType) => {
			return typeof value === 'object';
		};

		// Helper function which resolves a parameter value depending on if it is simply or not
		const resolveParameterValue = (
			value: NodeParameterValueType,
			siblingParameters: INodeParameters,
		) => {
			if (isComplexParameter(value)) {
				return this.getParameterValue(
					value,
					runExecutionData,
					runIndex,
					itemIndex,
					activeNodeName,
					connectionInputData,
					mode,
					additionalKeys,
					executeData,
					returnObjectAsString,
					selfData,
					contextNodeName,
				);
			}

			return this.resolveSimpleParameterValue(
				value as NodeParameterValue,
				siblingParameters,
				runExecutionData,
				runIndex,
				itemIndex,
				activeNodeName,
				connectionInputData,
				mode,
				additionalKeys,
				executeData,
				returnObjectAsString,
				selfData,
				contextNodeName,
			);
		};

		// Check if it value is a simple one that we can get it resolved directly
		if (!isComplexParameter(parameterValue)) {
			return this.resolveSimpleParameterValue(
				parameterValue as NodeParameterValue,
				{},
				runExecutionData,
				runIndex,
				itemIndex,
				activeNodeName,
				connectionInputData,
				mode,
				additionalKeys,
				executeData,
				returnObjectAsString,
				selfData,
				contextNodeName,
			);
		}

		// The parameter value is complex so resolve depending on type
		if (Array.isArray(parameterValue)) {
			// Data is an array
			const returnData = parameterValue.map((item) =>
				resolveParameterValue(item as NodeParameterValueType, {}),
			);
			return returnData as NodeParameterValue[] | INodeParameters[];
		}

		if (parameterValue === null || parameterValue === undefined) {
			return parameterValue;
		}

		if (typeof parameterValue !== 'object') {
			return {};
		}

		// Data is an object
		const returnData: INodeParameters = {};

		for (const [key, value] of Object.entries(parameterValue)) {
			returnData[key] = resolveParameterValue(
				value as NodeParameterValueType,
				parameterValue as INodeParameters,
			);
		}

		if (returnObjectAsString && typeof returnData === 'object') {
			return this.convertObjectValueToString(returnData);
		}

		return returnData;
	}
}



================================================
FILE: packages/workflow/src/from-ai-parse-utils.ts
================================================
import { z } from 'zod';

import { jsonParse } from './utils';

/**
 * This file contains the logic for parsing node parameters and extracting $fromAI calls
 */

export type FromAIArgumentType = 'string' | 'number' | 'boolean' | 'json';
export type FromAIArgument = {
	key: string;
	description?: string;
	type?: FromAIArgumentType;
	defaultValue?: string | number | boolean | Record<string, unknown>;
};

class ParseError extends Error {}

/**
 * Generates a Zod schema based on the provided FromAIArgument placeholder.
 * @param placeholder The FromAIArgument object containing key, type, description, and defaultValue.
 * @returns A Zod schema corresponding to the placeholder's type and constraints.
 */
export function generateZodSchema(placeholder: FromAIArgument): z.ZodTypeAny {
	let schema: z.ZodTypeAny;

	switch (placeholder.type?.toLowerCase()) {
		case 'string':
			schema = z.string();
			break;
		case 'number':
			schema = z.number();
			break;
		case 'boolean':
			schema = z.boolean();
			break;
		case 'json': {
			interface CustomSchemaDef extends z.ZodTypeDef {
				jsonSchema?: {
					anyOf: [
						{
							type: 'object';
							minProperties: number;
							additionalProperties: boolean;
						},
						{
							type: 'array';
							minItems: number;
						},
					];
				};
			}

			// Create a custom schema to validate that the incoming data is either a non-empty object or a non-empty array.
			const customSchema = z.custom<Record<string, unknown> | unknown[]>(
				(data: unknown) => {
					if (data === null || typeof data !== 'object') return false;
					if (Array.isArray(data)) {
						return data.length > 0;
					}
					return Object.keys(data).length > 0;
				},
				{
					message: 'Value must be a non-empty object or a non-empty array',
				},
			);

			// Cast the custom schema to a type that includes our JSON metadata.
			const typedSchema = customSchema as z.ZodType<
				Record<string, unknown> | unknown[],
				CustomSchemaDef
			>;

			// Attach the updated `jsonSchema` metadata to the internal definition.
			typedSchema._def.jsonSchema = {
				anyOf: [
					{
						type: 'object',
						minProperties: 1,
						additionalProperties: true,
					},
					{
						type: 'array',
						minItems: 1,
					},
				],
			};

			schema = typedSchema;
			break;
		}
		default:
			schema = z.string();
	}

	if (placeholder.description) {
		schema = schema.describe(`${schema.description ?? ''} ${placeholder.description}`.trim());
	}

	if (placeholder.defaultValue !== undefined) {
		schema = schema.default(placeholder.defaultValue);
	}

	return schema;
}

/**
 * Parses the default value, preserving its original type.
 * @param value The default value as a string.
 * @returns The parsed default value in its appropriate type.
 */
function parseDefaultValue(
	value: string | undefined,
): string | number | boolean | Record<string, unknown> | undefined {
	if (value === undefined || value === '') return undefined;
	const lowerValue = value.toLowerCase();
	if (lowerValue === 'true') return true;
	if (lowerValue === 'false') return false;
	if (!isNaN(Number(value))) return Number(value);
	try {
		return jsonParse(value);
	} catch {
		return value;
	}
}

/**
 * Parses the arguments of a single $fromAI function call.
 * @param argsString The string containing the function arguments.
 * @returns A FromAIArgument object.
 */
function parseArguments(argsString: string): FromAIArgument {
	// Split arguments by commas not inside quotes
	const args: string[] = [];
	let currentArg = '';
	let inQuotes = false;
	let quoteChar = '';
	let escapeNext = false;

	for (let i = 0; i < argsString.length; i++) {
		const char = argsString[i];

		if (escapeNext) {
			currentArg += char;
			escapeNext = false;
			continue;
		}

		if (char === '\\') {
			escapeNext = true;
			continue;
		}

		if (['"', "'", '`'].includes(char)) {
			if (!inQuotes) {
				inQuotes = true;
				quoteChar = char;
				currentArg += char;
			} else if (char === quoteChar) {
				inQuotes = false;
				quoteChar = '';
				currentArg += char;
			} else {
				currentArg += char;
			}
			continue;
		}

		if (char === ',' && !inQuotes) {
			args.push(currentArg.trim());
			currentArg = '';
			continue;
		}

		currentArg += char;
	}

	if (currentArg) {
		args.push(currentArg.trim());
	}

	// Remove surrounding quotes if present
	const cleanArgs = args.map((arg) => {
		const trimmed = arg.trim();
		if (
			(trimmed.startsWith("'") && trimmed.endsWith("'")) ||
			(trimmed.startsWith('`') && trimmed.endsWith('`')) ||
			(trimmed.startsWith('"') && trimmed.endsWith('"'))
		) {
			return trimmed
				.slice(1, -1)
				.replace(/\\'/g, "'")
				.replace(/\\`/g, '`')
				.replace(/\\"/g, '"')
				.replace(/\\\\/g, '\\');
		}
		return trimmed;
	});

	const type = cleanArgs?.[2] || 'string';

	if (!['string', 'number', 'boolean', 'json'].includes(type.toLowerCase())) {
		throw new ParseError(`Invalid type: ${type}`);
	}

	return {
		key: cleanArgs[0] || '',
		description: cleanArgs[1],
		type: (cleanArgs?.[2] ?? 'string') as FromAIArgumentType,
		defaultValue: parseDefaultValue(cleanArgs[3]),
	};
}

/**
 * Extracts all $fromAI calls from a given string
 * @param str The string to search for $fromAI calls.
 * @returns An array of FromAIArgument objects.
 *
 * This method uses a regular expression to find the start of each $fromAI function call
 * in the input string. It then employs a character-by-character parsing approach to
 * accurately extract the arguments of each call, handling nested parentheses and quoted strings.
 *
 * The parsing process:
 * 1. Finds the starting position of a $fromAI call using regex.
 * 2. Iterates through characters, keeping track of parentheses depth and quote status.
 * 3. Handles escaped characters within quotes to avoid premature quote closing.
 * 4. Builds the argument string until the matching closing parenthesis is found.
 * 5. Parses the extracted argument string into a FromAIArgument object.
 * 6. Repeats the process for all $fromAI calls in the input string.
 *
 */
export function extractFromAICalls(str: string): FromAIArgument[] {
	const args: FromAIArgument[] = [];
	// Regular expression to match the start of a $fromAI function call
	const pattern = /\$fromAI\s*\(\s*/gi;
	let match: RegExpExecArray | null;

	while ((match = pattern.exec(str)) !== null) {
		const startIndex = match.index + match[0].length;
		let current = startIndex;
		let inQuotes = false;
		let quoteChar = '';
		let parenthesesCount = 1;
		let argsString = '';

		// Parse the arguments string, handling nested parentheses and quotes
		while (current < str.length && parenthesesCount > 0) {
			const char = str[current];

			if (inQuotes) {
				// Handle characters inside quotes, including escaped characters
				if (char === '\\' && current + 1 < str.length) {
					argsString += char + str[current + 1];
					current += 2;
					continue;
				}

				if (char === quoteChar) {
					inQuotes = false;
					quoteChar = '';
				}
				argsString += char;
			} else {
				// Handle characters outside quotes
				if (['"', "'", '`'].includes(char)) {
					inQuotes = true;
					quoteChar = char;
				} else if (char === '(') {
					parenthesesCount++;
				} else if (char === ')') {
					parenthesesCount--;
				}

				// Only add characters if we're still inside the main parentheses
				if (parenthesesCount > 0 || char !== ')') {
					argsString += char;
				}
			}

			current++;
		}

		// If parentheses are balanced, parse the arguments
		if (parenthesesCount === 0) {
			try {
				const parsedArgs = parseArguments(argsString);
				args.push(parsedArgs);
			} catch (error) {
				// If parsing fails, throw an ParseError with details
				throw new ParseError(`Failed to parse $fromAI arguments: ${argsString}: ${String(error)}`);
			}
		} else {
			// Log an error if parentheses are unbalanced
			throw new ParseError(
				`Unbalanced parentheses while parsing $fromAI call: ${str.slice(startIndex)}`,
			);
		}
	}

	return args;
}

/**
 * Recursively traverses the nodeParameters object to find all $fromAI calls.
 * @param payload The current object or value being traversed.
 * @param collectedArgs The array collecting FromAIArgument objects.
 */
export function traverseNodeParameters(payload: unknown, collectedArgs: FromAIArgument[]) {
	if (typeof payload === 'string') {
		const fromAICalls = extractFromAICalls(payload);
		fromAICalls.forEach((call) => collectedArgs.push(call));
	} else if (Array.isArray(payload)) {
		payload.forEach((item: unknown) => traverseNodeParameters(item, collectedArgs));
	} else if (typeof payload === 'object' && payload !== null) {
		Object.values(payload).forEach((value) => traverseNodeParameters(value, collectedArgs));
	}
}

export function traverseNodeParametersWithParamNames(
	payload: unknown,
	collectedArgs: Map<string, FromAIArgument>,
	name?: string,
) {
	if (typeof payload === 'string') {
		const fromAICalls = extractFromAICalls(payload);
		fromAICalls.forEach((call) => collectedArgs.set(name as string, call));
	} else if (Array.isArray(payload)) {
		payload.forEach((item: unknown, index: number) =>
			traverseNodeParametersWithParamNames(item, collectedArgs, name + `[${index}]`),
		);
	} else if (typeof payload === 'object' && payload !== null) {
		for (const [key, value] of Object.entries(payload)) {
			traverseNodeParametersWithParamNames(value, collectedArgs, name ? name + '.' + key : key);
		}
	}
}



================================================
FILE: packages/workflow/src/global-state.ts
================================================
import { deepCopy } from './utils';

export interface GlobalState {
	defaultTimezone: string;
}

let globalState: GlobalState = { defaultTimezone: 'America/New_York' };

export function setGlobalState(state: GlobalState) {
	globalState = state;
}

export function getGlobalState() {
	return deepCopy(globalState);
}



================================================
FILE: packages/workflow/src/index.ts
================================================
import * as LoggerProxy from './logger-proxy';
import * as NodeHelpers from './node-helpers';
import * as ObservableObject from './observable-object';
import * as TelemetryHelpers from './telemetry-helpers';

export * from './errors';
export * from './constants';
export * from './common';
export * from './cron';
export * from './data-store.types';
export * from './deferred-promise';
export * from './global-state';
export * from './interfaces';
export * from './message-event-bus';
export * from './execution-status';
export * from './expression';
export * from './expressions/expression-helpers';
export * from './from-ai-parse-utils';
export * from './node-helpers';
export * from './tool-helpers';
export * from './node-reference-parser-utils';
export * from './metadata-utils';
export * from './workflow';
export * from './workflow-data-proxy';
export * from './workflow-data-proxy-env-provider';
export * from './versioned-node-type';
export * from './type-validation';
export * from './result';
export { LoggerProxy, NodeHelpers, ObservableObject, TelemetryHelpers };
export {
	isObjectEmpty,
	deepCopy,
	jsonParse,
	base64DecodeUTF8,
	jsonStringify,
	replaceCircularReferences,
	sleep,
	sleepWithAbort,
	fileTypeFromMimeType,
	assert,
	removeCircularRefs,
	updateDisplayOptions,
	randomInt,
	randomString,
	isSafeObjectProperty,
	setSafeObjectProperty,
	isDomainAllowed,
} from './utils';
export {
	isINodeProperties,
	isINodePropertyOptions,
	isINodePropertyCollection,
	isINodePropertiesList,
	isINodePropertyCollectionList,
	isINodePropertyOptionsList,
	isResourceMapperValue,
	isResourceLocatorValue,
	isFilterValue,
} from './type-guards';

export {
	parseExtractableSubgraphSelection,
	buildAdjacencyList,
	type ExtractableErrorResult,
	type ExtractableSubgraphData,
	type IConnectionAdjacencyList as AdjacencyList,
} from './graph/graph-utils';
export { ExpressionExtensions } from './extensions';
export * as ExpressionParser from './extensions/expression-parser';
export { NativeMethods } from './native-methods';
export * from './node-parameters/filter-parameter';
export * from './node-parameters/parameter-type-validation';
export * from './node-parameters/path-utils';
export * from './evaluation-helpers';

export type {
	DocMetadata,
	NativeDoc,
	DocMetadataArgument,
	DocMetadataExample,
	Extension,
} from './extensions';

declare module 'http' {
	export interface IncomingMessage {
		contentType?: string;
		encoding: BufferEncoding;
		contentDisposition?: { type: string; filename?: string };
		rawBody: Buffer;
		readRawBody(): Promise<void>;
		_body: boolean;

		// This gets added by the `follow-redirects` package
		responseUrl?: string;

		// This is added to response objects for all outgoing requests
		req?: ClientRequest;
	}
}



================================================
FILE: packages/workflow/src/interfaces.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import type { CallbackManager as CallbackManagerLC } from '@langchain/core/callbacks/manager';
import type { LogScope } from '@n8n/config';
import type { AxiosProxyConfig, GenericAbortSignal } from 'axios';
import type * as express from 'express';
import type FormData from 'form-data';
import type { PathLike } from 'fs';
import type { IncomingHttpHeaders } from 'http';
import type { ReplyHeaders, RequestBodyMatcher, RequestHeaderMatcher } from 'nock';
import type { Client as SSHClient } from 'ssh2';
import type { Readable } from 'stream';
import type { SecureContextOptions } from 'tls';
import type { URLSearchParams } from 'url';

import type { CODE_EXECUTION_MODES, CODE_LANGUAGES, LOG_LEVELS } from './constants';
import type {
	IDataStoreProjectAggregateService,
	IDataStoreProjectService,
} from './data-store.types';
import type { IDeferredPromise } from './deferred-promise';
import type { ExecutionCancelledError } from './errors';
import type { ExpressionError } from './errors/expression.error';
import type { NodeApiError } from './errors/node-api.error';
import type { NodeOperationError } from './errors/node-operation.error';
import type { WorkflowActivationError } from './errors/workflow-activation.error';
import type { WorkflowOperationError } from './errors/workflow-operation.error';
import type { ExecutionStatus } from './execution-status';
import type { Result } from './result';
import type { Workflow } from './workflow';
import type { EnvProviderState } from './workflow-data-proxy-env-provider';

export interface IAdditionalCredentialOptions {
	oauth2?: IOAuth2Options;
	credentialsDecrypted?: ICredentialsDecrypted;
}

export type IAllExecuteFunctions =
	| IExecuteFunctions
	| IExecutePaginationFunctions
	| IExecuteSingleFunctions
	| ISupplyDataFunctions
	| IHookFunctions
	| ILoadOptionsFunctions
	| IPollFunctions
	| ITriggerFunctions
	| IWebhookFunctions;

export type BinaryFileType = 'text' | 'json' | 'image' | 'audio' | 'video' | 'pdf' | 'html';
export interface IBinaryData {
	[key: string]: string | number | undefined;
	data: string;
	mimeType: string;
	fileType?: BinaryFileType;
	fileName?: string;
	directory?: string;
	fileExtension?: string;
	fileSize?: string; // TODO: change this to number and store the actual value
	id?: string;
}

// All properties in this interface except for
// "includeCredentialsOnRefreshOnBody" will get
// removed once we add the OAuth2 hooks to the
// credentials file.
export interface IOAuth2Options {
	includeCredentialsOnRefreshOnBody?: boolean;
	property?: string;
	tokenType?: string;
	keepBearer?: boolean;
	tokenExpiredStatusCode?: number;
	keyToIncludeInAccessTokenHeader?: string;
}

export interface IConnection {
	// The node the connection is to
	node: string;

	// The type of the input on destination node (for example "main")
	type: NodeConnectionType;

	// The output/input-index of destination node (if node has multiple inputs/outputs of the same type)
	index: number;
}

export type ExecutionError =
	| ExpressionError
	| WorkflowActivationError
	| WorkflowOperationError
	| ExecutionCancelledError
	| NodeOperationError
	| NodeApiError;

// Get used to gives nodes access to credentials
export interface IGetCredentials {
	get(type: string, id: string | null): Promise<ICredentialsEncrypted>;
}

export abstract class ICredentials<T extends object = ICredentialDataDecryptedObject> {
	id?: string;

	name: string;

	type: string;

	data: string | undefined;

	constructor(nodeCredentials: INodeCredentialsDetails, type: string, data?: string) {
		this.id = nodeCredentials.id ?? undefined;
		this.name = nodeCredentials.name;
		this.type = type;
		this.data = data;
	}

	abstract getData(nodeType?: string): T;

	abstract getDataToSave(): ICredentialsEncrypted;

	abstract setData(data: T): void;
}

export interface IUser {
	id: string;
	email: string;
	firstName: string;
	lastName: string;
}

export type ProjectSharingData = {
	id: string;
	name: string | null;
	icon: { type: 'emoji' | 'icon'; value: string } | null;
	type: 'personal' | 'team' | 'public';
	createdAt: string;
	updatedAt: string;
};

export interface ICredentialsDecrypted<T extends object = ICredentialDataDecryptedObject> {
	id: string;
	name: string;
	type: string;
	data?: T;
	homeProject?: ProjectSharingData;
	sharedWithProjects?: ProjectSharingData[];
}

export interface ICredentialsEncrypted {
	id?: string;
	name: string;
	type: string;
	data?: string;
}

export interface ICredentialsExpressionResolveValues {
	connectionInputData: INodeExecutionData[];
	itemIndex: number;
	node: INode;
	runExecutionData: IRunExecutionData | null;
	runIndex: number;
	workflow: Workflow;
}

// Simplified options of request library
export interface IRequestOptionsSimplified {
	auth?: {
		username: string;
		password: string;
		sendImmediately?: boolean;
	};
	body: IDataObject;
	headers: IDataObject;
	qs: IDataObject;
}

export interface IRequestOptionsSimplifiedAuth {
	auth?: {
		username: string;
		password: string;
		sendImmediately?: boolean;
	};
	body?: IDataObject;
	headers?: IDataObject;
	qs?: IDataObject;
	url?: string;
	skipSslCertificateValidation?: boolean | string;
}

export interface IHttpRequestHelper {
	helpers: { httpRequest: IAllExecuteFunctions['helpers']['httpRequest'] };
}
export abstract class ICredentialsHelper {
	abstract getParentTypes(name: string): string[];

	abstract authenticate(
		credentials: ICredentialDataDecryptedObject,
		typeName: string,
		requestOptions: IHttpRequestOptions | IRequestOptionsSimplified,
		workflow: Workflow,
		node: INode,
	): Promise<IHttpRequestOptions>;

	abstract preAuthentication(
		helpers: IHttpRequestHelper,
		credentials: ICredentialDataDecryptedObject,
		typeName: string,
		node: INode,
		credentialsExpired: boolean,
	): Promise<ICredentialDataDecryptedObject | undefined>;

	abstract getCredentials(
		nodeCredentials: INodeCredentialsDetails,
		type: string,
	): Promise<ICredentials>;

	abstract getDecrypted(
		additionalData: IWorkflowExecuteAdditionalData,
		nodeCredentials: INodeCredentialsDetails,
		type: string,
		mode: WorkflowExecuteMode,
		executeData?: IExecuteData,
		raw?: boolean,
		expressionResolveValues?: ICredentialsExpressionResolveValues,
	): Promise<ICredentialDataDecryptedObject>;

	abstract updateCredentials(
		nodeCredentials: INodeCredentialsDetails,
		type: string,
		data: ICredentialDataDecryptedObject,
	): Promise<void>;

	abstract updateCredentialsOauthTokenData(
		nodeCredentials: INodeCredentialsDetails,
		type: string,
		data: ICredentialDataDecryptedObject,
	): Promise<void>;

	abstract getCredentialsProperties(type: string): INodeProperties[];
}

export interface IAuthenticateBase {
	type: string;
	properties:
		| {
				[key: string]: string;
		  }
		| IRequestOptionsSimplifiedAuth;
}

export interface IAuthenticateGeneric extends IAuthenticateBase {
	type: 'generic';
	properties: IRequestOptionsSimplifiedAuth;
}

export type IAuthenticate =
	| ((
			credentials: ICredentialDataDecryptedObject,
			requestOptions: IHttpRequestOptions,
	  ) => Promise<IHttpRequestOptions>)
	| IAuthenticateGeneric;

export interface IAuthenticateRuleBase {
	type: string;
	properties: {
		[key: string]: string | number;
	};
	errorMessage?: string;
}

export interface IAuthenticateRuleResponseCode extends IAuthenticateRuleBase {
	type: 'responseCode';
	properties: {
		value: number;
		message: string;
	};
}

export interface IAuthenticateRuleResponseSuccessBody extends IAuthenticateRuleBase {
	type: 'responseSuccessBody';
	properties: {
		message: string;
		key: string;
		value: any;
	};
}

type Override<A extends object, B extends object> = Omit<A, keyof B> & B;

export namespace DeclarativeRestApiSettings {
	// The type below might be extended
	// with new options that need to be parsed as expressions
	export type HttpRequestOptions = Override<
		IHttpRequestOptions,
		{ skipSslCertificateValidation?: string | boolean; url?: string }
	>;

	export type ResultOptions = {
		maxResults?: number | string;
		options: HttpRequestOptions;
		paginate?: boolean | string;
		preSend: PreSendAction[];
		postReceive: Array<{
			data: {
				parameterValue: string | IDataObject | undefined;
			};
			actions: PostReceiveAction[];
		}>;
		requestOperations?: IN8nRequestOperations;
	};
}

export interface ICredentialTestRequest {
	request: DeclarativeRestApiSettings.HttpRequestOptions;
	rules?: IAuthenticateRuleResponseCode[] | IAuthenticateRuleResponseSuccessBody[];
}

export interface ICredentialTestRequestData {
	nodeType?: INodeType;
	testRequest: ICredentialTestRequest;
}

type ICredentialHttpRequestNode = {
	name: string;
	docsUrl: string;
	hidden?: boolean;
} & ({ apiBaseUrl: string } | { apiBaseUrlPlaceholder: string });

export interface ICredentialType {
	name: string;
	displayName: string;
	icon?: Icon;
	iconColor?: ThemeIconColor;
	iconUrl?: Themed<string>;
	extends?: string[];
	properties: INodeProperties[];
	documentationUrl?: string;
	__overwrittenProperties?: string[];
	authenticate?: IAuthenticate;
	preAuthentication?: (
		this: IHttpRequestHelper,
		credentials: ICredentialDataDecryptedObject,
	) => Promise<IDataObject>;
	test?: ICredentialTestRequest;
	genericAuth?: boolean;
	httpRequestNode?: ICredentialHttpRequestNode;
	supportedNodes?: string[];
}

export interface ICredentialTypes {
	recognizes(credentialType: string): boolean;
	getByName(credentialType: string): ICredentialType;
	getSupportedNodes(type: string): string[];
	getParentTypes(typeName: string): string[];
}

// The way the credentials get saved in the database (data encrypted)
export interface ICredentialData {
	id?: string;
	name: string;
	data: string; // Contains the access data as encrypted JSON string
}

// The encrypted credentials which the nodes can access
export type CredentialInformation =
	| string
	| string[]
	| number
	| boolean
	| IDataObject
	| IDataObject[];

// The encrypted credentials which the nodes can access
export interface ICredentialDataDecryptedObject {
	[key: string]: CredentialInformation;
}

// First array index: The output/input-index (if node has multiple inputs/outputs of the same type)
// Second array index: The different connections (if one node is connected to multiple nodes)
// Any index can be null, for example in a switch node with multiple indexes some of which are not connected
export type NodeInputConnections = Array<IConnection[] | null>;

export interface INodeConnection {
	sourceIndex: number;
	destinationIndex: number;
}

export interface INodeConnections {
	// Input name
	[key: string]: NodeInputConnections;
}

export interface IConnections {
	// Node name
	[key: string]: INodeConnections;
}

export type GenericValue = string | object | number | boolean | undefined | null;

export type CloseFunction = () => Promise<void>;

export interface IDataObject {
	[key: string]: GenericValue | IDataObject | GenericValue[] | IDataObject[];
}

export type IExecuteResponsePromiseData = IDataObject | IN8nHttpFullResponse;

export interface INodeTypeNameVersion {
	name: string;
	version: number;
}

export interface IRunNodeResponse {
	data: INodeExecutionData[][] | null | undefined;
	hints?: NodeExecutionHint[];
	closeFunction?: CloseFunction;
}

export interface ISourceDataConnections {
	// Key for each input type and because there can be multiple inputs of the same type it is an array
	// null is also allowed because if we still need data for a later while executing the workflow set temporary to null
	// the nodes get as input TaskDataConnections which is identical to this one except that no null is allowed.
	[key: string]: Array<ISourceData[] | null>;
}

export interface IExecuteData {
	data: ITaskDataConnections;
	metadata?: ITaskMetadata;
	node: INode;
	source: ITaskDataConnectionsSource | null;
}

export type IContextObject = {
	[key: string]: any;
};

export interface IExecuteContextData {
	// Keys are: "flow" | "node:<NODE_NAME>"
	[key: string]: IContextObject;
}

export type IHttpRequestMethods = 'DELETE' | 'GET' | 'HEAD' | 'PATCH' | 'POST' | 'PUT';

/** used in helpers.httpRequest(WithAuthentication) */
export interface IHttpRequestOptions {
	url: string;
	baseURL?: string;
	headers?: IDataObject;
	method?: IHttpRequestMethods;
	body?: FormData | GenericValue | GenericValue[] | Buffer | URLSearchParams;
	qs?: IDataObject;
	arrayFormat?: 'indices' | 'brackets' | 'repeat' | 'comma';
	auth?: {
		username: string;
		password: string;
		sendImmediately?: boolean;
	};
	disableFollowRedirect?: boolean;
	encoding?: 'arraybuffer' | 'blob' | 'document' | 'json' | 'text' | 'stream';
	skipSslCertificateValidation?: boolean;
	returnFullResponse?: boolean;
	ignoreHttpStatusErrors?: boolean;
	proxy?: {
		host: string;
		port: number;
		auth?: {
			username: string;
			password: string;
		};
		protocol?: string;
	};
	timeout?: number;
	json?: boolean;
	abortSignal?: GenericAbortSignal;
}

/**
 * used in helpers.request(WithAuthentication)
 * @see IHttpRequestOptions
 * @deprecated Prefer using IHttpRequestOptions
 */
export interface IRequestOptions {
	baseURL?: string;
	uri?: string;
	url?: string;
	method?: IHttpRequestMethods;
	qs?: IDataObject;
	qsStringifyOptions?: { arrayFormat: 'repeat' | 'brackets' | 'indices' };
	useQuerystring?: boolean;
	headers?: IDataObject;
	auth?: Partial<{
		sendImmediately: boolean;
		bearer: string;
		user: string;
		username: string;
		password: string;
		pass: string;
	}>;
	body?: any;
	formData?: IDataObject | FormData;
	form?: IDataObject | FormData;
	json?: boolean;
	useStream?: boolean;
	encoding?: string | null;
	timeout?: number;
	rejectUnauthorized?: boolean;
	proxy?: string | AxiosProxyConfig;
	simple?: boolean;
	gzip?: boolean;
	resolveWithFullResponse?: boolean;

	/** Whether to follow GET or HEAD HTTP 3xx redirects @default true */
	followRedirect?: boolean;

	/** Whether to follow **All** HTTP 3xx redirects @default false */
	followAllRedirects?: boolean;

	/** Max number of redirects to follow @default 21 */
	maxRedirects?: number;

	agentOptions?: SecureContextOptions;
}

export interface PaginationOptions {
	binaryResult?: boolean;
	continue: boolean | string;
	request: IRequestOptionsSimplifiedAuth;
	requestInterval: number;
	maxRequests?: number;
}

export type IN8nHttpResponse = IDataObject | Buffer | GenericValue | GenericValue[] | null;

export interface IN8nHttpFullResponse {
	body: IN8nHttpResponse | Readable;
	__bodyResolved?: boolean;
	headers: IDataObject;
	statusCode: number;
	statusMessage?: string;
}

export interface IN8nRequestOperations {
	pagination?:
		| IN8nRequestOperationPaginationGeneric
		| IN8nRequestOperationPaginationOffset
		| ((
				this: IExecutePaginationFunctions,
				requestOptions: DeclarativeRestApiSettings.ResultOptions,
		  ) => Promise<INodeExecutionData[]>);
}

export interface IN8nRequestOperationPaginationBase {
	type: string;
	properties: {
		[key: string]: unknown;
	};
}

export interface IN8nRequestOperationPaginationGeneric extends IN8nRequestOperationPaginationBase {
	type: 'generic';
	properties: {
		continue: boolean | string;
		request: IRequestOptionsSimplifiedAuth;
	};
}

export interface IN8nRequestOperationPaginationOffset extends IN8nRequestOperationPaginationBase {
	type: 'offset';
	properties: {
		limitParameter: string;
		offsetParameter: string;
		pageSize: number;
		rootProperty?: string; // Optional Path to option array
		type: 'body' | 'query';
	};
}

export type EnsureTypeOptions = 'string' | 'number' | 'boolean' | 'object' | 'array' | 'json';
export interface IGetNodeParameterOptions {
	contextNode?: INode;
	// make sure that returned value would be of specified type, converts it if needed
	ensureType?: EnsureTypeOptions;
	// extract value from regex, works only when parameter type is resourceLocator
	extractValue?: boolean;
	// get raw value of parameter with unresolved expressions
	rawExpressions?: boolean;
	// skip validation of parameter
	skipValidation?: boolean;
}

namespace ExecuteFunctions {
	namespace StringReturning {
		export type NodeParameter =
			| 'binaryProperty'
			| 'binaryPropertyName'
			| 'binaryPropertyOutput'
			| 'dataPropertyName'
			| 'dataBinaryProperty'
			| 'resource'
			| 'operation'
			| 'filePath'
			| 'encodingType';
	}

	namespace NumberReturning {
		export type NodeParameter = 'limit';
	}

	namespace BooleanReturning {
		export type NodeParameter =
			| 'binaryData'
			| 'download'
			| 'jsonParameters'
			| 'returnAll'
			| 'rawData'
			| 'resolveData';
	}

	namespace RecordReturning {
		export type NodeParameter = 'additionalFields' | 'filters' | 'options' | 'updateFields';
	}

	export type GetNodeParameterFn = {
		// @TECH_DEBT: Refactor to remove this barely used overload - N8N-5632
		getNodeParameter<T extends { resource: string }>(
			parameterName: 'resource',
			itemIndex?: number,
		): T['resource'];

		getNodeParameter(
			parameterName: StringReturning.NodeParameter,
			itemIndex: number,
			fallbackValue?: string,
			options?: IGetNodeParameterOptions,
		): string;
		getNodeParameter(
			parameterName: RecordReturning.NodeParameter,
			itemIndex: number,
			fallbackValue?: IDataObject,
			options?: IGetNodeParameterOptions,
		): IDataObject;
		getNodeParameter(
			parameterName: BooleanReturning.NodeParameter,
			itemIndex: number,
			fallbackValue?: boolean,
			options?: IGetNodeParameterOptions,
		): boolean;
		getNodeParameter(
			parameterName: NumberReturning.NodeParameter,
			itemIndex: number,
			fallbackValue?: number,
			options?: IGetNodeParameterOptions,
		): number;
		getNodeParameter(
			parameterName: string,
			itemIndex: number,
			fallbackValue?: any,
			options?: IGetNodeParameterOptions,
		): NodeParameterValueType | object;
	};
}

export interface IExecuteWorkflowInfo {
	code?: IWorkflowBase;
	id?: string;
}

export type ICredentialTestFunction = (
	this: ICredentialTestFunctions,
	credential: ICredentialsDecrypted<ICredentialDataDecryptedObject>,
) => Promise<INodeCredentialTestResult>;

export interface ICredentialTestFunctions {
	logger: Logger;
	helpers: SSHTunnelFunctions & {
		request: (uriOrObject: string | object, options?: object) => Promise<any>;
	};
}

export interface BaseHelperFunctions {
	createDeferredPromise: <T = void>() => IDeferredPromise<T>;
	returnJsonArray(jsonData: IDataObject | IDataObject[]): INodeExecutionData[];
}

export interface FileSystemHelperFunctions {
	createReadStream(path: PathLike): Promise<Readable>;
	getStoragePath(): string;
	writeContentToFile(
		path: PathLike,
		content: string | Buffer | Readable,
		flag?: string,
	): Promise<void>;
}

export interface BinaryHelperFunctions {
	prepareBinaryData(
		binaryData: Buffer | Readable,
		filePath?: string,
		mimeType?: string,
	): Promise<IBinaryData>;
	setBinaryDataBuffer(data: IBinaryData, binaryData: Buffer): Promise<IBinaryData>;
	/** @deprecated */
	copyBinaryFile(): Promise<never>;
	binaryToBuffer(body: Buffer | Readable): Promise<Buffer>;
	binaryToString(body: Buffer | Readable, encoding?: BufferEncoding): Promise<string>;
	getBinaryPath(binaryDataId: string): string;
	getBinaryStream(binaryDataId: string, chunkSize?: number): Promise<Readable>;
	createBinarySignedUrl(binaryData: IBinaryData, expiresIn?: string): string;
	getBinaryMetadata(binaryDataId: string): Promise<{
		fileName?: string;
		mimeType?: string;
		fileSize: number;
	}>;
}

export type DeduplicationScope = 'node' | 'workflow';
export type DeduplicationItemTypes = string | number;
export type DeduplicationMode = 'entries' | 'latestIncrementalKey' | 'latestDate';

export interface IProcessedDataLatest {
	mode: DeduplicationMode;
	data: DeduplicationItemTypes;
}

export interface IProcessedDataEntries {
	mode: DeduplicationMode;
	data: DeduplicationItemTypes[];
}

export interface IDeduplicationOutput {
	new: DeduplicationItemTypes[];
	processed: DeduplicationItemTypes[];
}

export interface IDeduplicationOutputItems {
	new: IDataObject[];
	processed: IDataObject[];
}

export interface ICheckProcessedOptions {
	mode: DeduplicationMode;
	maxEntries?: number;
}

export interface DeduplicationHelperFunctions {
	checkProcessedAndRecord(
		items: DeduplicationItemTypes[],
		scope: DeduplicationScope,
		options: ICheckProcessedOptions,
	): Promise<IDeduplicationOutput>;
	checkProcessedItemsAndRecord(
		propertyName: string,
		items: IDataObject[],
		scope: DeduplicationScope,
		options: ICheckProcessedOptions,
	): Promise<IDeduplicationOutputItems>;
	removeProcessed(
		items: DeduplicationItemTypes[],
		scope: DeduplicationScope,
		options: ICheckProcessedOptions,
	): Promise<void>;
	clearAllProcessedItems(scope: DeduplicationScope, options: ICheckProcessedOptions): Promise<void>;
	getProcessedDataCount(
		scope: DeduplicationScope,
		options: ICheckProcessedOptions,
	): Promise<number>;
}
interface NodeHelperFunctions {
	copyBinaryFile(filePath: string, fileName: string, mimeType?: string): Promise<IBinaryData>;
}

export interface RequestHelperFunctions {
	httpRequest(requestOptions: IHttpRequestOptions): Promise<any>;
	httpRequestWithAuthentication(
		this: IAllExecuteFunctions,
		credentialsType: string,
		requestOptions: IHttpRequestOptions,
		additionalCredentialOptions?: IAdditionalCredentialOptions,
	): Promise<any>;
	requestWithAuthenticationPaginated(
		this: IAllExecuteFunctions,
		requestOptions: IRequestOptions,
		itemIndex: number,
		paginationOptions: PaginationOptions,
		credentialsType?: string,
		additionalCredentialOptions?: IAdditionalCredentialOptions,
	): Promise<any[]>;

	/**
	 * @deprecated Use .httpRequest instead
	 * @see RequestHelperFunctions.httpRequest
	 */
	request(uriOrObject: string | IRequestOptions, options?: IRequestOptions): Promise<any>;
	/**
	 * @deprecated Use .httpRequestWithAuthentication instead
	 * @see RequestHelperFunctions.requestWithAuthentication
	 */
	requestWithAuthentication(
		this: IAllExecuteFunctions,
		credentialsType: string,
		requestOptions: IRequestOptions,
		additionalCredentialOptions?: IAdditionalCredentialOptions,
		itemIndex?: number,
	): Promise<any>;
	/**
	 * @deprecated Use .httpRequestWithAuthentication instead
	 * @see RequestHelperFunctions.requestWithAuthentication
	 */
	requestOAuth1(
		this: IAllExecuteFunctions,
		credentialsType: string,
		requestOptions: IRequestOptions,
	): Promise<any>;
	/**
	 * @deprecated Use .httpRequestWithAuthentication instead
	 * @see RequestHelperFunctions.requestWithAuthentication
	 */
	requestOAuth2(
		this: IAllExecuteFunctions,
		credentialsType: string,
		requestOptions: IRequestOptions,
		oAuth2Options?: IOAuth2Options,
	): Promise<any>;
}

export type SSHCredentials = {
	sshHost: string;
	sshPort: number;
	sshUser: string;
} & (
	| {
			sshAuthenticateWith: 'password';
			sshPassword: string;
	  }
	| {
			sshAuthenticateWith: 'privateKey';
			// TODO: rename this to `sshPrivateKey`
			privateKey: string;
			// TODO: rename this to `sshPassphrase`
			passphrase?: string;
	  }
);

export interface SSHTunnelFunctions {
	getSSHClient(credentials: SSHCredentials, abortController?: AbortController): Promise<SSHClient>;
	updateLastUsed(client: SSHClient): void;
}

type CronUnit = number | '*' | `*/${number}`;
export type CronExpression =
	`${CronUnit} ${CronUnit} ${CronUnit} ${CronUnit} ${CronUnit} ${CronUnit}`;

type CronRecurrenceRule =
	| { activated: false }
	| {
			activated: true;
			index: number;
			intervalSize: number;
			typeInterval: 'hours' | 'days' | 'weeks' | 'months';
	  };

export type CronContext = {
	nodeId: string;
	workflowId: string;
	timezone: string;
	expression: CronExpression;
	recurrence?: CronRecurrenceRule;
};

export type Cron = { expression: CronExpression; recurrence?: CronRecurrenceRule };

export interface SchedulingFunctions {
	registerCron(cron: Cron, onTick: () => void): void;
}

export type NodeTypeAndVersion = {
	name: string;
	type: string;
	typeVersion: number;
	disabled: boolean;
	parameters?: INodeParameters;
};

export interface FunctionsBase {
	logger: Logger;
	getCredentials<T extends object = ICredentialDataDecryptedObject>(
		type: string,
		itemIndex?: number,
	): Promise<T>;
	getCredentialsProperties(type: string): INodeProperties[];
	getExecutionId(): string;
	getNode(): INode;
	getWorkflow(): IWorkflowMetadata;
	getWorkflowStaticData(type: string): IDataObject;
	getTimezone(): string;
	getRestApiUrl(): string;
	getInstanceBaseUrl(): string;
	getInstanceId(): string;
	/** Get the waiting resume url signed with the signature token */
	getSignedResumeUrl(parameters?: Record<string, string>): string;
	/** Set requirement in the execution for signature token validation */
	setSignatureValidationRequired(): void;
	getChildNodes(
		nodeName: string,
		options?: { includeNodeParameters?: boolean },
	): NodeTypeAndVersion[];
	getParentNodes(
		nodeName: string,
		options?: { includeNodeParameters?: boolean },
	): NodeTypeAndVersion[];
	getKnownNodeTypes(): IDataObject;
	getMode?: () => WorkflowExecuteMode;
	getActivationMode?: () => WorkflowActivateMode;
	getChatTrigger: () => INode | null;

	/** @deprecated */
	prepareOutputData(outputData: INodeExecutionData[]): Promise<INodeExecutionData[][]>;
}

type FunctionsBaseWithRequiredKeys<Keys extends keyof FunctionsBase> = FunctionsBase & {
	[K in Keys]: NonNullable<FunctionsBase[K]>;
};

export type ContextType = 'flow' | 'node';

export type DataStoreProxyProvider = {
	getDataStoreAggregateProxy(
		workflow: Workflow,
		node: INode,
		dataStoreProjectId?: string,
	): Promise<IDataStoreProjectAggregateService>;
	getDataStoreProxy(
		workflow: Workflow,
		node: INode,
		dataStoreId: string,
		dataStoreProjectId?: string,
	): Promise<IDataStoreProjectService>;
};

export type DataStoreProxyFunctions = {
	// These are optional to account for situations where the data-store module is disabled
	getDataStoreAggregateProxy?(): Promise<IDataStoreProjectAggregateService>;
	getDataStoreProxy?(dataStoreId: string): Promise<IDataStoreProjectService>;
};

type BaseExecutionFunctions = FunctionsBaseWithRequiredKeys<'getMode'> & {
	continueOnFail(): boolean;
	setMetadata(metadata: ITaskMetadata): void;
	evaluateExpression(expression: string, itemIndex: number): NodeParameterValueType;
	getContext(type: ContextType): IContextObject;
	getExecuteData(): IExecuteData;
	getWorkflowDataProxy(itemIndex: number): IWorkflowDataProxyData;
	getInputSourceData(inputIndex?: number, connectionType?: NodeConnectionType): ISourceData;
	getExecutionCancelSignal(): AbortSignal | undefined;
	onExecutionCancellation(handler: () => unknown): void;
	logAiEvent(eventName: AiEvent, msg?: string): void;
};

// TODO: Create later own type only for Config-Nodes
export type IExecuteFunctions = ExecuteFunctions.GetNodeParameterFn &
	BaseExecutionFunctions & {
		executeWorkflow(
			workflowInfo: IExecuteWorkflowInfo,
			inputData?: INodeExecutionData[],
			parentCallbackManager?: CallbackManager,
			options?: {
				doNotWaitToFinish?: boolean;
				parentExecution?: RelatedExecution;
			},
		): Promise<ExecuteWorkflowData>;
		getExecutionDataById(executionId: string): Promise<IRunExecutionData | undefined>;
		getInputConnectionData(
			connectionType: AINodeConnectionType,
			itemIndex: number,
			inputIndex?: number,
		): Promise<unknown>;
		getInputData(inputIndex?: number, connectionType?: NodeConnectionType): INodeExecutionData[];
		getNodeInputs(): INodeInputConfiguration[];
		getNodeOutputs(): INodeOutputConfiguration[];
		putExecutionToWait(waitTill: Date): Promise<void>;
		sendMessageToUI(message: any): void;
		sendResponse(response: IExecuteResponsePromiseData): void;
		sendChunk(type: ChunkType, itemIndex: number, content?: IDataObject | string): void;
		isStreaming(): boolean;

		// TODO: Make this one then only available in the new config one
		addInputData(
			connectionType: NodeConnectionType,
			data: INodeExecutionData[][] | ExecutionError,
			runIndex?: number,
		): { index: number };
		addOutputData(
			connectionType: NodeConnectionType,
			currentNodeRunIndex: number,
			data: INodeExecutionData[][] | ExecutionError,
			metadata?: ITaskMetadata,
			sourceNodeRunIndex?: number,
		): void;

		addExecutionHints(...hints: NodeExecutionHint[]): void;

		nodeHelpers: NodeHelperFunctions;
		helpers: RequestHelperFunctions &
			BaseHelperFunctions &
			BinaryHelperFunctions &
			DeduplicationHelperFunctions &
			FileSystemHelperFunctions &
			SSHTunnelFunctions &
			DataStoreProxyFunctions & {
				normalizeItems(items: INodeExecutionData | INodeExecutionData[]): INodeExecutionData[];
				constructExecutionMetaData(
					inputData: INodeExecutionData[],
					options: { itemData: IPairedItemData | IPairedItemData[] },
				): NodeExecutionWithMetadata[];
				assertBinaryData(itemIndex: number, propertyName: string): IBinaryData;
				getBinaryDataBuffer(itemIndex: number, propertyName: string): Promise<Buffer>;
				detectBinaryEncoding(buffer: Buffer): string;
				copyInputItems(items: INodeExecutionData[], properties: string[]): IDataObject[];
			};

		getParentCallbackManager(): CallbackManager | undefined;

		startJob<T = unknown, E = unknown>(
			jobType: string,
			settings: unknown,
			itemIndex: number,
		): Promise<Result<T, E>>;
	};

export interface IExecuteSingleFunctions extends BaseExecutionFunctions {
	getInputData(inputIndex?: number, connectionType?: NodeConnectionType): INodeExecutionData;
	getItemIndex(): number;
	getNodeParameter(
		parameterName: string,
		fallbackValue?: any,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object;

	helpers: RequestHelperFunctions &
		BaseHelperFunctions &
		BinaryHelperFunctions & {
			assertBinaryData(propertyName: string, inputIndex?: number): IBinaryData;
			getBinaryDataBuffer(propertyName: string, inputIndex?: number): Promise<Buffer>;
			detectBinaryEncoding(buffer: Buffer): string;
		};
}

export type ISupplyDataFunctions = ExecuteFunctions.GetNodeParameterFn &
	FunctionsBaseWithRequiredKeys<'getMode'> &
	Pick<
		IExecuteFunctions,
		| 'addInputData'
		| 'addOutputData'
		| 'getInputConnectionData'
		| 'getInputData'
		| 'getNodeOutputs'
		| 'executeWorkflow'
		| 'sendMessageToUI'
		| 'helpers'
	> & {
		getNextRunIndex(): number;
		continueOnFail(): boolean;
		evaluateExpression(expression: string, itemIndex: number): NodeParameterValueType;
		getWorkflowDataProxy(itemIndex: number): IWorkflowDataProxyData;
		getExecutionCancelSignal(): AbortSignal | undefined;
		onExecutionCancellation(handler: () => unknown): void;
		logAiEvent(eventName: AiEvent, msg?: string): void;
		cloneWith(replacements: {
			runIndex: number;
			inputData: INodeExecutionData[][];
		}): ISupplyDataFunctions;
	};

export interface IExecutePaginationFunctions extends IExecuteSingleFunctions {
	makeRoutingRequest(
		this: IAllExecuteFunctions,
		requestOptions: DeclarativeRestApiSettings.ResultOptions,
	): Promise<INodeExecutionData[]>;
}

export interface ILoadOptionsFunctions extends FunctionsBase {
	getNodeParameter(
		parameterName: string,
		fallbackValue?: any,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object;
	getCurrentNodeParameter(
		parameterName: string,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object | undefined;
	getCurrentNodeParameters(): INodeParameters | undefined;

	helpers: RequestHelperFunctions & SSHTunnelFunctions & DataStoreProxyFunctions;
}

export type FieldValueOption = { name: string; type: FieldType | 'any' };

export type IWorkflowNodeContext = ExecuteFunctions.GetNodeParameterFn &
	Pick<FunctionsBase, 'getNode' | 'getWorkflow'>;

export interface ILocalLoadOptionsFunctions {
	getWorkflowNodeContext(nodeType: string): Promise<IWorkflowNodeContext | null>;
}

export interface IWorkflowLoader {
	get(workflowId: string): Promise<IWorkflowBase>;
}

export interface IPollFunctions
	extends FunctionsBaseWithRequiredKeys<'getMode' | 'getActivationMode'> {
	__emit(
		data: INodeExecutionData[][],
		responsePromise?: IDeferredPromise<IExecuteResponsePromiseData>,
		donePromise?: IDeferredPromise<IRun>,
	): void;
	__emitError(error: Error, responsePromise?: IDeferredPromise<IExecuteResponsePromiseData>): void;
	getNodeParameter(
		parameterName: string,
		fallbackValue?: any,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object;
	helpers: RequestHelperFunctions &
		BaseHelperFunctions &
		BinaryHelperFunctions &
		SchedulingFunctions;
}

export interface ITriggerFunctions
	extends FunctionsBaseWithRequiredKeys<'getMode' | 'getActivationMode'> {
	emit(
		data: INodeExecutionData[][],
		responsePromise?: IDeferredPromise<IExecuteResponsePromiseData>,
		donePromise?: IDeferredPromise<IRun>,
	): void;
	emitError(error: Error, responsePromise?: IDeferredPromise<IExecuteResponsePromiseData>): void;
	getNodeParameter(
		parameterName: string,
		fallbackValue?: any,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object;
	helpers: RequestHelperFunctions &
		BaseHelperFunctions &
		BinaryHelperFunctions &
		SSHTunnelFunctions &
		SchedulingFunctions;
}

export interface IHookFunctions
	extends FunctionsBaseWithRequiredKeys<'getMode' | 'getActivationMode'> {
	getWebhookName(): string;
	getWebhookDescription(name: WebhookType): IWebhookDescription | undefined;
	getNodeWebhookUrl: (name: WebhookType) => string | undefined;
	getNodeParameter(
		parameterName: string,
		fallbackValue?: any,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object;
	helpers: RequestHelperFunctions;
}

export interface IWebhookFunctions extends FunctionsBaseWithRequiredKeys<'getMode'> {
	getBodyData(): IDataObject;
	getHeaderData(): IncomingHttpHeaders;
	getInputConnectionData(
		connectionType: AINodeConnectionType,
		itemIndex: number,
		inputIndex?: number,
	): Promise<unknown>;
	getNodeParameter(
		parameterName: string,
		fallbackValue?: any,
		options?: IGetNodeParameterOptions,
	): NodeParameterValueType | object;
	getNodeWebhookUrl: (name: WebhookType) => string | undefined;
	evaluateExpression(expression: string, itemIndex?: number): NodeParameterValueType;
	getParamsData(): object;
	getQueryData(): object;
	getRequestObject(): express.Request;
	getResponseObject(): express.Response;
	getWebhookName(): string;
	nodeHelpers: NodeHelperFunctions;
	helpers: RequestHelperFunctions & BaseHelperFunctions & BinaryHelperFunctions;
}

export interface INodeCredentialsDetails {
	id: string | null;
	name: string;
}

export interface INodeCredentials {
	[key: string]: INodeCredentialsDetails;
}

export type OnError = 'continueErrorOutput' | 'continueRegularOutput' | 'stopWorkflow';
export interface INode {
	id: string;
	name: string;
	typeVersion: number;
	type: string;
	position: [number, number];
	disabled?: boolean;
	notes?: string;
	notesInFlow?: boolean;
	retryOnFail?: boolean;
	maxTries?: number;
	waitBetweenTries?: number;
	alwaysOutputData?: boolean;
	executeOnce?: boolean;
	onError?: OnError;
	continueOnFail?: boolean;
	parameters: INodeParameters;
	credentials?: INodeCredentials;
	webhookId?: string;
	extendsCredential?: string;
	rewireOutputLogTo?: NodeConnectionType;

	// forces the node to execute a particular custom operation
	// based on resource and operation
	// instead of calling default execute function
	// used by evaluations test-runner
	forceCustomOperation?: {
		resource: string;
		operation: string;
	};
}

export interface IPinData {
	[nodeName: string]: INodeExecutionData[];
}

export interface INodes {
	[key: string]: INode;
}

export interface IObservableObject {
	[key: string]: any;
	__dataChanged: boolean;
}

export interface IBinaryKeyData {
	[key: string]: IBinaryData;
}

export interface IPairedItemData {
	item: number;
	input?: number; // If undefined "0" gets used
	sourceOverwrite?: ISourceData;
}

export interface INodeExecutionData {
	[key: string]:
		| IDataObject
		| IBinaryKeyData
		| IPairedItemData
		| IPairedItemData[]
		| NodeApiError
		| NodeOperationError
		| number
		| string
		| undefined;
	json: IDataObject;
	binary?: IBinaryKeyData;
	error?: NodeApiError | NodeOperationError;
	pairedItem?: IPairedItemData | IPairedItemData[] | number;
	metadata?: {
		subExecution: RelatedExecution;
	};
	evaluationData?: Record<string, GenericValue>;
	/**
	 * Use this key to send a message to the chat.
	 *
	 * - Workflow has to be started by a chat node.
	 * - Put execution to wait after sending.
	 *
	 * See example in
	 * packages/@n8n/nodes-langchain/nodes/trigger/ChatTrigger/Chat.node.ts
	 */
	sendMessage?: string;

	/**
	 * @deprecated This key was added by accident and should not be used as it
	 * will be removed in future. For more information see PR #12469.
	 */
	index?: number;
}

export type NodeParameterValue = string | number | boolean | undefined | null;

export type ResourceLocatorModes = 'id' | 'url' | 'list' | string;
export interface IResourceLocatorResult {
	name: string;
	value: string;
	url?: string;
}

export interface INodeParameterResourceLocator {
	__rl: true;
	mode: ResourceLocatorModes;
	value: Exclude<NodeParameterValue, boolean>;
	cachedResultName?: string;
	cachedResultUrl?: string;
	__regex?: string;
}

export type NodeParameterValueType =
	// TODO: Later also has to be possible to add multiple ones with the name name. So array has to be possible
	| NodeParameterValue
	| INodeParameters
	| INodeParameterResourceLocator
	| ResourceMapperValue
	| FilterValue
	| AssignmentCollectionValue
	| NodeParameterValue[]
	| INodeParameters[]
	| INodeParameterResourceLocator[]
	| ResourceMapperValue[];

export interface INodeParameters {
	[key: string]: NodeParameterValueType;
}

export type NodePropertyTypes =
	| 'boolean'
	| 'button'
	| 'collection'
	| 'color'
	| 'dateTime'
	| 'fixedCollection'
	| 'hidden'
	| 'json'
	| 'callout'
	| 'notice'
	| 'multiOptions'
	| 'number'
	| 'options'
	| 'string'
	| 'credentialsSelect'
	| 'resourceLocator'
	| 'curlImport'
	| 'resourceMapper'
	| 'filter'
	| 'assignmentCollection'
	| 'credentials'
	| 'workflowSelector';

export type CodeAutocompleteTypes = 'function' | 'functionItem';

export type EditorType = 'codeNodeEditor' | 'jsEditor' | 'htmlEditor' | 'sqlEditor' | 'cssEditor';
export type CodeNodeEditorLanguage = (typeof CODE_LANGUAGES)[number];
export type CodeExecutionMode = (typeof CODE_EXECUTION_MODES)[number];
export type SQLDialect =
	| 'StandardSQL'
	| 'PostgreSQL'
	| 'MySQL'
	| 'MariaSQL'
	| 'MSSQL'
	| 'SQLite'
	| 'Cassandra'
	| 'PLSQL';

export interface ILoadOptions {
	routing?: {
		operations?: IN8nRequestOperations;
		output?: INodeRequestOutput;
		request?: DeclarativeRestApiSettings.HttpRequestOptions;
	};
}

export type NodePropertyAction = {
	type: 'askAiCodeGeneration';
	handler?: string;
	target?: string;
};

export interface CalloutActionBase {
	type: string;
	label: string;
	icon?: string;
}

export interface CalloutActionOpenPreBuiltAgentsCollection extends CalloutActionBase {
	type: 'openPreBuiltAgentsCollection';
}

export interface CalloutActionOpenSampleWorkflowTemplate extends CalloutActionBase {
	type: 'openSampleWorkflowTemplate';
	templateId: string;
}

export type CalloutAction =
	| CalloutActionOpenPreBuiltAgentsCollection
	| CalloutActionOpenSampleWorkflowTemplate;

export interface INodePropertyTypeOptions {
	// Supported by: button
	buttonConfig?: {
		action?: string | NodePropertyAction;
		label?: string; // otherwise "displayName" is used
		hasInputField?: boolean;
		inputFieldMaxLength?: number; // Supported if hasInputField is true
	};
	containerClass?: string; // Supported by: notice
	alwaysOpenEditWindow?: boolean; // Supported by: json
	codeAutocomplete?: CodeAutocompleteTypes; // Supported by: string
	editor?: EditorType; // Supported by: string
	editorIsReadOnly?: boolean; // Supported by: string
	sqlDialect?: SQLDialect; // Supported by: sqlEditor
	loadOptionsDependsOn?: string[]; // Supported by: options
	loadOptionsMethod?: string; // Supported by: options
	loadOptions?: ILoadOptions; // Supported by: options
	maxValue?: number; // Supported by: number
	minValue?: number; // Supported by: number
	multipleValues?: boolean; // Supported by: <All>
	multipleValueButtonText?: string; // Supported when "multipleValues" set to true
	numberPrecision?: number; // Supported by: number
	password?: boolean; // Supported by: string
	rows?: number; // Supported by: string
	showAlpha?: boolean; // Supported by: color
	sortable?: boolean; // Supported when "multipleValues" set to true
	expirable?: boolean; // Supported by: hidden (only in the credentials)
	resourceMapper?: ResourceMapperTypeOptions;
	filter?: FilterTypeOptions;
	assignment?: AssignmentTypeOptions;
	minRequiredFields?: number; // Supported by: fixedCollection
	maxAllowedFields?: number; // Supported by: fixedCollection
	calloutAction?: CalloutAction; // Supported by: callout
	[key: string]: any;
}

export interface ResourceMapperTypeOptionsBase {
	mode: 'add' | 'update' | 'upsert' | 'map';
	valuesLabel?: string;
	fieldWords?: {
		singular: string;
		plural: string;
	};
	addAllFields?: boolean;
	noFieldsError?: string;
	multiKeyMatch?: boolean;
	supportAutoMap?: boolean;
	matchingFieldsLabels?: {
		title?: string;
		description?: string;
		hint?: string;
	};
	showTypeConversionOptions?: boolean;
	allowEmptyValues?: boolean;
}

// Enforce at least one of resourceMapperMethod or localResourceMapperMethod
export type ResourceMapperTypeOptionsLocal = {
	resourceMapperMethod: string;
	localResourceMapperMethod?: never; // Explicitly disallows this property
};

export type ResourceMapperTypeOptionsExternal = {
	localResourceMapperMethod: string;
	resourceMapperMethod?: never; // Explicitly disallows this property
};

export type ResourceMapperTypeOptions = ResourceMapperTypeOptionsBase &
	(ResourceMapperTypeOptionsLocal | ResourceMapperTypeOptionsExternal);

type NonEmptyArray<T> = [T, ...T[]];

export type FilterTypeCombinator = 'and' | 'or';

export type FilterTypeOptions = {
	version: 1 | 2 | {}; // required so nodes are pinned on a version
	caseSensitive?: boolean | string; // default = true
	leftValue?: string; // when set, user can't edit left side of condition
	allowedCombinators?: NonEmptyArray<FilterTypeCombinator>; // default = ['and', 'or']
	maxConditions?: number; // default = 10
	typeValidation?: 'strict' | 'loose' | {}; // default = strict, `| {}` is a TypeScript trick to allow custom strings (expressions), but still give autocomplete
};

export type AssignmentTypeOptions = Partial<{
	hideType?: boolean; // visible by default
	defaultType?: FieldType | 'string';
	disableType?: boolean; // visible by default
}>;

export type DisplayCondition =
	| { _cnd: { eq: NodeParameterValue } }
	| { _cnd: { not: NodeParameterValue } }
	| { _cnd: { gte: number | string } }
	| { _cnd: { lte: number | string } }
	| { _cnd: { gt: number | string } }
	| { _cnd: { lt: number | string } }
	| { _cnd: { between: { from: number | string; to: number | string } } }
	| { _cnd: { startsWith: string } }
	| { _cnd: { endsWith: string } }
	| { _cnd: { includes: string } }
	| { _cnd: { regex: string } }
	| { _cnd: { exists: true } };

export interface IDisplayOptions {
	hide?: {
		[key: string]: Array<NodeParameterValue | DisplayCondition> | undefined;
	};
	show?: {
		'@version'?: Array<number | DisplayCondition>;
		'@tool'?: boolean[];
		[key: string]: Array<NodeParameterValue | DisplayCondition> | undefined;
	};

	hideOnCloud?: boolean;
}
export interface ICredentialsDisplayOptions {
	hide?: {
		[key: string]: NodeParameterValue[] | undefined;
	};
	show?: {
		'@version'?: number[];
		[key: string]: NodeParameterValue[] | undefined;
	};

	hideOnCloud?: boolean;
}

export interface INodeProperties {
	displayName: string;
	name: string;
	type: NodePropertyTypes;
	typeOptions?: INodePropertyTypeOptions;
	default: NodeParameterValueType;
	description?: string;
	hint?: string;
	disabledOptions?: IDisplayOptions;
	displayOptions?: IDisplayOptions;
	options?: Array<INodePropertyOptions | INodeProperties | INodePropertyCollection>;
	placeholder?: string;
	isNodeSetting?: boolean;
	noDataExpression?: boolean;
	required?: boolean;
	routing?: INodePropertyRouting;
	credentialTypes?: Array<
		'extends:oAuth2Api' | 'extends:oAuth1Api' | 'has:authenticate' | 'has:genericAuth'
	>;
	extractValue?: INodePropertyValueExtractor;
	modes?: INodePropertyMode[];
	requiresDataPath?: 'single' | 'multiple';
	doNotInherit?: boolean;
	// set expected type for the value which would be used for validation and type casting
	validateType?: FieldType;
	// works only if validateType is set
	// allows to skip validation during execution or set custom validation/casting logic inside node
	// inline error messages would still be shown in UI
	ignoreValidationDuringExecution?: boolean;
	// for type: options | multiOptions – skip validation of the value (e.g. when value is not in the list and specified via expression)
	allowArbitraryValues?: boolean;
}

export interface INodePropertyModeTypeOptions {
	searchListMethod?: string; // Supported by: options
	searchFilterRequired?: boolean;
	searchable?: boolean;
	/**
	 * If true, the resource locator will not show an error if the credentials are not selected
	 */
	skipCredentialsCheckInRLC?: boolean;
	allowNewResource?: {
		label: string;
		defaultName: string;
		method: string;
	};
}

export interface INodePropertyMode {
	displayName: string;
	name: string;
	type: 'string' | 'list';
	hint?: string;
	validation?: Array<
		INodePropertyModeValidation | { (this: IExecuteSingleFunctions, value: string): void }
	>;
	placeholder?: string;
	url?: string;
	extractValue?: INodePropertyValueExtractor;
	initType?: string;
	entryTypes?: {
		[name: string]: {
			selectable?: boolean;
			hidden?: boolean;
			queryable?: boolean;
			data?: {
				request?: IHttpRequestOptions;
				output?: INodeRequestOutput;
			};
		};
	};
	search?: INodePropertyRouting;
	typeOptions?: INodePropertyModeTypeOptions;
}

export interface INodePropertyModeValidation {
	type: string;
	properties: {};
}

export interface INodePropertyRegexValidation extends INodePropertyModeValidation {
	type: 'regex';
	properties: {
		regex: string;
		errorMessage: string;
	};
}

export interface INodePropertyOptions {
	name: string;
	value: string | number | boolean;
	action?: string;
	description?: string;
	routing?: INodePropertyRouting;
	outputConnectionType?: NodeConnectionType;
	inputSchema?: any;
}

export interface INodeListSearchItems extends INodePropertyOptions {
	icon?: string;
	url?: string;
}

export interface INodeListSearchResult {
	results: INodeListSearchItems[];
	paginationToken?: unknown;
}

export interface INodePropertyCollection {
	displayName: string;
	name: string;
	values: INodeProperties[];
}

export interface INodePropertyValueExtractorBase {
	type: string;
}

export interface INodePropertyValueExtractorRegex extends INodePropertyValueExtractorBase {
	type: 'regex';
	regex: string | RegExp;
}

export interface INodePropertyValueExtractorFunction {
	(
		this: IExecuteSingleFunctions,
		value: string | NodeParameterValue,
	): Promise<string | NodeParameterValue> | string;
}
export type INodePropertyValueExtractor = INodePropertyValueExtractorRegex;

export interface IParameterDependencies {
	[key: string]: string[];
}

export type IParameterLabel = {
	size?: 'small' | 'medium';
};

export interface ITriggerResponse {
	closeFunction?: CloseFunction;
	// To manually trigger the run
	manualTriggerFunction?: () => Promise<void>;
	// Gets added automatically at manual workflow runs resolves with
	// the first emitted data
	manualTriggerResponse?: Promise<INodeExecutionData[][]>;
}

export interface ExecuteWorkflowData {
	executionId: string;
	data: Array<INodeExecutionData[] | null>;
	waitTill?: Date | null;
}

export type WebhookSetupMethodNames = 'checkExists' | 'create' | 'delete';

export namespace MultiPartFormData {
	export interface File {
		filepath: string;
		mimetype?: string;
		originalFilename?: string;
		newFilename: string;
		size?: number;
	}

	export type Request = express.Request<
		{},
		{},
		{
			data: Record<string, string | string[]>;
			files: Record<string, File | File[]>;
		}
	>;
}

export interface SupplyData {
	metadata?: IDataObject;
	response: unknown;
	closeFunction?: CloseFunction;
}

type NodeOutput = INodeExecutionData[][] | NodeExecutionWithMetadata[][] | null;

export interface INodeType {
	description: INodeTypeDescription;
	supplyData?(this: ISupplyDataFunctions, itemIndex: number): Promise<SupplyData>;
	execute?(this: IExecuteFunctions): Promise<NodeOutput>;
	/**
	 * A function called when a node receives a chat message. Allows it to react
	 * to the message before it gets executed.
	 */
	onMessage?(context: IExecuteFunctions, data: INodeExecutionData): Promise<NodeOutput>;
	poll?(this: IPollFunctions): Promise<INodeExecutionData[][] | null>;
	trigger?(this: ITriggerFunctions): Promise<ITriggerResponse | undefined>;
	webhook?(this: IWebhookFunctions): Promise<IWebhookResponseData>;
	methods?: {
		loadOptions?: {
			[key: string]: (this: ILoadOptionsFunctions) => Promise<INodePropertyOptions[]>;
		};
		listSearch?: {
			[key: string]: (
				this: ILoadOptionsFunctions,
				filter?: string,
				paginationToken?: string,
			) => Promise<INodeListSearchResult>;
		};
		credentialTest?: {
			// Contains a group of functions that test credentials.
			[functionName: string]: ICredentialTestFunction;
		};
		resourceMapping?: {
			[functionName: string]: (this: ILoadOptionsFunctions) => Promise<ResourceMapperFields>;
		};
		localResourceMapping?: {
			[functionName: string]: (this: ILocalLoadOptionsFunctions) => Promise<ResourceMapperFields>;
		};
		actionHandler?: {
			[functionName: string]: (
				this: ILoadOptionsFunctions,
				payload: IDataObject | string | undefined,
			) => Promise<NodeParameterValueType>;
		};
	};
	webhookMethods?: {
		[name in WebhookType]?: {
			[method in WebhookSetupMethodNames]: (this: IHookFunctions) => Promise<boolean>;
		};
	};
	/**
	 * Defines custom operations for nodes that do not implement an `execute` method, such as declarative nodes.
	 * This function will be invoked instead of `execute` for a specific resource and operation.
	 * Should be either `execute` or `customOperations` defined for a node, but not both.
	 *
	 * @property customOperations - Maps specific resource and operation to a custom function
	 */
	customOperations?: {
		[resource: string]: {
			[operation: string]: (this: IExecuteFunctions) => Promise<NodeOutput>;
		};
	};
}

/**
 * This class serves as the base for all nodes using the new context API
 * having this as a class enables us to identify these instances at runtime
 */
export abstract class Node {
	abstract description: INodeTypeDescription;
	execute?(context: IExecuteFunctions): Promise<INodeExecutionData[][]>;
	webhook?(context: IWebhookFunctions): Promise<IWebhookResponseData>;
	poll?(context: IPollFunctions): Promise<INodeExecutionData[][] | null>;
}

export interface IVersionedNodeType {
	nodeVersions: {
		[key: number]: INodeType;
	};
	currentVersion: number;
	description: INodeTypeBaseDescription;
	getNodeType: (version?: number) => INodeType;
}
export interface INodeCredentialTestResult {
	status: 'OK' | 'Error';
	message: string;
}

export interface INodeCredentialTestRequest {
	credentials: ICredentialsDecrypted;
}

export interface INodeCredentialDescription {
	name: string;
	required?: boolean;
	displayName?: string;
	disabledOptions?: ICredentialsDisplayOptions;
	displayOptions?: ICredentialsDisplayOptions;
	testedBy?: ICredentialTestRequest | string; // Name of a function inside `loadOptions.credentialTest`
}

export type INodeIssueTypes = 'credentials' | 'execution' | 'input' | 'parameters' | 'typeUnknown';

export interface INodeIssueObjectProperty {
	[key: string]: string[];
}

export interface INodeIssueData {
	node: string;
	type: INodeIssueTypes;
	value: null | boolean | string | string[] | INodeIssueObjectProperty;
}

export interface INodeIssues {
	execution?: boolean;
	credentials?: INodeIssueObjectProperty;
	input?: INodeIssueObjectProperty;
	parameters?: INodeIssueObjectProperty;
	typeUnknown?: boolean;
	[key: string]: undefined | boolean | INodeIssueObjectProperty;
}

export interface IWorkflowIssues {
	[key: string]: INodeIssues;
}

export type ThemeIconColor =
	| 'gray'
	| 'black'
	| 'blue'
	| 'light-blue'
	| 'dark-blue'
	| 'orange'
	| 'orange-red'
	| 'pink-red'
	| 'red'
	| 'light-green'
	| 'green'
	| 'dark-green'
	| 'azure'
	| 'purple'
	| 'crimson';
export type Themed<T> = T | { light: T; dark: T };
export type IconRef = `fa:${string}` | `node:${string}.${string}`;
export type IconFile = `file:${string}.png` | `file:${string}.svg`;
export type Icon = IconRef | Themed<IconFile>;

type NodeGroupType = 'input' | 'output' | 'organization' | 'schedule' | 'transform' | 'trigger';

export interface INodeTypeBaseDescription {
	displayName: string;
	name: string;
	icon?: Icon;
	iconColor?: ThemeIconColor;
	iconUrl?: Themed<string>;
	badgeIconUrl?: Themed<string>;
	group: NodeGroupType[];
	description: string;
	documentationUrl?: string;
	subtitle?: string;
	defaultVersion?: number;
	codex?: CodexData;
	parameterPane?: 'wide';

	/**
	 * Whether the node must be hidden in the node creator panel,
	 * due to deprecation or as a special case (e.g. Start node)
	 */
	hidden?: true;

	/**
	 * Whether the node will be wrapped for tool-use by AI Agents,
	 * optionally replacing provided parts of the description
	 */
	usableAsTool?: true | UsableAsToolDescription;
}

/**
 * NodeDescription entries that replace the base node entries when
 * the node is used as a tool
 *
 * Note that the new codex is hardcoded and may not behave as expected
 * without additional changes to the implementation.
 */
export type UsableAsToolDescription = {
	replacements?: Partial<Omit<INodeTypeBaseDescription, 'usableAsTool'>>;
};

export interface INodePropertyRouting {
	operations?: IN8nRequestOperations; // Should be changed, does not sound right
	output?: INodeRequestOutput;
	request?: DeclarativeRestApiSettings.HttpRequestOptions;
	send?: INodeRequestSend;
}

export type PostReceiveAction =
	| ((
			this: IExecuteSingleFunctions,
			items: INodeExecutionData[],
			response: IN8nHttpFullResponse,
	  ) => Promise<INodeExecutionData[]>)
	| IPostReceiveBinaryData
	| IPostReceiveFilter
	| IPostReceiveLimit
	| IPostReceiveRootProperty
	| IPostReceiveSet
	| IPostReceiveSetKeyValue
	| IPostReceiveSort;

export type PreSendAction = (
	this: IExecuteSingleFunctions,
	requestOptions: IHttpRequestOptions,
) => Promise<IHttpRequestOptions>;

export interface INodeRequestOutput {
	maxResults?: number | string;
	postReceive?: PostReceiveAction[];
}

export interface INodeRequestSend {
	preSend?: PreSendAction[];
	paginate?: boolean | string; // Where should this life?
	property?: string; // Maybe: propertyName, destinationProperty?
	propertyInDotNotation?: boolean; // Enabled by default
	type?: 'body' | 'query';
	value?: string;
}

export interface IPostReceiveBase {
	type: string;
	enabled?: boolean | string;
	properties: {
		[key: string]: string | number | boolean | IDataObject;
	};
	errorMessage?: string;
}

export interface IPostReceiveBinaryData extends IPostReceiveBase {
	type: 'binaryData';
	properties: {
		destinationProperty: string;
	};
}

export interface IPostReceiveFilter extends IPostReceiveBase {
	type: 'filter';
	properties: {
		pass: boolean | string;
	};
}

export interface IPostReceiveLimit extends IPostReceiveBase {
	type: 'limit';
	properties: {
		maxResults: number | string;
	};
}

export interface IPostReceiveRootProperty extends IPostReceiveBase {
	type: 'rootProperty';
	properties: {
		property: string;
	};
}

export interface IPostReceiveSet extends IPostReceiveBase {
	type: 'set';
	properties: {
		value: string;
	};
}

export interface IPostReceiveSetKeyValue extends IPostReceiveBase {
	type: 'setKeyValue';
	properties: {
		[key: string]: string | number;
	};
}

export interface IPostReceiveSort extends IPostReceiveBase {
	type: 'sort';
	properties: {
		key: string;
	};
}

export const NodeConnectionTypes = {
	AiAgent: 'ai_agent',
	AiChain: 'ai_chain',
	AiDocument: 'ai_document',
	AiEmbedding: 'ai_embedding',
	AiLanguageModel: 'ai_languageModel',
	AiMemory: 'ai_memory',
	AiOutputParser: 'ai_outputParser',
	AiRetriever: 'ai_retriever',
	AiReranker: 'ai_reranker',
	AiTextSplitter: 'ai_textSplitter',
	AiTool: 'ai_tool',
	AiVectorStore: 'ai_vectorStore',
	Main: 'main',
} as const;

export type NodeConnectionType = (typeof NodeConnectionTypes)[keyof typeof NodeConnectionTypes];

export type AINodeConnectionType = Exclude<NodeConnectionType, typeof NodeConnectionTypes.Main>;

export const nodeConnectionTypes: NodeConnectionType[] = Object.values(NodeConnectionTypes);

export interface INodeInputFilter {
	// TODO: Later add more filter options like categories, subcatogries,
	//       regex, allow to exclude certain nodes, ... ?
	//       Potentially change totally after alpha/beta. Is not a breaking change after all.
	nodes?: string[]; // Allowed nodes
	excludedNodes?: string[];
}

export interface INodeInputConfiguration {
	category?: string;
	displayName?: string;
	required?: boolean;
	type: NodeConnectionType;
	filter?: INodeInputFilter;
	maxConnections?: number;
}

export interface INodeOutputConfiguration {
	category?: 'error';
	displayName?: string;
	maxConnections?: number;
	required?: boolean;
	type: NodeConnectionType;
}

export type ExpressionString = `={{${string}}}`;

export type NodeDefaults = Partial<{
	/**
	 * @deprecated Use {@link INodeTypeBaseDescription.iconColor|iconColor} instead. `iconColor` supports dark mode and uses preset colors from n8n's design system.
	 */
	color: string;
	name: string;
}>;

export interface INodeTypeDescription extends INodeTypeBaseDescription {
	version: number | number[];
	defaults: NodeDefaults;
	eventTriggerDescription?: string;
	activationMessage?: string;
	inputs: Array<NodeConnectionType | INodeInputConfiguration> | ExpressionString;
	requiredInputs?: string | number[] | number; // Ony available with executionOrder => "v1"
	inputNames?: string[];
	outputs: Array<NodeConnectionType | INodeOutputConfiguration> | ExpressionString;
	outputNames?: string[];
	properties: INodeProperties[];
	credentials?: INodeCredentialDescription[];
	maxNodes?: number; // How many nodes of that type can be created in a workflow
	polling?: true | undefined;
	supportsCORS?: true | undefined;
	requestDefaults?: DeclarativeRestApiSettings.HttpRequestOptions;
	requestOperations?: IN8nRequestOperations;
	hooks?: {
		[key: string]: INodeHookDescription[] | undefined;
		activate?: INodeHookDescription[];
		deactivate?: INodeHookDescription[];
	};
	webhooks?: IWebhookDescription[];
	translation?: { [key: string]: object };
	mockManualExecution?: true;
	triggerPanel?: TriggerPanelDefinition | boolean;
	extendsCredential?: string;
	hints?: NodeHint[];
	__loadOptionsMethods?: string[]; // only for validation during build
}

export type TriggerPanelDefinition = {
	hideContent?: boolean | string;
	header?: string;
	executionsHelp?: string | { active: string; inactive: string };
	activationHint?: string | { active: string; inactive: string };
};

export type NodeHint = {
	message: string;
	type?: 'info' | 'warning' | 'danger';
	location?: 'outputPane' | 'inputPane' | 'ndv';
	displayCondition?: string;
	whenToDisplay?: 'always' | 'beforeExecution' | 'afterExecution';
};

export type NodeExecutionHint = Omit<NodeHint, 'whenToDisplay' | 'displayCondition'>;

export interface INodeHookDescription {
	method: string;
}

export interface IWebhookData {
	httpMethod: IHttpRequestMethods;
	node: string;
	path: string;
	webhookDescription: IWebhookDescription;
	workflowId: string;
	workflowExecuteAdditionalData: IWorkflowExecuteAdditionalData;
	webhookId?: string;
	isTest?: boolean;
	userId?: string;
	staticData?: Workflow['staticData'];
}

export type WebhookType = 'default' | 'setup';

export interface IWebhookDescription {
	[key: string]: IHttpRequestMethods | WebhookResponseMode | boolean | string | undefined;
	httpMethod: IHttpRequestMethods | string;
	isFullPath?: boolean;
	name: WebhookType;
	path: string;
	responseBinaryPropertyName?: string;
	responseContentType?: string;
	responsePropertyName?: string;
	responseMode?: WebhookResponseMode | string;
	responseData?: WebhookResponseData | string;
	restartWebhook?: boolean;
	nodeType?: 'webhook' | 'form' | 'mcp';
	ndvHideUrl?: string | boolean; // If true the webhook will not be displayed in the editor
	ndvHideMethod?: string | boolean; // If true the method will not be displayed in the editor
}

export interface ProxyInput {
	all: () => INodeExecutionData[];
	context: any;
	first: () => INodeExecutionData | undefined;
	item: INodeExecutionData | undefined;
	last: () => INodeExecutionData | undefined;
	params?: INodeParameters;
}

export interface IWorkflowDataProxyData {
	[key: string]: any;
	$binary: INodeExecutionData['binary'];
	$data: any;
	$env: any;
	$evaluateExpression: (expression: string, itemIndex?: number) => NodeParameterValueType;
	$item: (itemIndex: number, runIndex?: number) => IWorkflowDataProxyData;
	$items: (nodeName?: string, outputIndex?: number, runIndex?: number) => INodeExecutionData[];
	$json: INodeExecutionData['json'];
	$node: any;
	$parameter: INodeParameters;
	$position: number;
	$workflow: any;
	$: any;
	$input: ProxyInput;
	$thisItem: any;
	$thisRunIndex: number;
	$thisItemIndex: number;
	$now: any;
	$today: any;
	$getPairedItem: (
		destinationNodeName: string,
		incomingSourceData: ISourceData | null,
		pairedItem: IPairedItemData,
	) => INodeExecutionData | null;
	constructor: any;
}

export type IWorkflowDataProxyAdditionalKeys = IDataObject & {
	$execution?: {
		id: string;
		mode: 'test' | 'production';
		resumeUrl: string;
		resumeFormUrl: string;
		customData?: {
			set(key: string, value: string): void;
			setAll(obj: Record<string, string>): void;
			get(key: string): string;
			getAll(): Record<string, string>;
		};
	};
	$vars?: IDataObject;
	$secrets?: IDataObject;
	$pageCount?: number;

	/** @deprecated */
	$executionId?: string;
	/** @deprecated */
	$resumeWebhookUrl?: string;
};

export interface IWorkflowMetadata {
	id?: string;
	name?: string;
	active: boolean;
}

export interface IWebhookResponseData {
	workflowData?: INodeExecutionData[][];
	webhookResponse?: any;
	noWebhookResponse?: boolean;
}

export type WebhookResponseData = 'allEntries' | 'firstEntryJson' | 'firstEntryBinary' | 'noData';

/**
 * Defines how and when response should be sent:
 *
 * onReceived: Response is sent immidiatly after node done executing
 *
 * lastNode: Response is sent after the last node finishes executing
 *
 * responseNode: Response is sent from the Responde to Webhook node
 *
 * formPage: Special response with executionId sent to the form trigger node
 *
 * hostedChat: Special response with executionId sent to the hosted chat trigger node
 *
 * streaming: Response added to runData to httpResponse and streamingEnabled set to true
 */
export type WebhookResponseMode =
	| 'onReceived'
	| 'lastNode'
	| 'responseNode'
	| 'formPage'
	| 'hostedChat'
	| 'streaming';

export interface INodeTypes {
	getByName(nodeType: string): INodeType | IVersionedNodeType;
	getByNameAndVersion(nodeType: string, version?: number): INodeType;
	getKnownTypes(): IDataObject;
}

export type LoadingDetails = {
	className: string;
	sourcePath: string;
};

export type CredentialLoadingDetails = LoadingDetails & {
	supportedNodes?: string[];
	extends?: string[];
};

export type NodeLoadingDetails = LoadingDetails;

export type KnownNodesAndCredentials = {
	nodes: Record<string, NodeLoadingDetails>;
	credentials: Record<string, CredentialLoadingDetails>;
};

export interface LoadedNodesAndCredentials {
	nodes: INodeTypeData;
	credentials: ICredentialTypeData;
}

export interface LoadedClass<T> {
	sourcePath: string;
	type: T;
}

type LoadedData<T> = Record<string, LoadedClass<T>>;
export type ICredentialTypeData = LoadedData<ICredentialType>;
export type INodeTypeData = LoadedData<INodeType | IVersionedNodeType>;

export interface IRun {
	data: IRunExecutionData;
	/**
	 * @deprecated Use status instead
	 */
	finished?: boolean;
	mode: WorkflowExecuteMode;
	waitTill?: Date | null;
	startedAt: Date;
	stoppedAt?: Date;
	status: ExecutionStatus;

	/** ID of the job this execution belongs to. Only in scaling mode. */
	jobId?: string;
}

// Contains all the data which is needed to execute a workflow and so also to
// start restart it again after it did fail.
// The RunData, ExecuteData and WaitForExecution contain often the same data.
export interface IRunExecutionData {
	startData?: {
		startNodes?: StartNodeData[];
		destinationNode?: string;
		originalDestinationNode?: string;
		runNodeFilter?: string[];
	};
	resultData: {
		error?: ExecutionError;
		runData: IRunData;
		pinData?: IPinData;
		lastNodeExecuted?: string;
		metadata?: Record<string, string>;
	};
	executionData?: {
		contextData: IExecuteContextData;
		nodeExecutionStack: IExecuteData[];
		metadata: {
			// node-name: metadata by runIndex
			[key: string]: ITaskMetadata[];
		};
		waitingExecution: IWaitingForExecution;
		waitingExecutionSource: IWaitingForExecutionSource | null;
	};
	parentExecution?: RelatedExecution;
	/**
	 * This is used to prevent breaking change
	 * for waiting executions started before signature validation was added
	 */
	validateSignature?: boolean;
	waitTill?: Date;
	pushRef?: string;

	/** Data needed for a worker to run a manual execution. */
	manualData?: Pick<
		IWorkflowExecutionDataProcess,
		'partialExecutionVersion' | 'dirtyNodeNames' | 'triggerToStartFrom' | 'userId'
	>;
}
export type SchemaType =
	| 'string'
	| 'number'
	| 'boolean'
	| 'bigint'
	| 'symbol'
	| 'array'
	| 'object'
	| 'function'
	| 'null'
	| 'undefined';

export type Schema = { type: SchemaType; key?: string; value: string | Schema[]; path: string };

export interface NodeExecutionSchema {
	nodeName: string;
	schema: Schema;
}

export interface IRunData {
	// node-name: result-data
	[key: string]: ITaskData[];
}

export interface ITaskSubRunMetadata {
	node: string;
	runIndex: number;
}

export interface RelatedExecution {
	executionId: string;
	workflowId: string;
}

export interface ITaskMetadata {
	subRun?: ITaskSubRunMetadata[];
	parentExecution?: RelatedExecution;
	subExecution?: RelatedExecution;
	subExecutionsCount?: number;
}

/** The data that gets returned when a node execution starts */
export interface ITaskStartedData {
	startTime: number;
	/** This index tracks the order in which nodes are executed */
	executionIndex: number;
	source: Array<ISourceData | null>; // Is an array as nodes have multiple inputs
	hints?: NodeExecutionHint[];
}

/** The data that gets returned when a node execution ends */
export interface ITaskData extends ITaskStartedData {
	executionTime: number;
	executionStatus?: ExecutionStatus;
	data?: ITaskDataConnections;
	inputOverride?: ITaskDataConnections;
	error?: ExecutionError;
	metadata?: ITaskMetadata;
}

export interface ISourceData {
	previousNode: string;
	previousNodeOutput?: number; // If undefined "0" gets used
	previousNodeRun?: number; // If undefined "0" gets used
}

export interface StartNodeData {
	name: string;
	sourceData: ISourceData | null;
}

// The data for all the different kind of connections (like main) and all the indexes
export interface ITaskDataConnections {
	// Key for each input type and because there can be multiple inputs of the same type it is an array
	// null is also allowed because if we still need data for a later while executing the workflow set temporary to null
	// the nodes get as input TaskDataConnections which is identical to this one except that no null is allowed.
	[key: string]: Array<INodeExecutionData[] | null>;
}

// Keeps data while workflow gets executed and allows when provided to restart execution
export interface IWaitingForExecution {
	// Node name
	[key: string]: {
		// Run index
		[key: number]: ITaskDataConnections;
	};
}

export interface ITaskDataConnectionsSource {
	// Key for each input type and because there can be multiple inputs of the same type it is an array
	// null is also allowed because if we still need data for a later while executing the workflow set temporary to null
	// the nodes get as input TaskDataConnections which is identical to this one except that no null is allowed.
	[key: string]: Array<ISourceData | null>;
}

export interface IWaitingForExecutionSource {
	// Node name
	[key: string]: {
		// Run index
		[key: number]: ITaskDataConnectionsSource;
	};
}

export type WorkflowId = IWorkflowBase['id'];

export interface IWorkflowBase {
	id: string;
	name: string;
	active: boolean;
	isArchived: boolean;
	createdAt: Date;
	startedAt?: Date;
	updatedAt: Date;
	nodes: INode[];
	connections: IConnections;
	settings?: IWorkflowSettings;
	staticData?: IDataObject;
	pinData?: IPinData;
	versionId?: string;
}

export interface IWorkflowCredentials {
	[credentialType: string]: {
		[id: string]: ICredentialsEncrypted;
	};
}

export interface IWorkflowExecutionDataProcess {
	destinationNode?: string;
	restartExecutionId?: string;
	executionMode: WorkflowExecuteMode;
	/**
	 * The data that is sent in the body of the webhook that started this
	 * execution.
	 */
	executionData?: IRunExecutionData;
	runData?: IRunData;
	pinData?: IPinData;
	retryOf?: string | null;
	pushRef?: string;
	startNodes?: StartNodeData[];
	workflowData: IWorkflowBase;
	userId?: string;
	projectId?: string;
	/**
	 * Defines which version of the partial execution flow is used.
	 * Possible values are:
	 *  1 - use the old flow
	 *  2 - use the new flow
	 */
	partialExecutionVersion?: 1 | 2;
	dirtyNodeNames?: string[];
	triggerToStartFrom?: {
		name: string;
		data?: ITaskData;
	};
	agentRequest?: AiAgentRequest;
	httpResponse?: express.Response; // Used for streaming responses
	streamingEnabled?: boolean;
	startedAt?: Date;
}

export interface ExecuteWorkflowOptions {
	node?: INode;
	parentWorkflowId: string;
	inputData?: INodeExecutionData[];
	loadedWorkflowData?: IWorkflowBase;
	loadedRunData?: IWorkflowExecutionDataProcess;
	parentWorkflowSettings?: IWorkflowSettings;
	parentCallbackManager?: CallbackManager;
	doNotWaitToFinish?: boolean;
	parentExecution?: RelatedExecution;
}

export type AiEvent =
	| 'ai-messages-retrieved-from-memory'
	| 'ai-message-added-to-memory'
	| 'ai-output-parsed'
	| 'ai-documents-retrieved'
	| 'ai-document-reranked'
	| 'ai-document-embedded'
	| 'ai-query-embedded'
	| 'ai-document-processed'
	| 'ai-text-split'
	| 'ai-tool-called'
	| 'ai-vector-store-searched'
	| 'ai-llm-generated-output'
	| 'ai-llm-errored'
	| 'ai-vector-store-populated'
	| 'ai-vector-store-updated';

type AiEventPayload = {
	msg: string;
	workflowName: string;
	executionId: string;
	nodeName: string;
	workflowId?: string;
	nodeType?: string;
};

// Used to transport an agent request for partial execution
export interface AiAgentRequest {
	query: string | INodeParameters;
	tool: {
		name: string;
	};
}

export interface IWorkflowExecuteAdditionalData {
	credentialsHelper: ICredentialsHelper;
	executeWorkflow: (
		workflowInfo: IExecuteWorkflowInfo,
		additionalData: IWorkflowExecuteAdditionalData,
		options: ExecuteWorkflowOptions,
	) => Promise<ExecuteWorkflowData>;
	getRunExecutionData: (executionId: string) => Promise<IRunExecutionData | undefined>;
	executionId?: string;
	restartExecutionId?: string;
	currentNodeExecutionIndex: number;
	httpResponse?: express.Response;
	httpRequest?: express.Request;
	streamingEnabled?: boolean;
	restApiUrl: string;
	instanceBaseUrl: string;
	setExecutionStatus?: (status: ExecutionStatus) => void;
	sendDataToUI?: (type: string, data: IDataObject | IDataObject[]) => void;
	formWaitingBaseUrl: string;
	webhookBaseUrl: string;
	webhookWaitingBaseUrl: string;
	webhookTestBaseUrl: string;
	currentNodeParameters?: INodeParameters;
	executionTimeoutTimestamp?: number;
	userId?: string;
	variables: IDataObject;
	logAiEvent: (eventName: AiEvent, payload: AiEventPayload) => void;
	parentCallbackManager?: CallbackManager;
	startRunnerTask<T, E = unknown>(
		additionalData: IWorkflowExecuteAdditionalData,
		jobType: string,
		settings: unknown,
		executeFunctions: IExecuteFunctions,
		inputData: ITaskDataConnections,
		node: INode,
		workflow: Workflow,
		runExecutionData: IRunExecutionData,
		runIndex: number,
		itemIndex: number,
		activeNodeName: string,
		connectionInputData: INodeExecutionData[],
		siblingParameters: INodeParameters,
		mode: WorkflowExecuteMode,
		envProviderState: EnvProviderState,
		executeData?: IExecuteData,
	): Promise<Result<T, E>>;
}

export type WorkflowExecuteMode =
	| 'cli'
	| 'error'
	| 'integrated'
	| 'internal'
	| 'manual'
	| 'retry'
	| 'trigger'
	| 'webhook'
	| 'evaluation';

export type WorkflowActivateMode =
	| 'init'
	| 'create' // unused
	| 'update'
	| 'activate'
	| 'manual' // unused
	| 'leadershipChange';

export namespace WorkflowSettings {
	export type CallerPolicy = 'any' | 'none' | 'workflowsFromAList' | 'workflowsFromSameOwner';
	export type SaveDataExecution = 'DEFAULT' | 'all' | 'none';
}

export interface IWorkflowSettings {
	timezone?: 'DEFAULT' | string;
	errorWorkflow?: string;
	callerIds?: string;
	callerPolicy?: WorkflowSettings.CallerPolicy;
	saveDataErrorExecution?: WorkflowSettings.SaveDataExecution;
	saveDataSuccessExecution?: WorkflowSettings.SaveDataExecution;
	saveManualExecutions?: 'DEFAULT' | boolean;
	saveExecutionProgress?: 'DEFAULT' | boolean;
	executionTimeout?: number;
	executionOrder?: 'v0' | 'v1';
	timeSavedPerExecution?: number;
}

export interface WorkflowFEMeta {
	onboardingId?: string;
}

export interface WorkflowTestData {
	description: string;
	input: {
		workflowData: {
			nodes: INode[];
			connections: IConnections;
			settings?: IWorkflowSettings;
		};
	};
	output: {
		assertBinaryData?: boolean;
		nodeExecutionOrder?: string[];
		nodeExecutionStack?: IExecuteData[];
		testAllOutputs?: boolean;
		nodeData: {
			[key: string]: any[][];
		};
		error?: string;
	};
	nock?: {
		baseUrl: string;
		mocks: Array<{
			method: 'delete' | 'get' | 'patch' | 'post' | 'put';
			path: string;
			requestBody?: RequestBodyMatcher;
			requestHeaders?: Record<string, RequestHeaderMatcher>;
			statusCode: number;
			responseBody: string | object;
			responseHeaders?: ReplyHeaders;
		}>;
	};
	trigger?: {
		mode: WorkflowExecuteMode;
		input: INodeExecutionData;
	};
	credentials?: Record<string, ICredentialDataDecryptedObject>;
}

export type LogLevel = (typeof LOG_LEVELS)[number];
export type LogMetadata = {
	[key: string]: unknown;
	scopes?: LogScope[];
	file?: string;
	function?: string;
};
export type Logger = Record<
	Exclude<LogLevel, 'silent'>,
	(message: string, metadata?: LogMetadata) => void
>;
export type LogLocationMetadata = Pick<LogMetadata, 'file' | 'function'>;

export interface IStatusCodeMessages {
	[key: string]: string;
}

export type DocumentationLink = {
	url: string;
};

export type CodexData = {
	categories?: string[];
	subcategories?: { [category: string]: string[] };
	resources?: {
		credentialDocumentation?: DocumentationLink[];
		primaryDocumentation?: DocumentationLink[];
	};
	alias?: string[];
};

export type JsonValue = string | number | boolean | null | JsonObject | JsonValue[];

export type JsonObject = { [key: string]: JsonValue };

export type AllEntities<M> = M extends { [key: string]: string } ? Entity<M, keyof M> : never;

export type Entity<M, K> = K extends keyof M ? { resource: K; operation: M[K] } : never;

export type PropertiesOf<M extends { resource: string; operation: string }> = Array<
	Omit<INodeProperties, 'displayOptions'> & {
		displayOptions?: {
			[key in 'show' | 'hide']?: {
				resource?: Array<M['resource']>;
				operation?: Array<M['operation']>;
				[otherKey: string]: Array<NodeParameterValue | DisplayCondition> | undefined;
			};
		};
	}
>;

// Telemetry

export interface ITelemetryTrackProperties {
	user_id?: string;
	[key: string]: GenericValue;
}

export interface INodesGraph {
	node_types: string[];
	node_connections: IDataObject[];
	nodes: INodesGraphNode;
	notes: INotesGraphNode;
	is_pinned: boolean;
}

export interface INodesGraphNode {
	[key: string]: INodeGraphItem;
}

export interface INotesGraphNode {
	[key: string]: INoteGraphItem;
}

export interface INoteGraphItem {
	overlapping: boolean;
	position: [number, number];
	height: number;
	width: number;
}

export interface INodeGraphItem {
	id: string;
	type: string;
	version?: number;
	resource?: string;
	operation?: string;
	domain?: string; // HTTP Request node v1
	domain_base?: string; // HTTP Request node v2
	domain_path?: string; // HTTP Request node v2
	position: [number, number];
	mode?: string;
	credential_type?: string; // HTTP Request node v2
	credential_set?: boolean; // HTTP Request node v2
	method?: string; // HTTP Request node v2
	src_node_id?: string;
	src_instance_id?: string;
	agent?: string; //@n8n/n8n-nodes-langchain.agent
	is_streaming?: boolean; //@n8n/n8n-nodes-langchain.agent
	prompts?: IDataObject[] | IDataObject; //ai node's prompts, cloud only
	toolSettings?: IDataObject; //various langchain tool's settings
	sql?: string; //merge node combineBySql, cloud only
	workflow_id?: string; //@n8n/n8n-nodes-langchain.toolWorkflow and n8n-nodes-base.executeWorkflow
	response_mode?: string; // @n8n/n8n-nodes-langchain.chatTrigger, n8n-nodes-base.webhook selected response mode
	public_chat?: boolean; // @n8n/n8n-nodes-langchain.chatTrigger
	runs?: number;
	items_total?: number;
	metric_names?: string[];
	language?: string; // only for Code node: 'javascript' or 'python'
}

export interface INodeNameIndex {
	[name: string]: string;
}

export interface INodesGraphResult {
	nodeGraph: INodesGraph;
	nameIndices: INodeNameIndex;
	webhookNodeNames: string[];
	evaluationTriggerNodeNames: string[];
}

export interface FeatureFlags {
	[featureFlag: string]: string | boolean | undefined;
}

export interface IConnectedNode {
	name: string;
	indicies: number[];
	depth: number;
}

export type PublicInstalledPackage = {
	packageName: string;
	installedVersion: string;
	authorName?: string;
	authorEmail?: string;
	installedNodes: PublicInstalledNode[];
	createdAt: Date;
	updatedAt: Date;
	updateAvailable?: string;
	failedLoading?: boolean;
};

export type PublicInstalledNode = {
	name: string;
	type: string;
	latestVersion: number;
	package: PublicInstalledPackage;
};

export interface NodeExecutionWithMetadata extends INodeExecutionData {
	pairedItem: IPairedItemData | IPairedItemData[];
}

export type AnnotationVote = 'up' | 'down';

export interface ExecutionSummary {
	id: string;
	/**
	 * @deprecated Use status instead
	 */
	finished?: boolean;
	mode: WorkflowExecuteMode;
	retryOf?: string | null;
	retrySuccessId?: string | null;
	waitTill?: Date;
	createdAt: Date;
	startedAt: Date | null;
	stoppedAt?: Date;
	workflowId: string;
	workflowName?: string;
	status: ExecutionStatus;
	lastNodeExecuted?: string;
	executionError?: ExecutionError;
	nodeExecutionStatus?: {
		[key: string]: IExecutionSummaryNodeExecutionResult;
	};
	annotation?: {
		vote: AnnotationVote;
		tags: Array<{
			id: string;
			name: string;
		}>;
	};
}

export interface IExecutionSummaryNodeExecutionResult {
	executionStatus: ExecutionStatus;
	errors?: Array<{
		name?: string;
		message?: string;
		description?: string;
	}>;
}

export interface ResourceMapperFields {
	fields: ResourceMapperField[];
	emptyFieldsNotice?: string;
}

export interface WorkflowInputsData {
	fields: ResourceMapperField[];
	dataMode: string;
	subworkflowInfo?: { workflowId?: string; triggerId?: string };
}

export interface ResourceMapperField {
	id: string;
	displayName: string;
	defaultMatch: boolean;
	canBeUsedToMatch?: boolean;
	required: boolean;
	display: boolean;
	type?: FieldType;
	removed?: boolean;
	options?: INodePropertyOptions[];
	readOnly?: boolean;
}

export type FormFieldsParameter = Array<{
	fieldLabel: string;
	elementName?: string;
	fieldType?: string;
	requiredField?: boolean;
	fieldOptions?: { values: Array<{ option: string }> };
	multiselect?: boolean;
	multipleFiles?: boolean;
	acceptFileTypes?: string;
	formatDate?: string;
	html?: string;
	placeholder?: string;
	fieldName?: string;
	fieldValue?: string;
	limitSelection?: 'exact' | 'range' | 'unlimited';
	numberOfSelections?: number;
	minSelections?: number;
	maxSelections?: number;
}>;

export type FieldTypeMap = {
	// eslint-disable-next-line id-denylist
	boolean: boolean;
	// eslint-disable-next-line id-denylist
	number: number;
	// eslint-disable-next-line id-denylist
	string: string;
	'string-alphanumeric': string;
	dateTime: string;
	time: string;
	array: unknown[];
	object: object;
	options: any;
	url: string;
	jwt: string;
	'form-fields': FormFieldsParameter;
};

export type FieldType = keyof FieldTypeMap;

export type ValidationResult<T extends FieldType = FieldType> =
	| { valid: false; errorMessage: string }
	| {
			valid: true;
			newValue?: FieldTypeMap[T];
	  };

export type ResourceMapperValue = {
	mappingMode: string;
	value: { [key: string]: string | number | boolean | null } | null;
	matchingColumns: string[];
	schema: ResourceMapperField[];
	attemptToConvertTypes: boolean;
	convertFieldsToString: boolean;
};

export type FilterOperatorType =
	| 'string'
	| 'number'
	| 'boolean'
	| 'array'
	| 'object'
	| 'dateTime'
	| 'any';

export interface FilterOperatorValue {
	type: FilterOperatorType;
	operation: string;
	rightType?: FilterOperatorType;
	singleValue?: boolean; // default = false
}

export type FilterConditionValue = {
	id: string;
	leftValue: NodeParameterValue | NodeParameterValue[];
	operator: FilterOperatorValue;
	rightValue: NodeParameterValue | NodeParameterValue[];
};

export type FilterOptionsValue = {
	caseSensitive: boolean;
	leftValue: string;
	typeValidation: 'strict' | 'loose';
	version: 1 | 2;
};

export type FilterValue = {
	options: FilterOptionsValue;
	conditions: FilterConditionValue[];
	combinator: FilterTypeCombinator;
};

export type AssignmentCollectionValue = {
	assignments: AssignmentValue[];
};

export type AssignmentValue = {
	id: string;
	name: string;
	value: NodeParameterValue;
	type?: string;
};

export interface ExecutionOptions {
	limit?: number;
}

export interface ExecutionFilters {
	/**
	 * @deprecated Use status instead
	 */
	finished?: boolean;
	mode?: WorkflowExecuteMode[];
	retryOf?: string;
	retrySuccessId?: string;
	status?: ExecutionStatus[];
	waitTill?: boolean;
	workflowId?: number | string;
}

export type NpsSurveyRespondedState = { lastShownAt: number; responded: true };
export type NpsSurveyWaitingState = {
	lastShownAt: number;
	waitingForResponse: true;
	ignoredCount: number;
};
export type NpsSurveyState = NpsSurveyRespondedState | NpsSurveyWaitingState;

export interface IUserSettings {
	isOnboarded?: boolean;
	firstSuccessfulWorkflowId?: string;
	userActivated?: boolean;
	userActivatedAt?: number;
	allowSSOManualLogin?: boolean;
	npsSurvey?: NpsSurveyState;
	easyAIWorkflowOnboarded?: boolean;
	userClaimedAiCredits?: boolean;
	dismissedCallouts?: Record<string, boolean>;
}

export interface IProcessedDataConfig {
	availableModes: string;
	mode: string;
}

export interface IDataDeduplicator {
	checkProcessedAndRecord(
		items: DeduplicationItemTypes[],
		context: DeduplicationScope,
		contextData: ICheckProcessedContextData,
		options: ICheckProcessedOptions,
	): Promise<IDeduplicationOutput>;

	removeProcessed(
		items: DeduplicationItemTypes[],
		context: DeduplicationScope,
		contextData: ICheckProcessedContextData,
		options: ICheckProcessedOptions,
	): Promise<void>;

	clearAllProcessedItems(
		context: DeduplicationScope,
		contextData: ICheckProcessedContextData,
		options: ICheckProcessedOptions,
	): Promise<void>;
	getProcessedDataCount(
		context: DeduplicationScope,
		contextData: ICheckProcessedContextData,
		options: ICheckProcessedOptions,
	): Promise<number>;
}

export interface ICheckProcessedContextData {
	node?: INode;
	workflow: {
		id: string;
		active: boolean;
	};
}

export type N8nAIProviderType = 'openai' | 'unknown';

export type Functionality = 'regular' | 'configuration-node' | 'pairedItem';

export type CallbackManager = CallbackManagerLC;

export type IPersonalizationSurveyAnswersV4 = {
	version: 'v4';
	personalization_survey_submitted_at: string;
	personalization_survey_n8n_version: string;
	automationGoalDevops?: string[] | null;
	automationGoalDevopsOther?: string | null;
	companyIndustryExtended?: string[] | null;
	otherCompanyIndustryExtended?: string[] | null;
	companySize?: string | null;
	companyType?: string | null;
	automationGoalSm?: string[] | null;
	automationGoalSmOther?: string | null;
	usageModes?: string[] | null;
	email?: string | null;
	role?: string | null;
	roleOther?: string | null;
	reportedSource?: string | null;
	reportedSourceOther?: string | null;
};

export type ChunkType = 'begin' | 'item' | 'end' | 'error';
export interface StructuredChunk {
	type: ChunkType;
	content?: string;
	metadata: {
		nodeId: string;
		nodeName: string;
		runIndex: number;
		itemIndex: number;
		timestamp: number;
	};
}



================================================
FILE: packages/workflow/src/logger-proxy.ts
================================================
import type { Logger } from './interfaces';

const noOp = () => {};
export let error: Logger['error'] = noOp;
export let warn: Logger['warn'] = noOp;
export let info: Logger['info'] = noOp;
export let debug: Logger['debug'] = noOp;

export const init = (logger: Logger) => {
	error = (message, meta) => logger.error(message, meta);
	warn = (message, meta) => logger.warn(message, meta);
	info = (message, meta) => logger.info(message, meta);
	debug = (message, meta) => logger.debug(message, meta);
};



================================================
FILE: packages/workflow/src/message-event-bus.ts
================================================
import type { DateTime } from 'luxon';

import type { INodeCredentials } from './interfaces';

// ===============================
// General Enums And Interfaces
// ===============================

export const enum EventMessageTypeNames {
	generic = '$$EventMessage',
	audit = '$$EventMessageAudit',
	confirm = '$$EventMessageConfirm',
	workflow = '$$EventMessageWorkflow',
	node = '$$EventMessageNode',
	execution = '$$EventMessageExecution',
	aiNode = '$$EventMessageAiNode',
	runner = '$$EventMessageRunner',
	queue = '$$EventMessageQueue',
}

export const enum MessageEventBusDestinationTypeNames {
	abstract = '$$AbstractMessageEventBusDestination',
	webhook = '$$MessageEventBusDestinationWebhook',
	sentry = '$$MessageEventBusDestinationSentry',
	syslog = '$$MessageEventBusDestinationSyslog',
}

export const messageEventBusDestinationTypeNames = [
	MessageEventBusDestinationTypeNames.abstract,
	MessageEventBusDestinationTypeNames.webhook,
	MessageEventBusDestinationTypeNames.sentry,
	MessageEventBusDestinationTypeNames.syslog,
];

// ===============================
// Event Message Interfaces
// ===============================

export interface IAbstractEventMessage {
	__type: EventMessageTypeNames;

	id: string;

	ts: DateTime;

	eventName: string;

	message: string;

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	payload: any;
}

// ===============================
// Event Destination Interfaces
// ===============================

export interface MessageEventBusDestinationOptions {
	__type?: MessageEventBusDestinationTypeNames;
	id?: string;
	label?: string;
	enabled?: boolean;
	subscribedEvents?: string[];
	credentials?: INodeCredentials;
	anonymizeAuditMessages?: boolean;
}

export interface MessageEventBusDestinationWebhookParameterItem {
	parameters: Array<{
		name: string;
		value: string | number | boolean | null | undefined;
	}>;
}

export interface MessageEventBusDestinationWebhookParameterOptions {
	batch?: {
		batchSize?: number;
		batchInterval?: number;
	};
	allowUnauthorizedCerts?: boolean;
	queryParameterArrays?: 'indices' | 'brackets' | 'repeat';
	redirect?: {
		followRedirects?: boolean;
		maxRedirects?: number;
	};
	response?: {
		response?: {
			fullResponse?: boolean;
			neverError?: boolean;
			responseFormat?: string;
			outputPropertyName?: string;
		};
	};
	proxy?: {
		protocol: 'https' | 'http';
		host: string;
		port: number;
	};
	timeout?: number;
}

export interface MessageEventBusDestinationWebhookOptions
	extends MessageEventBusDestinationOptions {
	url: string;
	responseCodeMustMatch?: boolean;
	expectedStatusCode?: number;
	method?: string;
	authentication?: 'predefinedCredentialType' | 'genericCredentialType' | 'none';
	sendQuery?: boolean;
	sendHeaders?: boolean;
	genericAuthType?: string;
	nodeCredentialType?: string;
	specifyHeaders?: string;
	specifyQuery?: string;
	jsonQuery?: string;
	jsonHeaders?: string;
	headerParameters?: MessageEventBusDestinationWebhookParameterItem;
	queryParameters?: MessageEventBusDestinationWebhookParameterItem;
	sendPayload?: boolean;
	options?: MessageEventBusDestinationWebhookParameterOptions;
}

export interface MessageEventBusDestinationSyslogOptions extends MessageEventBusDestinationOptions {
	expectedStatusCode?: number;
	host: string;
	port?: number;
	protocol?: 'udp' | 'tcp';
	facility?: number;
	app_name?: string;
	eol?: string;
}

export interface MessageEventBusDestinationSentryOptions extends MessageEventBusDestinationOptions {
	dsn: string;
	tracesSampleRate?: number;
	sendPayload?: boolean;
}

// ==================================
// Event Destination Default Settings
// ==================================

export const defaultMessageEventBusDestinationOptions: MessageEventBusDestinationOptions = {
	__type: MessageEventBusDestinationTypeNames.abstract,
	id: '',
	label: 'New Event Destination',
	enabled: true,
	subscribedEvents: ['n8n.audit', 'n8n.workflow'],
	credentials: {},
	anonymizeAuditMessages: false,
};

export const defaultMessageEventBusDestinationSyslogOptions: MessageEventBusDestinationSyslogOptions =
	{
		...defaultMessageEventBusDestinationOptions,
		__type: MessageEventBusDestinationTypeNames.syslog,
		label: 'Syslog Server',
		expectedStatusCode: 200,
		host: '127.0.0.1',
		port: 514,
		protocol: 'tcp',
		facility: 16,
		app_name: 'n8n',
		eol: '\n',
	};

export const defaultMessageEventBusDestinationWebhookOptions: MessageEventBusDestinationWebhookOptions =
	{
		...defaultMessageEventBusDestinationOptions,
		__type: MessageEventBusDestinationTypeNames.webhook,
		credentials: {},
		label: 'Webhook Endpoint',
		expectedStatusCode: 200,
		responseCodeMustMatch: false,
		url: 'https://',
		method: 'POST',
		authentication: 'none',
		sendQuery: false,
		sendHeaders: false,
		genericAuthType: '',
		nodeCredentialType: '',
		specifyHeaders: '',
		specifyQuery: '',
		jsonQuery: '',
		jsonHeaders: '',
		headerParameters: { parameters: [] },
		queryParameters: { parameters: [] },
		sendPayload: true,
		options: {},
	};

export const defaultMessageEventBusDestinationSentryOptions: MessageEventBusDestinationSentryOptions =
	{
		...defaultMessageEventBusDestinationOptions,
		__type: MessageEventBusDestinationTypeNames.sentry,
		label: 'Sentry DSN',
		dsn: 'https://',
		sendPayload: true,
	};



================================================
FILE: packages/workflow/src/metadata-utils.ts
================================================
import type { ITaskMetadata } from '.';
import { hasKey } from './utils';

function responseHasSubworkflowData(
	response: unknown,
): response is { executionId: string; workflowId: string } {
	return ['executionId', 'workflowId'].every(
		(x) => hasKey(response, x) && typeof response[x] === 'string',
	);
}

type ISubWorkflowMetadata = Required<Pick<ITaskMetadata, 'subExecution' | 'subExecutionsCount'>>;

function parseErrorResponseWorkflowMetadata(response: unknown): ISubWorkflowMetadata | undefined {
	if (!responseHasSubworkflowData(response)) return undefined;

	return {
		subExecution: {
			executionId: response.executionId,
			workflowId: response.workflowId,
		},
		subExecutionsCount: 1,
	};
}

export function parseErrorMetadata(error: unknown): ISubWorkflowMetadata | undefined {
	if (hasKey(error, 'errorResponse')) {
		return parseErrorResponseWorkflowMetadata(error.errorResponse);
	}

	// This accounts for cases where the backend attaches the properties on plain errors
	// e.g. from custom nodes throwing literal `Error` or `ApplicationError` objects directly
	return parseErrorResponseWorkflowMetadata(error);
}



================================================
FILE: packages/workflow/src/node-helpers.ts
================================================
/* eslint-disable @typescript-eslint/no-unsafe-argument */

/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
import get from 'lodash/get';
import isEqual from 'lodash/isEqual';

import { EXECUTE_WORKFLOW_NODE_TYPE, WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE } from './constants';
import { ApplicationError } from '@n8n/errors';
import { NodeConnectionTypes } from './interfaces';
import type {
	FieldType,
	IContextObject,
	INode,
	INodeCredentialDescription,
	INodeIssueObjectProperty,
	INodeIssues,
	INodeParameterResourceLocator,
	INodeParameters,
	INodeProperties,
	INodePropertyCollection,
	INodePropertyMode,
	INodePropertyModeValidation,
	INodePropertyOptions,
	INodePropertyRegexValidation,
	INodeType,
	IParameterDependencies,
	IRunExecutionData,
	IVersionedNodeType,
	NodeParameterValue,
	ResourceMapperValue,
	INodeTypeDescription,
	INodeOutputConfiguration,
	INodeInputConfiguration,
	GenericValue,
	DisplayCondition,
	NodeConnectionType,
} from './interfaces';
import { validateFilterParameter } from './node-parameters/filter-parameter';
import {
	isFilterValue,
	isINodePropertyOptionsList,
	isResourceLocatorValue,
	isResourceMapperValue,
	isValidResourceLocatorParameterValue,
} from './type-guards';
import { validateFieldType } from './type-validation';
import { deepCopy } from './utils';
import type { Workflow } from './workflow';

export const cronNodeOptions: INodePropertyCollection[] = [
	{
		name: 'item',
		displayName: 'Item',
		values: [
			{
				displayName: 'Mode',
				name: 'mode',
				type: 'options',
				options: [
					{
						name: 'Every Minute',
						value: 'everyMinute',
					},
					{
						name: 'Every Hour',
						value: 'everyHour',
					},
					{
						name: 'Every Day',
						value: 'everyDay',
					},
					{
						name: 'Every Week',
						value: 'everyWeek',
					},
					{
						name: 'Every Month',
						value: 'everyMonth',
					},
					{
						name: 'Every X',
						value: 'everyX',
					},
					{
						name: 'Custom',
						value: 'custom',
					},
				],
				default: 'everyDay',
				description: 'How often to trigger.',
			},
			{
				displayName: 'Hour',
				name: 'hour',
				type: 'number',
				typeOptions: {
					minValue: 0,
					maxValue: 23,
				},
				displayOptions: {
					hide: {
						mode: ['custom', 'everyHour', 'everyMinute', 'everyX'],
					},
				},
				default: 14,
				description: 'The hour of the day to trigger (24h format)',
			},
			{
				displayName: 'Minute',
				name: 'minute',
				type: 'number',
				typeOptions: {
					minValue: 0,
					maxValue: 59,
				},
				displayOptions: {
					hide: {
						mode: ['custom', 'everyMinute', 'everyX'],
					},
				},
				default: 0,
				description: 'The minute of the day to trigger',
			},
			{
				displayName: 'Day of Month',
				name: 'dayOfMonth',
				type: 'number',
				displayOptions: {
					show: {
						mode: ['everyMonth'],
					},
				},
				typeOptions: {
					minValue: 1,
					maxValue: 31,
				},
				default: 1,
				description: 'The day of the month to trigger',
			},
			{
				displayName: 'Weekday',
				name: 'weekday',
				type: 'options',
				displayOptions: {
					show: {
						mode: ['everyWeek'],
					},
				},
				options: [
					{
						name: 'Monday',
						value: '1',
					},
					{
						name: 'Tuesday',
						value: '2',
					},
					{
						name: 'Wednesday',
						value: '3',
					},
					{
						name: 'Thursday',
						value: '4',
					},
					{
						name: 'Friday',
						value: '5',
					},
					{
						name: 'Saturday',
						value: '6',
					},
					{
						name: 'Sunday',
						value: '0',
					},
				],
				default: '1',
				description: 'The weekday to trigger',
			},
			{
				displayName: 'Cron Expression',
				name: 'cronExpression',
				type: 'string',
				displayOptions: {
					show: {
						mode: ['custom'],
					},
				},
				default: '* * * * * *',
				description:
					'Use custom cron expression. Values and ranges as follows:<ul><li>Seconds: 0-59</li><li>Minutes: 0 - 59</li><li>Hours: 0 - 23</li><li>Day of Month: 1 - 31</li><li>Months: 0 - 11 (Jan - Dec)</li><li>Day of Week: 0 - 6 (Sun - Sat)</li></ul>',
			},
			{
				displayName: 'Value',
				name: 'value',
				type: 'number',
				typeOptions: {
					minValue: 0,
					maxValue: 1000,
				},
				displayOptions: {
					show: {
						mode: ['everyX'],
					},
				},
				default: 2,
				description: 'All how many X minutes/hours it should trigger',
			},
			{
				displayName: 'Unit',
				name: 'unit',
				type: 'options',
				displayOptions: {
					show: {
						mode: ['everyX'],
					},
				},
				options: [
					{
						name: 'Minutes',
						value: 'minutes',
					},
					{
						name: 'Hours',
						value: 'hours',
					},
				],
				default: 'hours',
				description: 'If it should trigger all X minutes or hours',
			},
		],
	},
];

/**
 * Determines if the provided node type has any output types other than the main connection type.
 * @param typeDescription The node's type description to check.
 */
export function isSubNodeType(
	typeDescription: Pick<INodeTypeDescription, 'outputs'> | null,
): boolean {
	if (!typeDescription?.outputs || typeof typeDescription.outputs === 'string') {
		return false;
	}
	const outputTypes = getConnectionTypes(typeDescription.outputs);
	return outputTypes
		? outputTypes.filter((output) => output !== NodeConnectionTypes.Main).length > 0
		: false;
}

const getPropertyValues = (
	nodeValues: INodeParameters,
	propertyName: string,
	node: Pick<INode, 'typeVersion'> | null,
	nodeTypeDescription: INodeTypeDescription | null,
	nodeValuesRoot: INodeParameters,
) => {
	let value;
	if (propertyName.charAt(0) === '/') {
		// Get the value from the root of the node
		value = get(nodeValuesRoot, propertyName.slice(1));
	} else if (propertyName === '@version') {
		value = node?.typeVersion || 0;
	} else if (propertyName === '@tool') {
		value = nodeTypeDescription?.name.endsWith('Tool') ?? false;
	} else {
		// Get the value from current level
		value = get(nodeValues, propertyName);
	}

	if (value && typeof value === 'object' && '__rl' in value && value.__rl) {
		value = value.value;
	}

	if (!Array.isArray(value)) {
		return [value as NodeParameterValue];
	} else {
		return value as NodeParameterValue[];
	}
};

const checkConditions = (
	conditions: Array<NodeParameterValue | DisplayCondition>,
	actualValues: NodeParameterValue[],
) => {
	return conditions.some((condition) => {
		if (
			condition &&
			typeof condition === 'object' &&
			condition._cnd &&
			Object.keys(condition).length === 1
		) {
			const [key, targetValue] = Object.entries(condition._cnd)[0];

			return actualValues.every((propertyValue) => {
				if (key === 'eq') {
					return isEqual(propertyValue, targetValue);
				}
				if (key === 'not') {
					return !isEqual(propertyValue, targetValue);
				}
				if (key === 'gte') {
					return (propertyValue as number) >= targetValue;
				}
				if (key === 'lte') {
					return (propertyValue as number) <= targetValue;
				}
				if (key === 'gt') {
					return (propertyValue as number) > targetValue;
				}
				if (key === 'lt') {
					return (propertyValue as number) < targetValue;
				}
				if (key === 'between') {
					const { from, to } = targetValue as { from: number; to: number };
					return (propertyValue as number) >= from && (propertyValue as number) <= to;
				}
				if (key === 'includes') {
					return (propertyValue as string).includes(targetValue);
				}
				if (key === 'startsWith') {
					return (propertyValue as string).startsWith(targetValue);
				}
				if (key === 'endsWith') {
					return (propertyValue as string).endsWith(targetValue);
				}
				if (key === 'regex') {
					return new RegExp(targetValue as string).test(propertyValue as string);
				}
				if (key === 'exists') {
					return propertyValue !== null && propertyValue !== undefined && propertyValue !== '';
				}
				return false;
			});
		}

		return actualValues.includes(condition as NodeParameterValue);
	});
};

/**
 * Returns if the parameter should be displayed or not
 *
 * @param {INodeParameters} nodeValues The data on the node which decides if the parameter
 *                                    should be displayed
 * @param {(INodeProperties | INodeCredentialDescription)} parameter The parameter to check if it should be displayed
 * @param {INodeParameters} [nodeValuesRoot] The root node-parameter-data
 */
export function displayParameter(
	nodeValues: INodeParameters,
	parameter: INodeProperties | INodeCredentialDescription,
	node: Pick<INode, 'typeVersion'> | null, // Allow null as it does also get used by credentials and they do not have versioning yet
	nodeTypeDescription: INodeTypeDescription | null,
	nodeValuesRoot?: INodeParameters,
	displayKey: 'displayOptions' | 'disabledOptions' = 'displayOptions',
) {
	if (!parameter[displayKey]) {
		return true;
	}

	const { show, hide } = parameter[displayKey];

	nodeValuesRoot = nodeValuesRoot || nodeValues;

	if (show) {
		// All the defined rules have to match to display parameter
		for (const propertyName of Object.keys(show)) {
			const values = getPropertyValues(
				nodeValues,
				propertyName,
				node,
				nodeTypeDescription,
				nodeValuesRoot,
			);

			if (values.some((v) => typeof v === 'string' && v.charAt(0) === '=')) {
				return true;
			}

			if (values.length === 0 || !checkConditions(show[propertyName]!, values)) {
				return false;
			}
		}
	}

	if (hide) {
		// Any of the defined hide rules have to match to hide the parameter
		for (const propertyName of Object.keys(hide)) {
			const values = getPropertyValues(
				nodeValues,
				propertyName,
				node,
				nodeTypeDescription,
				nodeValuesRoot,
			);

			if (values.length !== 0 && checkConditions(hide[propertyName]!, values)) {
				return false;
			}
		}
	}

	return true;
}

/**
 * Returns if the given parameter should be displayed or not considering the path
 * to the properties
 *
 * @param {INodeParameters} nodeValues The data on the node which decides if the parameter
 *                                    should be displayed
 * @param {(INodeProperties | INodeCredentialDescription)} parameter The parameter to check if it should be displayed
 * @param {string} path The path to the property
 */
export function displayParameterPath(
	nodeValues: INodeParameters,
	parameter: INodeProperties | INodeCredentialDescription,
	path: string,
	node: Pick<INode, 'typeVersion'> | null,
	nodeTypeDescription: INodeTypeDescription | null,
	displayKey: 'displayOptions' | 'disabledOptions' = 'displayOptions',
) {
	let resolvedNodeValues = nodeValues;
	if (path !== '') {
		resolvedNodeValues = get(nodeValues, path) as INodeParameters;
	}

	// Get the root parameter data
	let nodeValuesRoot = nodeValues;
	if (path && path.split('.').indexOf('parameters') === 0) {
		nodeValuesRoot = get(nodeValues, 'parameters') as INodeParameters;
	}

	return displayParameter(
		resolvedNodeValues,
		parameter,
		node,
		nodeTypeDescription,
		nodeValuesRoot,
		displayKey,
	);
}

/**
 * Returns the context data
 *
 * @param {IRunExecutionData} runExecutionData The run execution data
 * @param {string} type The data type. "node"/"flow"
 * @param {INode} [node] If type "node" is set the node to return the context of has to be supplied
 */
export function getContext(
	runExecutionData: IRunExecutionData,
	type: string,
	node?: INode,
): IContextObject {
	if (runExecutionData.executionData === undefined) {
		// TODO: Should not happen leave it for test now
		throw new ApplicationError('`executionData` is not initialized');
	}

	let key: string;
	if (type === 'flow') {
		key = 'flow';
	} else if (type === 'node') {
		if (node === undefined) {
			// @TODO: What does this mean?
			throw new ApplicationError(
				'The request data of context type "node" the node parameter has to be set!',
			);
		}
		key = `node:${node.name}`;
	} else {
		throw new ApplicationError('Unknown context type. Only `flow` and `node` are supported.', {
			extra: { contextType: type },
		});
	}

	if (runExecutionData.executionData.contextData[key] === undefined) {
		runExecutionData.executionData.contextData[key] = {};
	}

	return runExecutionData.executionData.contextData[key];
}

/**
 * Returns which parameters are dependent on which
 */
function getParameterDependencies(nodePropertiesArray: INodeProperties[]): IParameterDependencies {
	const dependencies: IParameterDependencies = {};

	for (const nodeProperties of nodePropertiesArray) {
		const { name, displayOptions } = nodeProperties;

		if (!dependencies[name]) {
			dependencies[name] = [];
		}

		if (!displayOptions) {
			// Does not have any dependencies
			continue;
		}

		for (const displayRule of Object.values(displayOptions)) {
			for (const parameterName of Object.keys(displayRule)) {
				if (!dependencies[name].includes(parameterName)) {
					if (parameterName.charAt(0) === '@') {
						// Is a special parameter so can be skipped
						continue;
					}
					dependencies[name].push(parameterName);
				}
			}
		}
	}

	return dependencies;
}

/**
 * Returns in which order the parameters should be resolved
 * to have the parameters available they depend on
 */
function getParameterResolveOrder(
	nodePropertiesArray: INodeProperties[],
	parameterDependencies: IParameterDependencies,
): number[] {
	const executionOrder: number[] = [];
	const indexToResolve = Array.from({ length: nodePropertiesArray.length }, (_, k) => k);
	const resolvedParameters: string[] = [];

	let index: number;
	let property: INodeProperties;

	let lastIndexLength = indexToResolve.length;
	let lastIndexReduction = -1;

	let iterations = 0;

	while (indexToResolve.length !== 0) {
		iterations += 1;

		index = indexToResolve.shift() as number;
		property = nodePropertiesArray[index];

		if (parameterDependencies[property.name].length === 0) {
			// Does not have any dependencies so simply add
			executionOrder.push(index);
			resolvedParameters.push(property.name);
			continue;
		}

		// Parameter has dependencies
		for (const dependency of parameterDependencies[property.name]) {
			if (!resolvedParameters.includes(dependency)) {
				if (dependency.charAt(0) === '/') {
					// Assume that root level dependencies are resolved
					continue;
				}
				// Dependencies for that parameter are still missing so
				// try to add again later
				indexToResolve.push(index);
				continue;
			}
		}

		// All dependencies got found so add
		executionOrder.push(index);
		resolvedParameters.push(property.name);

		if (indexToResolve.length < lastIndexLength) {
			lastIndexReduction = iterations;
		}

		if (iterations > lastIndexReduction + nodePropertiesArray.length) {
			throw new ApplicationError(
				'Could not resolve parameter dependencies. Max iterations reached! Hint: If `displayOptions` are specified in any child parameter of a parent `collection` or `fixedCollection`, remove the `displayOptions` from the child parameter.',
			);
		}
		lastIndexLength = indexToResolve.length;
	}

	return executionOrder;
}

type GetNodeParametersOptions = {
	onlySimpleTypes?: boolean;
	dataIsResolved?: boolean; // If nodeValues are already fully resolved (so that all default values got added already)
	nodeValuesRoot?: INodeParameters;
	parentType?: string;
	parameterDependencies?: IParameterDependencies;
};

/**
 * Returns the node parameter values. Depending on the settings it either just returns the none
 * default values or it applies all the default values.
 *
 * @param {INodeProperties[]} nodePropertiesArray The properties which exist and their settings
 * @param {INodeParameters} nodeValues The node parameter data
 * @param {boolean} returnDefaults If default values get added or only none default values returned
 * @param {boolean} returnNoneDisplayed If also values which should not be displayed should be returned
 * @param {GetNodeParametersOptions} options Optional properties
 */
// eslint-disable-next-line complexity
export function getNodeParameters(
	nodePropertiesArray: INodeProperties[],
	nodeValues: INodeParameters | null,
	returnDefaults: boolean,
	returnNoneDisplayed: boolean,
	node: Pick<INode, 'typeVersion'> | null,
	nodeTypeDescription: INodeTypeDescription | null,
	options?: GetNodeParametersOptions,
): INodeParameters | null {
	let { nodeValuesRoot, parameterDependencies } = options ?? {};
	const { onlySimpleTypes = false, dataIsResolved = false, parentType } = options ?? {};
	if (parameterDependencies === undefined) {
		parameterDependencies = getParameterDependencies(nodePropertiesArray);
	}

	// Get the parameter names which get used multiple times as for this
	// ones we have to always check which ones get displayed and which ones not
	const duplicateParameterNames: string[] = [];
	const parameterNames: string[] = [];
	for (const nodeProperties of nodePropertiesArray) {
		if (parameterNames.includes(nodeProperties.name)) {
			if (!duplicateParameterNames.includes(nodeProperties.name)) {
				duplicateParameterNames.push(nodeProperties.name);
			}
		} else {
			parameterNames.push(nodeProperties.name);
		}
	}

	const nodeParameters: INodeParameters = {};
	const nodeParametersFull: INodeParameters = {};

	let nodeValuesDisplayCheck = nodeParametersFull;
	if (!dataIsResolved && !returnNoneDisplayed) {
		nodeValuesDisplayCheck = getNodeParameters(
			nodePropertiesArray,
			nodeValues,
			true,
			true,
			node,
			nodeTypeDescription,
			{
				onlySimpleTypes: true,
				dataIsResolved: true,
				nodeValuesRoot,
				parentType,
				parameterDependencies,
			},
		) as INodeParameters;
	}

	nodeValuesRoot = nodeValuesRoot || nodeValuesDisplayCheck;

	// Go through the parameters in order of their dependencies
	const parameterIterationOrderIndex = getParameterResolveOrder(
		nodePropertiesArray,
		parameterDependencies,
	);

	for (const parameterIndex of parameterIterationOrderIndex) {
		const nodeProperties = nodePropertiesArray[parameterIndex];
		if (
			!nodeValues ||
			(nodeValues[nodeProperties.name] === undefined &&
				(!returnDefaults || parentType === 'collection'))
		) {
			// The value is not defined so go to the next
			continue;
		}

		if (
			!returnNoneDisplayed &&
			!displayParameter(
				nodeValuesDisplayCheck,
				nodeProperties,
				node,
				nodeTypeDescription,
				nodeValuesRoot,
			)
		) {
			if (!returnNoneDisplayed || !returnDefaults) {
				continue;
			}
		}

		if (!['collection', 'fixedCollection'].includes(nodeProperties.type)) {
			// Is a simple property so can be set as it is

			if (duplicateParameterNames.includes(nodeProperties.name)) {
				if (
					!displayParameter(
						nodeValuesDisplayCheck,
						nodeProperties,
						node,
						nodeTypeDescription,
						nodeValuesRoot,
					)
				) {
					continue;
				}
			}

			if (returnDefaults) {
				// Set also when it has the default value
				if (['boolean', 'number', 'options'].includes(nodeProperties.type)) {
					// Boolean, numbers and options are special as false and 0 are valid values
					// and should not be replaced with default value
					nodeParameters[nodeProperties.name] =
						nodeValues[nodeProperties.name] !== undefined
							? nodeValues[nodeProperties.name]
							: nodeProperties.default;
				} else if (
					nodeProperties.type === 'resourceLocator' &&
					typeof nodeProperties.default === 'object'
				) {
					nodeParameters[nodeProperties.name] =
						nodeValues[nodeProperties.name] !== undefined
							? nodeValues[nodeProperties.name]
							: { __rl: true, ...nodeProperties.default };
				} else {
					nodeParameters[nodeProperties.name] =
						nodeValues[nodeProperties.name] ?? nodeProperties.default;
				}
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
			} else if (
				(nodeValues[nodeProperties.name] !== nodeProperties.default &&
					typeof nodeValues[nodeProperties.name] !== 'object') ||
				(typeof nodeValues[nodeProperties.name] === 'object' &&
					!isEqual(nodeValues[nodeProperties.name], nodeProperties.default)) ||
				(nodeValues[nodeProperties.name] !== undefined && parentType === 'collection')
			) {
				// Set only if it is different to the default value
				nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name];
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				continue;
			}
		}

		if (onlySimpleTypes) {
			// It is only supposed to resolve the simple types. So continue.
			continue;
		}

		// Is a complex property so check lower levels
		let tempValue: INodeParameters | null;
		if (nodeProperties.type === 'collection') {
			// Is collection

			if (
				nodeProperties.typeOptions !== undefined &&
				nodeProperties.typeOptions.multipleValues === true
			) {
				// Multiple can be set so will be an array

				// Return directly the values like they are
				if (nodeValues[nodeProperties.name] !== undefined) {
					nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name];
				} else if (returnDefaults) {
					// Does not have values defined but defaults should be returned
					if (Array.isArray(nodeProperties.default)) {
						nodeParameters[nodeProperties.name] = deepCopy(nodeProperties.default);
					} else {
						// As it is probably wrong for many nodes, do we keep on returning an empty array if
						// anything else than an array is set as default
						nodeParameters[nodeProperties.name] = [];
					}
				}
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
			} else if (nodeValues[nodeProperties.name] !== undefined) {
				// Has values defined so get them
				const tempNodeParameters = getNodeParameters(
					nodeProperties.options as INodeProperties[],
					nodeValues[nodeProperties.name] as INodeParameters,
					returnDefaults,
					returnNoneDisplayed,
					node,
					nodeTypeDescription,
					{
						onlySimpleTypes: false,
						dataIsResolved: false,
						nodeValuesRoot,
						parentType: nodeProperties.type,
					},
				);

				if (tempNodeParameters !== null) {
					nodeParameters[nodeProperties.name] = tempNodeParameters;
					nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				}
			} else if (returnDefaults) {
				// Does not have values defined but defaults should be returned
				nodeParameters[nodeProperties.name] = deepCopy(nodeProperties.default);
				nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
			}
		} else if (nodeProperties.type === 'fixedCollection') {
			// Is fixedCollection

			const collectionValues: INodeParameters = {};
			let tempNodeParameters: INodeParameters;
			let tempNodePropertiesArray: INodeProperties[];
			let nodePropertyOptions: INodePropertyCollection | undefined;

			let propertyValues = nodeValues[nodeProperties.name];
			if (returnDefaults) {
				if (propertyValues === undefined) {
					propertyValues = deepCopy(nodeProperties.default);
				}
			}

			if (
				!returnDefaults &&
				nodeProperties.typeOptions?.multipleValues === false &&
				propertyValues &&
				Object.keys(propertyValues).length === 0
			) {
				// For fixedCollections, which only allow one value, it is important to still return
				// the empty object which indicates that a value got added, even if it does not have
				// anything set. If that is not done, the value would get lost.
				return nodeValues;
			}

			// Iterate over all collections
			for (const itemName of Object.keys(propertyValues || {})) {
				if (
					nodeProperties.typeOptions !== undefined &&
					nodeProperties.typeOptions.multipleValues === true
				) {
					// Multiple can be set so will be an array

					const tempArrayValue: INodeParameters[] = [];
					// Collection values should always be an object
					if (typeof propertyValues !== 'object' || Array.isArray(propertyValues)) {
						continue;
					}
					// Iterate over all items as it contains multiple ones
					for (const nodeValue of (propertyValues as INodeParameters)[
						itemName
					] as INodeParameters[]) {
						nodePropertyOptions = nodeProperties.options!.find(
							(nodePropertyOptions) => nodePropertyOptions.name === itemName,
						) as INodePropertyCollection;

						if (nodePropertyOptions === undefined) {
							throw new ApplicationError('Could not find property option', {
								extra: { propertyOption: itemName, property: nodeProperties.name },
							});
						}

						tempNodePropertiesArray = nodePropertyOptions.values!;
						tempValue = getNodeParameters(
							tempNodePropertiesArray,
							nodeValue,
							returnDefaults,
							returnNoneDisplayed,
							node,
							nodeTypeDescription,
							{
								onlySimpleTypes: false,
								dataIsResolved: false,
								nodeValuesRoot,
								parentType: nodeProperties.type,
							},
						);
						if (tempValue !== null) {
							tempArrayValue.push(tempValue);
						}
					}
					collectionValues[itemName] = tempArrayValue;
				} else {
					// Only one can be set so is an object of objects
					tempNodeParameters = {};

					// Get the options of the current item

					const nodePropertyOptions = nodeProperties.options!.find(
						(data) => data.name === itemName,
					);

					if (nodePropertyOptions !== undefined) {
						tempNodePropertiesArray = (nodePropertyOptions as INodePropertyCollection).values!;
						tempValue = getNodeParameters(
							tempNodePropertiesArray,
							(nodeValues[nodeProperties.name] as INodeParameters)[itemName] as INodeParameters,
							returnDefaults,
							returnNoneDisplayed,
							node,
							nodeTypeDescription,
							{
								onlySimpleTypes: false,
								dataIsResolved: false,
								nodeValuesRoot,
								parentType: nodeProperties.type,
							},
						);
						if (tempValue !== null) {
							Object.assign(tempNodeParameters, tempValue);
						}
					}

					if (Object.keys(tempNodeParameters).length !== 0) {
						collectionValues[itemName] = tempNodeParameters;
					}
				}
			}

			if (
				!returnDefaults &&
				nodeProperties.typeOptions?.multipleValues === false &&
				collectionValues &&
				Object.keys(collectionValues).length === 0 &&
				propertyValues &&
				propertyValues?.constructor.name === 'Object' &&
				Object.keys(propertyValues).length !== 0
			) {
				// For fixedCollections, which only allow one value, it is important to still return
				// the object with an empty collection property which indicates that a value got added
				// which contains all default values. If that is not done, the value would get lost.
				const returnValue = {} as INodeParameters;
				Object.keys(propertyValues || {}).forEach((value) => {
					returnValue[value] = {};
				});
				nodeParameters[nodeProperties.name] = returnValue;
			}

			if (Object.keys(collectionValues).length !== 0 || returnDefaults) {
				// Set only if value got found
				if (returnDefaults) {
					// Set also when it has the default value
					if (collectionValues === undefined) {
						nodeParameters[nodeProperties.name] = deepCopy(nodeProperties.default);
					} else {
						nodeParameters[nodeProperties.name] = collectionValues;
					}
					nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				} else if (collectionValues !== nodeProperties.default) {
					// Set only if values got found and it is not the default
					nodeParameters[nodeProperties.name] = collectionValues;
					nodeParametersFull[nodeProperties.name] = nodeParameters[nodeProperties.name];
				}
			}
		}
	}
	return nodeParameters;
}

/**
 * Returns the webhook path
 */
export function getNodeWebhookPath(
	workflowId: string,
	node: INode,
	path: string,
	isFullPath?: boolean,
	restartWebhook?: boolean,
) {
	let webhookPath = '';

	if (restartWebhook === true) {
		return path;
	}

	if (node.webhookId === undefined) {
		const nodeName = encodeURIComponent(node.name.toLowerCase());

		webhookPath = `${workflowId}/${nodeName}/${path}`;
	} else {
		if (isFullPath === true) {
			return path || node.webhookId;
		}

		webhookPath = `${node.webhookId}/${path}`;
	}
	return webhookPath;
}

/**
 * Returns the webhook URL
 */
export function getNodeWebhookUrl(
	baseUrl: string,
	workflowId: string,
	node: INode,
	path: string,
	isFullPath?: boolean,
): string {
	if ((path.startsWith(':') || path.includes('/:')) && node.webhookId) {
		// setting this to false to prefix the webhookId
		isFullPath = false;
	}
	if (path.startsWith('/')) {
		path = path.slice(1);
	}
	return `${baseUrl}/${getNodeWebhookPath(workflowId, node, path, isFullPath)}`;
}

export function getConnectionTypes(
	connections: Array<NodeConnectionType | INodeInputConfiguration | INodeOutputConfiguration>,
): NodeConnectionType[] {
	return connections
		.map((connection) => {
			if (typeof connection === 'string') {
				return connection;
			}
			return connection.type;
		})
		.filter((connection) => connection !== undefined);
}

export function getNodeInputs(
	workflow: Workflow,
	node: INode,
	nodeTypeData: INodeTypeDescription,
): Array<NodeConnectionType | INodeInputConfiguration> {
	if (Array.isArray(nodeTypeData?.inputs)) {
		return nodeTypeData.inputs;
	}

	// Calculate the outputs dynamically
	try {
		return (workflow.expression.getSimpleParameterValue(
			node,
			nodeTypeData.inputs,
			'internal',
			{},
		) || []) as NodeConnectionType[];
	} catch (e) {
		console.warn('Could not calculate inputs dynamically for node: ', node.name);
		return [];
	}
}

export function getNodeOutputs(
	workflow: Workflow,
	node: INode,
	nodeTypeData: INodeTypeDescription,
): Array<NodeConnectionType | INodeOutputConfiguration> {
	let outputs: Array<NodeConnectionType | INodeOutputConfiguration> = [];

	if (Array.isArray(nodeTypeData.outputs)) {
		outputs = nodeTypeData.outputs;
	} else {
		// Calculate the outputs dynamically
		try {
			outputs = (workflow.expression.getSimpleParameterValue(
				node,
				nodeTypeData.outputs,
				'internal',
				{},
			) || []) as NodeConnectionType[];
		} catch (e) {
			console.warn('Could not calculate outputs dynamically for node: ', node.name);
		}
	}

	if (node.onError === 'continueErrorOutput') {
		// Copy the data to make sure that we do not change the data of the
		// node type and so change the displayNames for all nodes in the flow
		outputs = deepCopy(outputs);
		if (outputs.length === 1) {
			// Set the displayName to "Success"
			if (typeof outputs[0] === 'string') {
				outputs[0] = {
					type: outputs[0],
				};
			}
			outputs[0].displayName = 'Success';
		}
		return [
			...outputs,
			{
				category: 'error',
				type: NodeConnectionTypes.Main,
				displayName: 'Error',
			},
		];
	}

	return outputs;
}

/**
 * Returns all the parameter-issues of the node
 *
 * @param {INodeProperties[]} nodePropertiesArray The properties of the node
 * @param {INode} node The data of the node
 */
export function getNodeParametersIssues(
	nodePropertiesArray: INodeProperties[],
	node: INode,
	nodeTypeDescription: INodeTypeDescription | null,
	pinDataNodeNames?: string[],
): INodeIssues | null {
	const foundIssues: INodeIssues = {};
	let propertyIssues: INodeIssues;

	if (node.disabled === true || pinDataNodeNames?.includes(node.name)) {
		// Ignore issues on disabled and pindata nodes
		return null;
	}

	for (const nodeProperty of nodePropertiesArray) {
		propertyIssues = getParameterIssues(
			nodeProperty,
			node.parameters,
			'',
			node,
			nodeTypeDescription,
		);
		mergeIssues(foundIssues, propertyIssues);
	}

	if (Object.keys(foundIssues).length === 0) {
		return null;
	}

	return foundIssues;
}

/*
 * Validates resource locator node parameters based on validation ruled defined in each parameter mode
 */
const validateResourceLocatorParameter = (
	value: INodeParameterResourceLocator,
	parameterMode: INodePropertyMode,
): string[] => {
	const valueToValidate = value?.value?.toString() || '';
	if (valueToValidate.startsWith('=')) {
		return [];
	}

	const validationErrors: string[] = [];
	// Each mode can have multiple validations specified
	if (parameterMode.validation) {
		for (const validation of parameterMode.validation) {
			if (validation && (validation as INodePropertyModeValidation).type === 'regex') {
				const regexValidation = validation as INodePropertyRegexValidation;
				const regex = new RegExp(`^${regexValidation.properties.regex}$`);

				if (!regex.test(valueToValidate)) {
					validationErrors.push(regexValidation.properties.errorMessage);
				}
			}
		}
	}

	return validationErrors;
};

/*
 * Validates resource mapper values based on service schema
 */
const validateResourceMapperParameter = (
	nodeProperties: INodeProperties,
	value: ResourceMapperValue,
	skipRequiredCheck = false,
): Record<string, string[]> => {
	// No issues to raise in automatic mapping mode, no user input to validate
	if (value.mappingMode === 'autoMapInputData') {
		return {};
	}

	const issues: Record<string, string[]> = {};
	let fieldWordSingular =
		nodeProperties.typeOptions?.resourceMapper?.fieldWords?.singular || 'Field';
	fieldWordSingular = fieldWordSingular.charAt(0).toUpperCase() + fieldWordSingular.slice(1);
	value.schema.forEach((field) => {
		const fieldValue = value.value ? value.value[field.id] : null;
		const key = `${nodeProperties.name}.${field.id}`;
		const fieldErrors: string[] = [];
		if (field.required && !skipRequiredCheck) {
			if (value.value === null || fieldValue === undefined) {
				const error = `${fieldWordSingular} "${field.id}" is required`;
				fieldErrors.push(error);
			}
		}
		if (!fieldValue?.toString().startsWith('=') && field.type) {
			const validationResult = validateFieldType(field.id, fieldValue, field.type, {
				valueOptions: field.options,
			});
			if (!validationResult.valid && validationResult.errorMessage) {
				fieldErrors.push(validationResult.errorMessage);
			}
		}
		if (fieldErrors.length > 0) {
			issues[key] = fieldErrors;
		}
	});
	return issues;
};

const validateParameter = (
	nodeProperties: INodeProperties,
	value: GenericValue,
	type: FieldType,
): string | undefined => {
	const nodeName = nodeProperties.name;
	const options = type === 'options' ? nodeProperties.options : undefined;

	if (!value?.toString().startsWith('=')) {
		const validationResult = validateFieldType(nodeName, value, type, {
			valueOptions: options as INodePropertyOptions[],
		});

		if (!validationResult.valid && validationResult.errorMessage) {
			return validationResult.errorMessage;
		}
	}

	return undefined;
};

/**
 * Adds an issue if the parameter is not defined
 *
 * @param {INodeIssues} foundIssues The already found issues
 * @param {INodeProperties} nodeProperties The properties of the node
 * @param {NodeParameterValue} value The value of the parameter
 */
function addToIssuesIfMissing(
	foundIssues: INodeIssues,
	nodeProperties: INodeProperties,
	value: NodeParameterValue | INodeParameterResourceLocator,
) {
	// TODO: Check what it really has when undefined
	if (
		(nodeProperties.type === 'string' && (value === '' || value === undefined)) ||
		(nodeProperties.type === 'multiOptions' && Array.isArray(value) && value.length === 0) ||
		(nodeProperties.type === 'dateTime' && (value === '' || value === undefined)) ||
		(nodeProperties.type === 'options' && (value === '' || value === undefined)) ||
		((nodeProperties.type === 'resourceLocator' || nodeProperties.type === 'workflowSelector') &&
			!isValidResourceLocatorParameterValue(value as INodeParameterResourceLocator))
	) {
		// Parameter is required but empty
		if (foundIssues.parameters === undefined) {
			foundIssues.parameters = {};
		}
		if (foundIssues.parameters[nodeProperties.name] === undefined) {
			foundIssues.parameters[nodeProperties.name] = [];
		}

		foundIssues.parameters[nodeProperties.name].push(
			`Parameter "${nodeProperties.displayName}" is required.`,
		);
	}
}

/**
 * Returns the parameter value
 *
 * @param {INodeParameters} nodeValues The values of the node
 * @param {string} parameterName The name of the parameter to return the value of
 * @param {string} path The path to the properties
 */
export function getParameterValueByPath(
	nodeValues: INodeParameters,
	parameterName: string,
	path: string,
) {
	return get(nodeValues, path ? `${path}.${parameterName}` : parameterName);
}

function isINodeParameterResourceLocator(value: unknown): value is INodeParameterResourceLocator {
	return typeof value === 'object' && value !== null && 'value' in value && 'mode' in value;
}

/**
 * Returns all the issues with the given node-values
 *
 * @param {INodeProperties} nodeProperties The properties of the node
 * @param {INodeParameters} nodeValues The values of the node
 * @param {string} path The path to the properties
 */
// eslint-disable-next-line complexity
export function getParameterIssues(
	nodeProperties: INodeProperties,
	nodeValues: INodeParameters,
	path: string,
	node: INode,
	nodeTypeDescription: INodeTypeDescription | null,
): INodeIssues {
	const foundIssues: INodeIssues = {};
	const isDisplayed = displayParameterPath(
		nodeValues,
		nodeProperties,
		path,
		node,
		nodeTypeDescription,
	);
	if (nodeProperties.required === true) {
		if (isDisplayed) {
			const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);

			if (
				// eslint-disable-next-line @typescript-eslint/prefer-optional-chain
				nodeProperties.typeOptions !== undefined &&
				nodeProperties.typeOptions.multipleValues !== undefined
			) {
				// Multiple can be set so will be an array
				if (Array.isArray(value)) {
					for (const singleValue of value as NodeParameterValue[]) {
						addToIssuesIfMissing(foundIssues, nodeProperties, singleValue);
					}
				}
			} else {
				// Only one can be set so will be a single value
				addToIssuesIfMissing(foundIssues, nodeProperties, value as NodeParameterValue);
			}
		}
	}

	if (
		(nodeProperties.type === 'resourceLocator' || nodeProperties.type === 'workflowSelector') &&
		isDisplayed
	) {
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		if (isINodeParameterResourceLocator(value)) {
			const mode = nodeProperties.modes?.find((option) => option.name === value.mode);
			if (mode) {
				const errors = validateResourceLocatorParameter(value, mode);
				errors.forEach((error) => {
					if (foundIssues.parameters === undefined) {
						foundIssues.parameters = {};
					}
					if (foundIssues.parameters[nodeProperties.name] === undefined) {
						foundIssues.parameters[nodeProperties.name] = [];
					}

					foundIssues.parameters[nodeProperties.name].push(error);
				});
			}
		}
	} else if (nodeProperties.type === 'resourceMapper' && isDisplayed) {
		const skipRequiredCheck = nodeProperties.typeOptions?.resourceMapper?.mode !== 'add';
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		if (isResourceMapperValue(value)) {
			const issues = validateResourceMapperParameter(nodeProperties, value, skipRequiredCheck);
			if (Object.keys(issues).length > 0) {
				if (foundIssues.parameters === undefined) {
					foundIssues.parameters = {};
				}
				if (foundIssues.parameters[nodeProperties.name] === undefined) {
					foundIssues.parameters[nodeProperties.name] = [];
				}
				foundIssues.parameters = { ...foundIssues.parameters, ...issues };
			}
		}
	} else if (nodeProperties.type === 'filter' && isDisplayed) {
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		if (isFilterValue(value)) {
			const issues = validateFilterParameter(nodeProperties, value);
			if (Object.keys(issues).length > 0) {
				foundIssues.parameters = { ...foundIssues.parameters, ...issues };
			}
		}
	} else if (nodeProperties.validateType) {
		const value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
		const error = validateParameter(nodeProperties, value, nodeProperties.validateType);
		if (error) {
			if (foundIssues.parameters === undefined) {
				foundIssues.parameters = {};
			}
			if (foundIssues.parameters[nodeProperties.name] === undefined) {
				foundIssues.parameters[nodeProperties.name] = [];
			}

			foundIssues.parameters[nodeProperties.name].push(error);
		}
	}

	// Check if there are any child parameters
	if (nodeProperties.options === undefined) {
		// There are none so nothing else to check
		return foundIssues;
	}

	// Check the child parameters

	// Important:
	// Checks the child properties only if the property is defined on current level.
	// That means that the required flag works only for the current level only. If
	// it is set on a lower level it means that the property is only required in case
	// the parent property got set.

	let basePath = path ? `${path}.` : '';

	const checkChildNodeProperties: Array<{
		basePath: string;
		data: INodeProperties;
	}> = [];

	// Collect all the properties to check
	if (nodeProperties.type === 'collection') {
		for (const option of nodeProperties.options) {
			checkChildNodeProperties.push({
				basePath,
				data: option as INodeProperties,
			});
		}
	} else if (nodeProperties.type === 'fixedCollection' && isDisplayed) {
		basePath = basePath ? `${basePath}.` : `${nodeProperties.name}.`;

		let propertyOptions: INodePropertyCollection;
		for (propertyOptions of nodeProperties.options as INodePropertyCollection[]) {
			// Check if the option got set and if not skip it
			const value = getParameterValueByPath(
				nodeValues,
				propertyOptions.name,
				basePath.slice(0, -1),
			);

			// Validate allowed field counts
			const valueArray = Array.isArray(value) ? value : [];
			const { minRequiredFields, maxAllowedFields } = nodeProperties.typeOptions ?? {};
			let error = '';

			if (minRequiredFields && valueArray.length < minRequiredFields) {
				error = `At least ${minRequiredFields} ${minRequiredFields === 1 ? 'field is' : 'fields are'} required.`;
			}
			if (maxAllowedFields && valueArray.length > maxAllowedFields) {
				error = `At most ${maxAllowedFields} ${maxAllowedFields === 1 ? 'field is' : 'fields are'} allowed.`;
			}
			if (error) {
				foundIssues.parameters ??= {};
				foundIssues.parameters[nodeProperties.name] ??= [];
				foundIssues.parameters[nodeProperties.name].push(error);
			}

			if (value === undefined) {
				continue;
			}

			if (
				// eslint-disable-next-line @typescript-eslint/prefer-optional-chain
				nodeProperties.typeOptions !== undefined &&
				nodeProperties.typeOptions.multipleValues !== undefined
			) {
				// Multiple can be set so will be an array of objects
				if (Array.isArray(value)) {
					for (let i = 0; i < (value as INodeParameters[]).length; i++) {
						for (const option of propertyOptions.values) {
							checkChildNodeProperties.push({
								basePath: `${basePath}${propertyOptions.name}[${i}]`,
								data: option,
							});
						}
					}
				}
			} else {
				// Only one can be set so will be an object
				for (const option of propertyOptions.values) {
					checkChildNodeProperties.push({
						basePath: basePath + propertyOptions.name,
						data: option,
					});
				}
			}
		}
	} else {
		// For all other types there is nothing to check so return
		return foundIssues;
	}

	let propertyIssues;

	for (const optionData of checkChildNodeProperties) {
		propertyIssues = getParameterIssues(
			optionData.data,
			nodeValues,
			optionData.basePath,
			node,
			nodeTypeDescription,
		);
		mergeIssues(foundIssues, propertyIssues);
	}

	return foundIssues;
}

/**
 * Merges multiple NodeIssues together
 *
 * @param {INodeIssues} destination The issues to merge into
 * @param {(INodeIssues | null)} source The issues to merge
 */
export function mergeIssues(destination: INodeIssues, source: INodeIssues | null) {
	if (source === null) {
		// Nothing to merge
		return;
	}

	if (source.execution === true) {
		destination.execution = true;
	}

	const objectProperties = ['parameters', 'credentials'];

	let destinationProperty: INodeIssueObjectProperty;
	for (const propertyName of objectProperties) {
		if (source[propertyName] !== undefined) {
			if (destination[propertyName] === undefined) {
				destination[propertyName] = {};
			}

			let parameterName: string;
			for (parameterName of Object.keys(source[propertyName] as INodeIssueObjectProperty)) {
				destinationProperty = destination[propertyName] as INodeIssueObjectProperty;
				if (destinationProperty[parameterName] === undefined) {
					destinationProperty[parameterName] = [];
				}
				destinationProperty[parameterName].push.apply(
					destinationProperty[parameterName],
					(source[propertyName] as INodeIssueObjectProperty)[parameterName],
				);
			}
		}
	}

	if (source.typeUnknown === true) {
		destination.typeUnknown = true;
	}
}

/**
 * Merges the given node properties
 */
export function mergeNodeProperties(
	mainProperties: INodeProperties[],
	addProperties: INodeProperties[],
): void {
	let existingIndex: number;
	for (const property of addProperties) {
		if (property.doNotInherit) continue;

		existingIndex = mainProperties.findIndex((element) => element.name === property.name);

		if (existingIndex === -1) {
			// Property does not exist yet, so add
			mainProperties.push(property);
		} else {
			// Property exists already, so overwrite
			mainProperties[existingIndex] = property;
		}
	}
}

export function getVersionedNodeType(
	object: IVersionedNodeType | INodeType,
	version?: number,
): INodeType {
	if ('nodeVersions' in object) {
		return object.getNodeType(version);
	}
	return object;
}

export function isTriggerNode(nodeTypeData: INodeTypeDescription) {
	return nodeTypeData.group.includes('trigger');
}

export function isExecutable(workflow: Workflow, node: INode, nodeTypeData: INodeTypeDescription) {
	const outputs = getNodeOutputs(workflow, node, nodeTypeData);
	const outputNames = getConnectionTypes(outputs);
	return (
		outputNames.includes(NodeConnectionTypes.Main) ||
		outputNames.includes(NodeConnectionTypes.AiTool) ||
		isTriggerNode(nodeTypeData)
	);
}

export function isNodeWithWorkflowSelector(node: INode) {
	return [EXECUTE_WORKFLOW_NODE_TYPE, WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE].includes(node.type);
}

/**
 * @returns An object containing either the resolved operation's action if available,
 * else the resource and operation if both exist.
 * If neither can be resolved, returns an empty object.
 */
function resolveResourceAndOperation(
	nodeParameters: INodeParameters,
	nodeTypeDescription: INodeTypeDescription,
) {
	if (nodeTypeDescription.name === 'n8n-nodes-base.code') {
		const language = nodeParameters.language as string;
		const langProp = nodeTypeDescription.properties.find((p) => p.name === 'language');
		if (langProp?.options && isINodePropertyOptionsList(langProp.options)) {
			const found = langProp.options.find((o) => o.value === language);
			if (found?.action) return { action: found.action };
		}
	}

	const resource = nodeParameters.resource as string;
	const operation = nodeParameters.operation as string;
	const nodeTypeOperation = nodeTypeDescription.properties.find(
		(p) => p.name === 'operation' && p.displayOptions?.show?.resource?.includes(resource),
	);

	if (nodeTypeOperation?.options && isINodePropertyOptionsList(nodeTypeOperation.options)) {
		const foundOperation = nodeTypeOperation.options.find((option) => option.value === operation);
		if (foundOperation?.action) {
			return { action: foundOperation.action };
		}
	}

	if (resource && operation) {
		return { operation, resource };
	} else {
		return {};
	}
}

/**
 * Generates a human-readable description for a node based on its parameters and type definition.
 *
 * This function creates a descriptive string that represents what the node does,
 * based on its resource, operation, and node type information. The description is
 * formatted in one of the following ways:
 *
 * 1. "{action} in {displayName}" if the operation has a defined action
 * 2. "{operation} {resource} in {displayName}" if resource and operation exist
 * 3. The node type's description field as a fallback
 */
export function makeDescription(
	nodeParameters: INodeParameters,
	nodeTypeDescription: INodeTypeDescription,
): string {
	const { action, operation, resource } = resolveResourceAndOperation(
		nodeParameters,
		nodeTypeDescription,
	);

	if (action) {
		return `${action} in ${nodeTypeDescription.defaults.name}`;
	}

	if (resource && operation) {
		return `${operation} ${resource} in ${nodeTypeDescription.defaults.name}`;
	}

	return nodeTypeDescription.description;
}

export function isTool(
	nodeTypeDescription: INodeTypeDescription,
	parameters: INodeParameters,
): boolean {
	// Check if node is a vector store in retrieve-as-tool mode
	if (nodeTypeDescription.name.includes('vectorStore')) {
		const mode = parameters.mode;
		return mode === 'retrieve-as-tool';
	}

	// Check for other tool nodes
	if (Array.isArray(nodeTypeDescription.outputs)) {
		// Handle static outputs (array case)
		for (const output of nodeTypeDescription.outputs) {
			if (typeof output === 'string') {
				return output === NodeConnectionTypes.AiTool;
			} else if (output?.type && output.type === NodeConnectionTypes.AiTool) {
				return true;
			}
		}
	}

	return false;
}

/**
 * Generates a resource and operation aware node name.
 *
 * Appends `in {nodeTypeDisplayName}` if nodeType is a tool
 *
 * 1. "{action}" if the operation has a defined action
 * 2. "{operation} {resource}" if resource and operation exist
 * 3. The node type's defaults.name field or displayName as a fallback
 */
export function makeNodeName(
	nodeParameters: INodeParameters,
	nodeTypeDescription: INodeTypeDescription,
): string {
	const { action, operation, resource } = resolveResourceAndOperation(
		nodeParameters,
		nodeTypeDescription,
	);

	const postfix = isTool(nodeTypeDescription, nodeParameters)
		? ` in ${nodeTypeDescription.defaults.name}`
		: '';

	if (action) {
		return `${action}${postfix}`;
	}

	if (resource && operation) {
		const operationProper = operation[0].toUpperCase() + operation.slice(1);
		return `${operationProper} ${resource}${postfix}`;
	}

	return nodeTypeDescription.defaults.name ?? nodeTypeDescription.displayName;
}

/**
 * Returns true if the node name is of format `<defaultNodeName>\d*` , which includes auto-renamed nodes
 */
export function isDefaultNodeName(
	name: string,
	nodeType: INodeTypeDescription,
	parameters: INodeParameters,
): boolean {
	const currentDefaultName = makeNodeName(parameters, nodeType);

	return name.startsWith(currentDefaultName) && /^\d*$/.test(name.slice(currentDefaultName.length));
}

/**
 * Determines whether a tool description should be updated and returns the new description if needed.
 * Returns undefined if no update is needed.
 */

export const getUpdatedToolDescription = (
	currentNodeType: INodeTypeDescription | null,
	newParameters: INodeParameters | null,
	currentParameters?: INodeParameters,
) => {
	if (!currentNodeType) return;

	if (newParameters?.descriptionType === 'manual' && currentParameters) {
		const previousDescription = makeDescription(currentParameters, currentNodeType);
		const newDescription = makeDescription(newParameters, currentNodeType);

		if (
			newParameters.toolDescription === previousDescription ||
			!newParameters.toolDescription?.toString().trim() ||
			newParameters.toolDescription === currentNodeType.description
		) {
			return newDescription;
		}
	}

	return;
};

/**
 * Generates a tool description for a given node based on its parameters and type.
 */
export function getToolDescriptionForNode(node: INode, nodeType: INodeType): string {
	let toolDescription;
	if (
		node.parameters.descriptionType === 'auto' ||
		!node?.parameters.toolDescription?.toString().trim()
	) {
		toolDescription = makeDescription(node.parameters, nodeType.description);
	} else if (node?.parameters.toolDescription) {
		toolDescription = node.parameters.toolDescription;
	} else {
		toolDescription = nodeType.description.description;
	}
	return toolDescription as string;
}

/**
 * Attempts to retrieve the ID of a subworkflow from a execute workflow node.
 */
export function getSubworkflowId(node: INode): string | undefined {
	if (isNodeWithWorkflowSelector(node) && isResourceLocatorValue(node.parameters.workflowId)) {
		return node.parameters.workflowId.value as string;
	}
	return;
}



================================================
FILE: packages/workflow/src/node-reference-parser-utils.ts
================================================
import cloneDeep from 'lodash/cloneDeep';
import escapeRegExp from 'lodash/escapeRegExp';
import isEqual from 'lodash/isEqual';
import mapValues from 'lodash/mapValues';

import { OperationalError } from './errors';
import type { INode, INodeParameters, NodeParameterValueType } from './interfaces';

class LazyRegExp {
	private regExp?: RegExp;

	constructor(
		private pattern: () => string,
		private flags?: string,
	) {}

	get(): RegExp {
		if (!this.regExp) this.regExp = new RegExp(this.pattern(), this.flags);

		return this.regExp;
	}
}

type ExpressionMapping = {
	nodeNameInExpression: null | string; // 'abc';
	originalExpression: string; // "$('abc').first().def.ghi";
	replacementPrefix: string; //  "$('Start').first()";
	replacementName: string; // "def_ghi";
};

type ParameterMapping<T> = undefined | T[] | { [key: PropertyKey]: ParameterMapping<T> };

type ParameterExtractMapping = ParameterMapping<ExpressionMapping>;

const DOT_REFERENCEABLE_JS_VARIABLE = /\w[\w\d_\$]*/;
const INVALID_JS_DOT_PATH = /[^\.\w\d_\$]/;
const INVALID_JS_DOT_NAME = /[^\w\d_\$]/;

// These are the keys that are followed by one of DATA_ACCESSORS
const ITEM_TO_DATA_ACCESSORS = [
	/^first\(\)/,
	/^last\(\)/,
	/^all\(\)/,
	// The order here is relevant because `item` would match occurrences of `itemMatching`
	/^itemMatching\(\d+\)/, // We only support trivial itemMatching arguments
	/^item/,
];

// These we safely can convert to a normal argument
const ITEM_ACCESSORS = ['params', 'isExecuted'];

const DATA_ACCESSORS = ['json', 'binary'];

export function hasDotNotationBannedChar(nodeName: string) {
	const DOT_NOTATION_BANNED_CHARS = /^(\d)|[\\ `!@#$%^&*()_+\-=[\]{};':"\\|,.<>?~]/g;

	return DOT_NOTATION_BANNED_CHARS.test(nodeName);
}

export function backslashEscape(nodeName: string) {
	const BACKSLASH_ESCAPABLE_CHARS = /[.*+?^${}()|[\]\\]/g;

	return nodeName.replace(BACKSLASH_ESCAPABLE_CHARS, (char) => `\\${char}`);
}

export function dollarEscape(nodeName: string) {
	return nodeName.replace(new RegExp('\\$', 'g'), '$$$$');
}

type AccessPattern = {
	checkPattern: string;
	replacePattern: (name: string) => string;
	customCallback?: (expression: string, newName: string, escapedNewName: string) => string;
};

const ACCESS_PATTERNS: AccessPattern[] = [
	{
		checkPattern: '$(',
		replacePattern: (s) => String.raw`(\$\(['"])${s}(['"]\))`,
	},
	{
		checkPattern: '$node[',
		replacePattern: (s) => String.raw`(\$node\[['"])${s}(['"]\])`,
	},
	{
		checkPattern: '$node.',
		replacePattern: (s) => String.raw`(\$node\.)${s}(\.?)`,
		customCallback: (expression: string, newName: string, escapedNewName: string) => {
			if (hasDotNotationBannedChar(newName)) {
				const regex = new RegExp(`.${backslashEscape(newName)}( |\\.)`, 'g');
				return expression.replace(regex, `["${escapedNewName}"]$1`);
			}
			return expression;
		},
	},
	{
		checkPattern: '$items(',
		replacePattern: (s) => String.raw`(\$items\(['"])${s}(['"],|['"]\))`,
	},
];

export function applyAccessPatterns(expression: string, previousName: string, newName: string) {
	// To not run the "expensive" regex stuff when it is not needed
	// make a simple check first if it really contains the node-name
	if (!expression.includes(previousName)) return expression;

	// Really contains node-name (even though we do not know yet if really as $node-expression)
	const escapedOldName = backslashEscape(previousName); // for match
	const escapedNewName = dollarEscape(newName); // for replacement

	for (const pattern of ACCESS_PATTERNS) {
		if (expression.includes(pattern.checkPattern)) {
			expression = expression.replace(
				new RegExp(pattern.replacePattern(escapedOldName), 'g'),
				`$1${escapedNewName}$2`,
			);

			if (pattern.customCallback) {
				expression = pattern.customCallback(expression, newName, escapedNewName);
			}
		}
	}
	return expression;
}

function convertToUniqueJsDotName(nodeName: string, allNodeNames: string[]) {
	let jsLegal = nodeName
		.replaceAll(' ', '_')
		.split('')
		.filter((x) => !INVALID_JS_DOT_NAME.test(x))
		.join('');

	if (nodeName === jsLegal) return jsLegal;

	// This accounts for theoretical cases where we collide with other reduced names
	// By adding our own index in the array we also avoid running into theoretical cases
	// where a node with the name 'ourName_27' exists for our reduced name 'ourName'
	// because we must have a different index, so therefore only one of us can be `ourName_27_27`
	//
	// The underscore prevents colliding e.g. index 1 with 11
	while (allNodeNames.includes(jsLegal)) jsLegal += `_${allNodeNames.indexOf(nodeName)}`;
	return jsLegal;
}

function convertDataAccessorName(name: string): string {
	const [fnName, maybeDigits] = name.split('(');
	switch (fnName.toLowerCase()) {
		case 'item':
			return fnName;
		case 'first':
		case 'last':
			return `${fnName}Item`;
		case 'all':
			return `${fnName}Items`;
	}

	// use the digits without the )
	return `${fnName}_${maybeDigits?.slice(0, -1) ?? 'unknown'}`;
}

function parseExpressionMapping(
	isolatedExpression: string,
	nodeNameInExpression: string | null,
	nodeNamePlainJs: string | null,
	startNodeName: string,
): ExpressionMapping | null {
	const splitExpr = isolatedExpression.split('.');

	// This supports literal . used in the node name
	const dotsInName = nodeNameInExpression?.split('').filter((x) => x === '.').length ?? 0;
	const dotInAccessorsOffset = isolatedExpression.startsWith('$node.') ? 1 : 0;
	const exprStart = splitExpr.slice(0, dotInAccessorsOffset + dotsInName + 1).join('.');
	const parts = splitExpr.slice(dotInAccessorsOffset + dotsInName + 1);

	// The calling code is expected to only handle $json expressions for the root node
	// As these are invalid conversions for inner nodes
	if (exprStart === '$json') {
		let partsIdx = 0;
		for (; partsIdx < parts.length; ++partsIdx) {
			if (!DOT_REFERENCEABLE_JS_VARIABLE.test(parts[partsIdx])) break;
		}
		return {
			nodeNameInExpression: null,
			originalExpression: `${exprStart}.${parts.slice(0, partsIdx + 1).join('.')}`, // $json.valid.until, but not ['x'] after
			replacementPrefix: `${exprStart}`, // $json
			replacementName: `${parts.slice(0, partsIdx).join('_')}`, // valid_until
		};
	}

	if (parts.length === 0) {
		// If a node is referenced by name without any accessor we return a proxy that stringifies as an empty object
		// But it can still be validly passed to other functions
		// However when passed to a sub-workflow it collapses into a true empty object
		// So lets just abort porting this and don't touch it
		return null;
	}
	// Handling `all()` is very awkward since we need to pass the value as a single parameter but
	// can't do `$('Start').all() since it would be a different node's all
	const accessorPrefix = parts[0] === 'all()' ? 'first()' : parts[0];

	if (ITEM_TO_DATA_ACCESSORS.some((x) => parts[0].match(x))) {
		if (parts.length === 1) {
			// this case is a literal use of the return value of `$('nodeName').first()`
			// Note that it's safe to rename to first, even if there is a variable of the same name
			// since we resolve duplicate names later in the process
			const originalName = parts[0];
			return {
				nodeNameInExpression,
				originalExpression: `${exprStart}.${parts[0]}`, // $('abc').first()
				replacementPrefix: `$('${startNodeName}').${accessorPrefix}.json`, //  $('Start').first().json
				replacementName: `${nodeNamePlainJs}_${convertDataAccessorName(originalName)}`, // nodeName_firstItem, nodeName_itemMatching_20
			};
		} else {
			if (DATA_ACCESSORS.some((x) => parts[1] === x)) {
				let partsIdx = 2;
				for (; partsIdx < parts.length; ++partsIdx) {
					if (!DOT_REFERENCEABLE_JS_VARIABLE.test(parts[partsIdx])) break;
				}
				// Use a separate name for anything except item to avoid users confusing their e.g. first() variables
				const replacementPostfix =
					parts[0] === 'item' ? '' : `_${convertDataAccessorName(parts[0])}`;
				return {
					nodeNameInExpression,
					originalExpression: `${exprStart}.${parts.slice(0, partsIdx + 1).join('.')}`, // $('abc').item.json.valid.until, but not ['x'] after
					replacementPrefix: `$('${startNodeName}').${accessorPrefix}.${parts[1]}`, // $('Start').item.json
					replacementName: parts.slice(2, partsIdx).join('_') + replacementPostfix, // valid_until, or valid_until_firstItem
				};
			} else {
				// this case covers any normal ObjectExtensions functions called on the ITEM_TO_DATA_ACCESSORS entry
				// e.g. $('nodeName').first().toJsonObject().randomJSFunction() or $('nodeName').all().map(x => ({...x, a: 3 }))
				return {
					nodeNameInExpression,
					originalExpression: `${exprStart}.${parts[0]}`, // $('abc').first()
					replacementPrefix: `$('${startNodeName}').${accessorPrefix}.json`, //  $('Start').first().json.
					replacementName: `${nodeNamePlainJs}_${convertDataAccessorName(parts[0])}`, // nodeName_firstItem
				};
			}
		}
	}

	// This covers specific metadata functions available on nodes
	const itemAccessorMatch = ITEM_ACCESSORS.flatMap((x) => (x === parts[0] ? x : []))[0];
	if (itemAccessorMatch !== undefined) {
		return {
			nodeNameInExpression,
			originalExpression: `${exprStart}.${parts[0]}`, // $('abc').isExecuted
			replacementPrefix: `$('${startNodeName}').first().json`, //  $('Start').first()
			replacementName: `${nodeNamePlainJs}_${parts[0]}`, // nodeName_isExecuted
		};
	}

	// If we end up here it means that:
	// - we have a complex `itemMatching(<expr>)` case, or
	// - the expression should be invalid, or
	// - a new function was added that we're not aware of.
	//
	// In these cases let's just not touch it and keep it as is
	return null;
}

// find `$('NodeName').item.json.path.to.x` in `{{ $('NodeName').item.json.path.to.x[someFunction()] }}`
function extractExpressionCandidate(expression: string, startIndex: number, endIndex: number) {
	const firstPartException = ITEM_TO_DATA_ACCESSORS.map((x) =>
		x.exec(expression.slice(endIndex)),
	).filter((x) => x !== null);

	// Note that by choosing match 0 we use `itemMatching` matches over `item`
	// matches by relying on the order in ITEM_TO_DATA_ACCESSORS
	let after_accessor_idx = endIndex + (firstPartException[0]?.[0].length ?? -1);
	// skip `.` to continue, but halt before other symbols like `[` in `all()[0]`
	if (expression[after_accessor_idx + 1] === '.') after_accessor_idx += 1;
	const after_accessor = expression.slice(after_accessor_idx);
	const firstInvalidCharMatch = INVALID_JS_DOT_PATH.exec(after_accessor);

	// we should at least find the }} closing the JS expressions in valid cases
	if (!firstInvalidCharMatch) return null;

	return expression.slice(startIndex, after_accessor_idx + firstInvalidCharMatch.index);
}

// Parse a given regex accessor match (e.g. `$('nodeName')`, `$node['nodeName']`)
// and extract a potential ExpressionMapping
function parseCandidateMatch(
	match: RegExpExecArray,
	expression: string,
	nodeNames: string[],
	startNodeName: string,
): ExpressionMapping | null {
	const startIndex = match.index;
	const endIndex = startIndex + match[0].length + 1;
	// this works because all access patterns define match groups
	// [fullMatch, "$('", "nodeName", "')"]
	const nodeNameInExpression = match[2];

	// This should be invalid in theory, since the regex matches should only act
	// on known node names
	if (!nodeNames.includes(nodeNameInExpression)) return null;

	const candidate = extractExpressionCandidate(expression, startIndex, endIndex);
	if (candidate === null) return null;

	return parseExpressionMapping(
		candidate,
		nodeNameInExpression,
		convertToUniqueJsDotName(nodeNameInExpression, nodeNames),
		startNodeName,
	);
}

// Handle matches of form `$json.path.to.value`, which is necessary for the selection input node
function parse$jsonMatch(match: RegExpExecArray, expression: string, startNodeName: string) {
	const candidate = extractExpressionCandidate(
		expression,
		match.index,
		match.index + match[0].length + 1,
	);
	if (candidate === null) return null;
	return parseExpressionMapping(candidate, null, null, startNodeName);
}

// Parse all references to other nodes in `expression` and return them as `ExpressionMappings`
function parseReferencingExpressions(
	expression: string,
	nodeRegexps: Array<readonly [string, LazyRegExp]>,
	nodeNames: string[],
	startNodeName: string,
	parse$json: boolean,
): ExpressionMapping[] {
	const result: ExpressionMapping[] = [];

	for (const [pattern, regexp] of nodeRegexps) {
		if (!expression.includes(pattern)) continue;

		const matches = [...expression.matchAll(regexp.get())];
		result.push(
			...matches
				.map((x) => parseCandidateMatch(x, expression, nodeNames, startNodeName))
				.filter((x) => x !== null),
		);
	}

	if (parse$json && expression.includes('$json')) {
		for (const match of expression.matchAll(/\$json/gi)) {
			const res = parse$jsonMatch(match, expression, startNodeName);
			if (res) result.push(res);
		}
	}
	return result;
}

// Recursively apply `mapper` to all expressions in `parameterValue`
function applyParameterMapping(
	parameterValue: NodeParameterValueType,
	mapper: (s: string) => ExpressionMapping[],
	keyOfValue?: string,
): [ParameterExtractMapping, ExpressionMapping[]] {
	const result: ParameterExtractMapping = {};

	if (typeof parameterValue !== 'object' || parameterValue === null) {
		if (
			typeof parameterValue === 'string' &&
			(parameterValue.charAt(0) === '=' || keyOfValue === 'jsCode')
		) {
			const mapping = mapper(parameterValue);
			return [mapping, mapping];
		}
		return [undefined, []];
	}

	const allMappings = [];
	for (const [key, value] of Object.entries(parameterValue)) {
		const [mapping, all] = applyParameterMapping(value as NodeParameterValueType, mapper, key);
		result[key] = mapping;
		allMappings.push(...all);
	}

	return [result, allMappings];
}

// Ensure all expressions have a unique variable name
function resolveDuplicates(data: ExpressionMapping[], allNodeNames: string[]) {
	// Map from candidate variableName to its expressionData
	const triggerArgumentMap = new Map<string, ExpressionMapping>();
	const originalExpressionMap = new Map<string, string>();

	for (const mapping of data) {
		const { nodeNameInExpression, originalExpression, replacementPrefix } = mapping;
		let { replacementName } = mapping;
		const hasKeyAndCollides = (key: string) => {
			const value = triggerArgumentMap.get(key);
			if (!value) return false;
			return !isEqual(value, mapping);
		};

		// We need both parts in the key as we may need to pass e.g. `.first()` and `.item` separately
		// Since we cannot pass the node itself as its proxy reduces it to an empty object
		const key = () => `${replacementPrefix}.${replacementName}`;

		// This covers a realistic case where two nodes have the same path, e.g.
		//    $('original input').item.json.path.to.url
		//    $('some time later in the workflow').item.json.path.to.url
		if (hasKeyAndCollides(key()) && nodeNameInExpression) {
			replacementName = `${convertToUniqueJsDotName(nodeNameInExpression, allNodeNames)}_${replacementName}`;
		}
		// This covers all other theoretical cases, like where `${nodeName}_${variable}` might clash with another variable name
		while (hasKeyAndCollides(key())) replacementName += '_1';

		triggerArgumentMap.set(key(), {
			originalExpression,
			nodeNameInExpression,
			replacementName,
			replacementPrefix,
		});
		originalExpressionMap.set(originalExpression, key());
	}

	return {
		triggerArgumentMap,
		originalExpressionMap,
	};
}

// Recursively loop through the nodeProperties and apply `parameterExtractMapping` where defined
function applyExtractMappingToNode(node: INode, parameterExtractMapping: ParameterExtractMapping) {
	const usedMappings: ExpressionMapping[] = [];

	const applyMapping = (
		parameters: NodeParameterValueType,
		mapping: ParameterExtractMapping,
	): NodeParameterValueType => {
		if (!mapping) return parameters;
		if (typeof parameters !== 'object' || parameters === null) {
			if (Array.isArray(mapping) && typeof parameters === 'string') {
				for (const mapper of mapping) {
					if (!parameters.includes(mapper.originalExpression)) continue;
					parameters = parameters.replaceAll(
						mapper.originalExpression,
						`${mapper.replacementPrefix}.${mapper.replacementName}`,
					);
					usedMappings.push(mapper);
				}
			}
			return parameters;
		}

		// This should be an invalid state, though an explicit check makes typings easier
		if (Array.isArray(mapping)) {
			return parameters;
		}

		if (Array.isArray(parameters) && typeof mapping === 'object' && !Array.isArray(mapping)) {
			return parameters.map((x, i) => applyMapping(x, mapping[i]) as INodeParameters);
		}

		return mapValues(parameters, (v, k) => applyMapping(v, mapping[k])) as NodeParameterValueType;
	};

	const parameters = applyMapping(node.parameters, parameterExtractMapping);

	return { result: { ...node, parameters } as INode, usedMappings };
}

// Recursively find the finalized mapping for provisional mappings
function applyCanonicalMapping(
	mapping: ParameterExtractMapping,
	getCanonicalData: (m: ExpressionMapping) => ExpressionMapping | undefined,
): ParameterExtractMapping {
	if (!mapping) return;
	if (Array.isArray(mapping)) {
		// Sort by longest so that we don't accidentally replace part of a longer expression
		return mapping
			.map(getCanonicalData)
			.filter((x) => x !== undefined)
			.sort((a, b) => b.originalExpression.length - a.originalExpression.length);
	}
	return mapValues(mapping, (v) => applyCanonicalMapping(v, getCanonicalData));
}

/**
 * Extracts references to nodes in `nodeNames` from the nodes in `subGraph`.
 *
 * @returns an object with two keys:
 * 		- nodes: Transformed copies of nodes in `subGraph`, ready for use in a sub-workflow
 *    - variables: A map from variable name in the sub-workflow to the replaced expression
 *
 * @throws if the startNodeName already exists in `nodeNames`
 * @throws if `nodeNames` does not include all node names in `subGraph`
 */
export function extractReferencesInNodeExpressions(
	subGraph: INode[],
	nodeNames: string[],
	insertedStartName: string,
	graphInputNodeNames?: string[],
) {
	////
	// STEP 1 - Validate input invariants
	////
	const subGraphNames = subGraph.map((x) => x.name);
	if (subGraphNames.includes(insertedStartName))
		throw new OperationalError(
			`StartNodeName ${insertedStartName} already exists in nodeNames: ${JSON.stringify(subGraphNames)}`,
		);

	if (subGraphNames.some((x) => !nodeNames.includes(x))) {
		throw new OperationalError(
			`extractReferencesInNodeExpressions called with node in subGraph ${JSON.stringify(subGraphNames)} whose name is not in provided 'nodeNames' list ${JSON.stringify(nodeNames)}.`,
		);
	}

	////
	// STEP 2 - Compile all candidate regexp patterns
	////

	// This looks scary for large workflows, but RegExp should support >1 million characters and
	// it's a very linear pattern.
	const namesRegexp = '(' + nodeNames.map(escapeRegExp).join('|') + ')';
	const nodeRegexps = ACCESS_PATTERNS.map(
		(pattern) =>
			[
				pattern.checkPattern,
				// avoid compiling the expensive regex for rare legacy ways of accessing nodes
				new LazyRegExp(() => pattern.replacePattern(namesRegexp), 'g'),
			] as const,
	);

	////
	// STEP 3 - Parse expressions used in parameters and build mappings
	////

	// This map is used to change the actual expressions once resolved
	// The value represents fields in the actual parameters object which require change
	const parameterTreeMappingByNode = new Map<string, ParameterExtractMapping>();
	// This is used to track all candidates for change, necessary for deduplication
	const allData = [];

	for (const node of subGraph) {
		const [parameterMapping, allMappings] = applyParameterMapping(node.parameters, (s) =>
			parseReferencingExpressions(
				s,
				nodeRegexps,
				nodeNames,
				insertedStartName,
				graphInputNodeNames?.includes(node.name) ?? false,
			),
		);
		parameterTreeMappingByNode.set(node.name, parameterMapping);
		allData.push(...allMappings);
	}

	////
	// STEP 4 - Filter out nodes in subGraph and handle name clashes
	////

	const subGraphNodeNames = new Set(subGraphNames);
	const dataFromOutsideSubgraph = allData.filter(
		// `nodeNameInExpression` being absent implies direct access via `$json` or `$binary`
		(x) => !x.nodeNameInExpression || !subGraphNodeNames.has(x.nodeNameInExpression),
	);
	const { originalExpressionMap, triggerArgumentMap } = resolveDuplicates(
		dataFromOutsideSubgraph,
		nodeNames,
	);

	////
	// STEP 5 - Apply canonical mappings to nodes and track created variables
	////

	// triggerArgumentMap[originalExpressionMap[originalExpression]] returns its canonical object
	// These should never be undefined at this stage
	const getCanonicalData = (e: ExpressionMapping) => {
		const key = originalExpressionMap.get(e.originalExpression);
		if (!key) return undefined;
		return triggerArgumentMap.get(key);
	};

	for (const [key, value] of parameterTreeMappingByNode.entries()) {
		parameterTreeMappingByNode.set(key, applyCanonicalMapping(value, getCanonicalData));
	}

	const allUsedMappings = [];
	const output = [];
	for (const node of subGraph) {
		const { result, usedMappings } = applyExtractMappingToNode(
			cloneDeep(node),
			parameterTreeMappingByNode.get(node.name),
		);
		allUsedMappings.push(...usedMappings);
		output.push(result);
	}

	const variables = new Map(allUsedMappings.map((m) => [m.replacementName, m.originalExpression]));
	return { nodes: output, variables };
}



================================================
FILE: packages/workflow/src/observable-object.ts
================================================
/* eslint-disable @typescript-eslint/no-unsafe-return */

import type { IDataObject, IObservableObject } from './interfaces';

interface IObservableOptions {
	ignoreEmptyOnFirstChild?: boolean;
}

export function create(
	target: IDataObject,
	parent?: IObservableObject,
	option?: IObservableOptions,
	depth?: number,
): IDataObject {
	// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
	depth = depth || 0;

	// Make all the children of target also observable

	for (const key in target) {
		if (typeof target[key] === 'object' && target[key] !== null) {
			target[key] = create(
				target[key] as IDataObject,
				// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
				(parent || target) as IObservableObject,
				option,
				depth + 1,
			);
		}
	}

	Object.defineProperty(target, '__dataChanged', {
		value: false,
		writable: true,
	});
	return new Proxy(target, {
		deleteProperty(target, name) {
			if (parent === undefined) {
				// If no parent is given mark current data as changed
				(target as IObservableObject).__dataChanged = true;
			} else {
				// If parent is given mark the parent data as changed
				parent.__dataChanged = true;
			}
			return Reflect.deleteProperty(target, name);
		},
		get(target, name, receiver) {
			return Reflect.get(target, name, receiver);
		},
		has(target, key) {
			return Reflect.has(target, key);
		},
		set(target, name, value) {
			if (parent === undefined) {
				// If no parent is given mark current data as changed
				if (
					option !== undefined &&
					option.ignoreEmptyOnFirstChild === true &&
					depth === 0 &&
					target[name.toString()] === undefined &&
					typeof value === 'object' &&
					// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
					Object.keys(value).length === 0
				) {
				} else {
					(target as IObservableObject).__dataChanged = true;
				}
			} else {
				// If parent is given mark the parent data as changed
				parent.__dataChanged = true;
			}
			return Reflect.set(target, name, value);
		},
	});
}



================================================
FILE: packages/workflow/src/result.ts
================================================
import { ensureError } from './errors';

export type ResultOk<T> = { ok: true; result: T };
export type ResultError<E> = { ok: false; error: E };
export type Result<T, E> = ResultOk<T> | ResultError<E>;

export const createResultOk = <T>(data: T): ResultOk<T> => ({
	ok: true,
	result: data,
});

export const createResultError = <E = unknown>(error: E): ResultError<E> => ({
	ok: false,
	error,
});

/**
 * Executes the given function and converts it to a Result object.
 *
 * @example
 * const result = toResult(() => fs.writeFileSync('file.txt', 'Hello, World!'));
 */
export const toResult = <T, E extends Error = Error>(fn: () => T): Result<T, E> => {
	try {
		return createResultOk<T>(fn());
	} catch (e) {
		const error = ensureError(e);
		return createResultError<E>(error as E);
	}
};



================================================
FILE: packages/workflow/src/telemetry-helpers.ts
================================================
import {
	AGENT_LANGCHAIN_NODE_TYPE,
	AGENT_TOOL_LANGCHAIN_NODE_TYPE,
	AI_TRANSFORM_NODE_TYPE,
	CHAIN_LLM_LANGCHAIN_NODE_TYPE,
	CHAIN_SUMMARIZATION_LANGCHAIN_NODE_TYPE,
	CHAT_TRIGGER_NODE_TYPE,
	CODE_NODE_TYPE,
	EVALUATION_NODE_TYPE,
	EVALUATION_TRIGGER_NODE_TYPE,
	EXECUTE_WORKFLOW_NODE_TYPE,
	FREE_AI_CREDITS_ERROR_TYPE,
	FREE_AI_CREDITS_USED_ALL_CREDITS_ERROR_CODE,
	FROM_AI_AUTO_GENERATED_MARKER,
	HTTP_REQUEST_NODE_TYPE,
	HTTP_REQUEST_TOOL_LANGCHAIN_NODE_TYPE,
	LANGCHAIN_CUSTOM_TOOLS,
	MERGE_NODE_TYPE,
	OPEN_AI_API_CREDENTIAL_TYPE,
	OPENAI_LANGCHAIN_NODE_TYPE,
	STICKY_NODE_TYPE,
	WEBHOOK_NODE_TYPE,
	WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE,
} from './constants';
import { ApplicationError } from '@n8n/errors';
import type { NodeApiError } from './errors/node-api.error';
import type {
	IConnection,
	INode,
	INodeNameIndex,
	INodesGraph,
	INodeGraphItem,
	INodesGraphResult,
	IWorkflowBase,
	INodeTypes,
	IDataObject,
	IRunData,
	ITaskData,
	IRun,
	INodeParameterResourceLocator,
} from './interfaces';
import { NodeConnectionTypes } from './interfaces';
import { getNodeParameters } from './node-helpers';
import { jsonParse } from './utils';
import { DEFAULT_EVALUATION_METRIC } from './evaluation-helpers';

const isNodeApiError = (error: unknown): error is NodeApiError =>
	typeof error === 'object' && error !== null && 'name' in error && error?.name === 'NodeApiError';

export function getNodeTypeForName(workflow: IWorkflowBase, nodeName: string): INode | undefined {
	return workflow.nodes.find((node) => node.name === nodeName);
}

export function isNumber(value: unknown): value is number {
	return typeof value === 'number';
}

const countPlaceholders = (text: string) => {
	const placeholder = /(\{[a-zA-Z0-9_]+\})/g;
	let returnData = 0;

	try {
		const matches = text.matchAll(placeholder);
		for (const _ of matches) returnData++;
	} catch (error) {}

	return returnData;
};

const countPlaceholdersInParameters = (parameters: IDataObject[]) => {
	let returnData = 0;

	for (const parameter of parameters) {
		if (!parameter.value) {
			//count parameters provided by model
			returnData++;
		} else {
			//check if any placeholders in user provided value
			returnData += countPlaceholders(String(parameter.value));
		}
	}

	return returnData;
};

type XYPosition = [number, number];

function areOverlapping(
	topLeft: XYPosition,
	bottomRight: XYPosition,
	targetPos: XYPosition,
): boolean {
	return (
		targetPos[0] > topLeft[0] &&
		targetPos[1] > topLeft[1] &&
		targetPos[0] < bottomRight[0] &&
		targetPos[1] < bottomRight[1]
	);
}

const URL_PARTS_REGEX = /(?<protocolPlusDomain>.*?\..*?)(?<pathname>\/.*)/;

export function getDomainBase(raw: string, urlParts = URL_PARTS_REGEX): string {
	try {
		const url = new URL(raw);

		return [url.protocol, url.hostname].join('//');
	} catch {
		const match = urlParts.exec(raw);

		if (!match?.groups?.protocolPlusDomain) return '';

		return match.groups.protocolPlusDomain;
	}
}

function isSensitive(segment: string) {
	if (/^v\d+$/.test(segment)) return false;

	return /%40/.test(segment) || /\d/.test(segment) || /^[0-9A-F]{8}/i.test(segment);
}

export const ANONYMIZATION_CHARACTER = '*';

function sanitizeRoute(raw: string, check = isSensitive, char = ANONYMIZATION_CHARACTER) {
	return raw
		.split('/')
		.map((segment) => (check(segment) ? char.repeat(segment.length) : segment))
		.join('/');
}

/**
 * Return pathname plus query string from URL, anonymizing IDs in route and query params.
 */
export function getDomainPath(raw: string, urlParts = URL_PARTS_REGEX): string {
	try {
		const url = new URL(raw);

		if (!url.hostname) throw new ApplicationError('Malformed URL');

		return sanitizeRoute(url.pathname);
	} catch {
		const match = urlParts.exec(raw);

		if (!match?.groups?.pathname) return '';

		// discard query string
		const route = match.groups.pathname.split('?').shift() as string;

		return sanitizeRoute(route);
	}
}

function getNumberOfItemsInRuns(runs: ITaskData[]): number {
	return runs.reduce((total, run) => {
		const data = run.data ?? {};
		let count = 0;
		Object.keys(data).forEach((type) => {
			const conn = data[type] ?? [];
			conn.forEach((branch) => {
				count += (branch ?? []).length;
			});
		});

		return total + count;
	}, 0);
}

export function generateNodesGraph(
	workflow: Partial<IWorkflowBase>,
	nodeTypes: INodeTypes,
	options?: {
		sourceInstanceId?: string;
		nodeIdMap?: { [curr: string]: string };
		isCloudDeployment?: boolean;
		runData?: IRunData;
	},
): INodesGraphResult {
	const { runData } = options ?? {};
	const nodeGraph: INodesGraph = {
		node_types: [],
		node_connections: [],
		nodes: {},
		notes: {},
		is_pinned: Object.keys(workflow.pinData ?? {}).length > 0,
	};
	const nameIndices: INodeNameIndex = {};
	const webhookNodeNames: string[] = [];
	const evaluationTriggerNodeNames: string[] = [];

	const nodes = (workflow.nodes ?? []).filter((node) => node.type === STICKY_NODE_TYPE);
	const otherNodes = (workflow.nodes ?? []).filter((node) => node.type !== STICKY_NODE_TYPE);

	nodes.forEach((stickyNote: INode, index: number) => {
		const stickyType = nodeTypes.getByNameAndVersion(STICKY_NODE_TYPE, stickyNote.typeVersion);
		if (!stickyType) {
			return;
		}

		let nodeParameters: IDataObject = {};

		try {
			nodeParameters =
				getNodeParameters(
					stickyType.description.properties,
					stickyNote.parameters,
					true,
					false,
					stickyNote,
					stickyType.description,
				) ?? {};
		} catch {
			// prevent node param resolution from failing graph generation
		}

		const height: number = typeof nodeParameters.height === 'number' ? nodeParameters.height : 0;
		const width: number = typeof nodeParameters.width === 'number' ? nodeParameters.width : 0;

		const topLeft = stickyNote.position;
		const bottomRight: [number, number] = [topLeft[0] + width, topLeft[1] + height];
		const overlapping = Boolean(
			otherNodes.find((node) => areOverlapping(topLeft, bottomRight, node.position)),
		);
		nodeGraph.notes[index] = {
			overlapping,
			position: topLeft,
			height,
			width,
		};
	});

	// eslint-disable-next-line complexity
	otherNodes.forEach((node: INode, index: number) => {
		nodeGraph.node_types.push(node.type);
		const nodeItem: INodeGraphItem = {
			id: node.id,
			type: node.type,
			version: node.typeVersion,
			position: node.position,
		};

		if (runData?.[node.name]) {
			const runs = runData[node.name] ?? [];
			nodeItem.runs = runs.length;

			nodeItem.items_total = getNumberOfItemsInRuns(runs);
		}

		if (options?.sourceInstanceId) {
			nodeItem.src_instance_id = options.sourceInstanceId;
		}

		if (node.id && options?.nodeIdMap?.[node.id]) {
			nodeItem.src_node_id = options.nodeIdMap[node.id];
		}

		if (node.type === AI_TRANSFORM_NODE_TYPE && options?.isCloudDeployment) {
			nodeItem.prompts = { instructions: node.parameters.instructions as string };
		} else if (node.type === AGENT_LANGCHAIN_NODE_TYPE) {
			nodeItem.agent = (node.parameters.agent as string) ?? 'toolsAgent';

			if (node.typeVersion >= 2.1) {
				const options = node.parameters?.options;
				if (
					typeof options === 'object' &&
					options &&
					'enableStreaming' in options &&
					options.enableStreaming === false
				) {
					nodeItem.is_streaming = false;
				} else {
					nodeItem.is_streaming = true;
				}
			}
		} else if (node.type === MERGE_NODE_TYPE) {
			nodeItem.operation = node.parameters.mode as string;

			if (options?.isCloudDeployment && node.parameters.mode === 'combineBySql') {
				nodeItem.sql = node.parameters.query as string;
			}
		} else if (node.type === HTTP_REQUEST_NODE_TYPE && node.typeVersion === 1) {
			try {
				nodeItem.domain = new URL(node.parameters.url as string).hostname;
			} catch {
				nodeItem.domain = getDomainBase(node.parameters.url as string);
			}
		} else if (node.type === HTTP_REQUEST_NODE_TYPE && node.typeVersion > 1) {
			const { authentication } = node.parameters as { authentication: string };

			nodeItem.credential_type = {
				none: 'none',
				genericCredentialType: node.parameters.genericAuthType as string,
				predefinedCredentialType: node.parameters.nodeCredentialType as string,
			}[authentication];

			nodeItem.credential_set = node.credentials ? Object.keys(node.credentials).length > 0 : false;

			const { url } = node.parameters as { url: string };

			nodeItem.domain_base = getDomainBase(url);
			nodeItem.domain_path = getDomainPath(url);
			nodeItem.method = node.parameters.requestMethod as string;
		} else if (HTTP_REQUEST_TOOL_LANGCHAIN_NODE_TYPE === node.type) {
			if (!nodeItem.toolSettings) nodeItem.toolSettings = {};

			nodeItem.toolSettings.url_type = 'other';
			nodeItem.toolSettings.uses_auth = false;
			nodeItem.toolSettings.placeholders = 0;
			nodeItem.toolSettings.query_from_model_only = false;
			nodeItem.toolSettings.headers_from_model_only = false;
			nodeItem.toolSettings.body_from_model_only = false;

			const toolUrl = (node.parameters?.url as string) ?? '';
			nodeItem.toolSettings.placeholders += countPlaceholders(toolUrl);

			const authType = (node.parameters?.authentication as string) ?? '';

			if (authType && authType !== 'none') {
				nodeItem.toolSettings.uses_auth = true;
			}

			if (toolUrl.startsWith('{') && toolUrl.endsWith('}')) {
				nodeItem.toolSettings.url_type = 'any';
			} else if (toolUrl.includes('google.com')) {
				nodeItem.toolSettings.url_type = 'google';
			}

			if (node.parameters?.sendBody) {
				if (node.parameters?.specifyBody === 'model') {
					nodeItem.toolSettings.body_from_model_only = true;
				}

				if (node.parameters?.jsonBody) {
					nodeItem.toolSettings.placeholders += countPlaceholders(
						node.parameters?.jsonBody as string,
					);
				}

				if (node.parameters?.parametersBody) {
					const parameters = (node.parameters?.parametersBody as IDataObject)
						.values as IDataObject[];

					nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
				}
			}

			if (node.parameters?.sendHeaders) {
				if (node.parameters?.specifyHeaders === 'model') {
					nodeItem.toolSettings.headers_from_model_only = true;
				}

				if (node.parameters?.jsonHeaders) {
					nodeItem.toolSettings.placeholders += countPlaceholders(
						node.parameters?.jsonHeaders as string,
					);
				}

				if (node.parameters?.parametersHeaders) {
					const parameters = (node.parameters?.parametersHeaders as IDataObject)
						.values as IDataObject[];

					nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
				}
			}

			if (node.parameters?.sendQuery) {
				if (node.parameters?.specifyQuery === 'model') {
					nodeItem.toolSettings.query_from_model_only = true;
				}

				if (node.parameters?.jsonQuery) {
					nodeItem.toolSettings.placeholders += countPlaceholders(
						node.parameters?.jsonQuery as string,
					);
				}

				if (node.parameters?.parametersQuery) {
					const parameters = (node.parameters?.parametersQuery as IDataObject)
						.values as IDataObject[];

					nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
				}
			}
		} else if (node.type === WEBHOOK_NODE_TYPE) {
			webhookNodeNames.push(node.name);
			const responseMode = node.parameters?.responseMode;
			nodeItem.response_mode = typeof responseMode === 'string' ? responseMode : 'onReceived';
		} else if (node.type === CHAT_TRIGGER_NODE_TYPE) {
			// Capture streaming response mode parameter
			const options = node.parameters?.options;
			if (
				typeof options === 'object' &&
				options &&
				'responseMode' in options &&
				typeof options.responseMode === 'string'
			) {
				nodeItem.response_mode = options.responseMode;
			}
			// Capture public chat setting
			const isPublic = node.parameters?.public;
			if (typeof isPublic === 'boolean') {
				nodeItem.public_chat = isPublic;
			}
		} else if (
			node.type === EXECUTE_WORKFLOW_NODE_TYPE ||
			node.type === WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE
		) {
			if (node.parameters?.workflowId) {
				nodeItem.workflow_id = node.parameters?.workflowId as string;
			}
		} else if (node.type === EVALUATION_TRIGGER_NODE_TYPE) {
			evaluationTriggerNodeNames.push(node.name);
		} else if (
			node.type === EVALUATION_NODE_TYPE &&
			options?.isCloudDeployment &&
			node.parameters?.operation === 'setMetrics'
		) {
			const metrics = node.parameters?.metrics as IDataObject | undefined;

			// If metrics are not defined, it means the node is using preconfigured metric
			if (!metrics) {
				const predefinedMetricKey =
					(node.parameters?.metric as string | undefined) ?? DEFAULT_EVALUATION_METRIC;
				nodeItem.metric_names = [predefinedMetricKey];
			} else {
				nodeItem.metric_names = (metrics.assignments as Array<{ name: string }> | undefined)?.map(
					(metric: { name: string }) => metric.name,
				);
			}
		} else if (node.type === CODE_NODE_TYPE) {
			const { language } = node.parameters;
			nodeItem.language =
				language === undefined ? 'javascript' : language === 'python' ? 'python' : 'unknown';
		} else {
			try {
				const nodeType = nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
				if (nodeType) {
					const nodeParameters = getNodeParameters(
						nodeType.description.properties,
						node.parameters,
						true,
						false,
						node,
						nodeType.description,
					);

					if (nodeParameters) {
						const keys: Array<'operation' | 'resource' | 'mode'> = [
							'operation',
							'resource',
							'mode',
						];
						keys.forEach((key) => {
							if (nodeParameters.hasOwnProperty(key)) {
								nodeItem[key] = nodeParameters[key]?.toString();
							}
						});
					}
				}
			} catch (e: unknown) {
				if (
					!(
						e instanceof Error &&
						typeof e.message === 'string' &&
						e.message.includes('Unrecognized node type')
					)
				) {
					throw e;
				}
			}
		}

		if (options?.isCloudDeployment === true) {
			if (node.type === OPENAI_LANGCHAIN_NODE_TYPE) {
				nodeItem.prompts =
					(((node.parameters?.messages as IDataObject) ?? {}).values as IDataObject[]) ?? [];
			}

			if (node.type === AGENT_LANGCHAIN_NODE_TYPE || node.type === AGENT_TOOL_LANGCHAIN_NODE_TYPE) {
				const prompts: IDataObject = {};

				if (node.parameters?.text) {
					prompts.text = node.parameters.text as string;
				}
				const nodeOptions = node.parameters?.options as IDataObject;

				if (nodeOptions) {
					const optionalMessagesKeys = [
						'humanMessage',
						'systemMessage',
						'humanMessageTemplate',
						'prefix',
						'suffixChat',
						'suffix',
						'prefixPrompt',
						'suffixPrompt',
					];

					for (const key of optionalMessagesKeys) {
						if (nodeOptions[key]) {
							prompts[key] = nodeOptions[key] as string;
						}
					}
				}

				if (Object.keys(prompts).length) {
					nodeItem.prompts = prompts;
				}
			}

			if (node.type === CHAIN_SUMMARIZATION_LANGCHAIN_NODE_TYPE) {
				nodeItem.prompts = (
					(((node.parameters?.options as IDataObject) ?? {})
						.summarizationMethodAndPrompts as IDataObject) ?? {}
				).values as IDataObject;
			}

			if (LANGCHAIN_CUSTOM_TOOLS.includes(node.type)) {
				nodeItem.prompts = {
					description: (node.parameters?.description as string) ?? '',
				};
			}

			if (node.type === CHAIN_LLM_LANGCHAIN_NODE_TYPE) {
				nodeItem.prompts =
					(((node.parameters?.messages as IDataObject) ?? {}).messageValues as IDataObject[]) ?? [];
			}

			if (node.type === MERGE_NODE_TYPE && node.parameters?.operation === 'combineBySql') {
				nodeItem.sql = node.parameters?.query as string;
			}
		}

		nodeGraph.nodes[index.toString()] = nodeItem;
		nameIndices[node.name] = index.toString();
	});

	const getGraphConnectionItem = (startNode: string, connectionItem: IConnection) => {
		return { start: nameIndices[startNode], end: nameIndices[connectionItem.node] };
	};

	Object.keys(workflow.connections ?? []).forEach((nodeName) => {
		const connections = workflow.connections?.[nodeName];
		if (!connections) {
			return;
		}

		Object.keys(connections).forEach((key) => {
			connections[key].forEach((element) => {
				(element ?? []).forEach((element2) => {
					nodeGraph.node_connections.push(getGraphConnectionItem(nodeName, element2));
				});
			});
		});
	});

	return { nodeGraph, nameIndices, webhookNodeNames, evaluationTriggerNodeNames };
}

export function extractLastExecutedNodeCredentialData(
	runData: IRun,
): null | { credentialId: string; credentialType: string } {
	const nodeCredentials = runData?.data?.executionData?.nodeExecutionStack?.[0]?.node?.credentials;

	if (!nodeCredentials) return null;

	const credentialType = Object.keys(nodeCredentials)[0] ?? null;

	if (!credentialType) return null;

	const { id } = nodeCredentials[credentialType];

	if (!id) return null;

	return { credentialId: id, credentialType };
}

export const userInInstanceRanOutOfFreeAiCredits = (runData: IRun): boolean => {
	const credentials = extractLastExecutedNodeCredentialData(runData);

	if (!credentials) return false;

	if (credentials.credentialType !== OPEN_AI_API_CREDENTIAL_TYPE) return false;

	const { error } = runData.data.resultData;

	if (!isNodeApiError(error) || !error.messages[0]) return false;

	const rawErrorResponse = error.messages[0].replace(`${error.httpCode} -`, '');

	try {
		const errorResponse = jsonParse<{ error: { code: number; type: string } }>(rawErrorResponse);
		if (
			errorResponse?.error?.type === FREE_AI_CREDITS_ERROR_TYPE &&
			errorResponse.error.code === FREE_AI_CREDITS_USED_ALL_CREDITS_ERROR_CODE
		) {
			return true;
		}
	} catch {
		return false;
	}

	return false;
};

export type FromAICount = {
	aiNodeCount: number;
	aiToolCount: number;
	fromAIOverrideCount: number;
	fromAIExpressionCount: number;
};

export function resolveAIMetrics(nodes: INode[], nodeTypes: INodeTypes): FromAICount | {} {
	const resolvedNodes = nodes
		.map((x) => [x, nodeTypes.getByNameAndVersion(x.type, x.typeVersion)] as const)
		.filter((x) => !!x[1]?.description);

	const aiNodeCount = resolvedNodes.reduce(
		(acc, x) => acc + Number(x[1].description.codex?.categories?.includes('AI')),
		0,
	);

	if (aiNodeCount === 0) return {};

	let fromAIOverrideCount = 0;
	let fromAIExpressionCount = 0;

	const tools = resolvedNodes.filter((node) =>
		node[1].description.codex?.subcategories?.AI?.includes('Tools'),
	);

	for (const [node, _] of tools) {
		// FlatMap to support values in resourceLocators
		const values = Object.values(node.parameters).flatMap((param) => {
			if (param && typeof param === 'object' && 'value' in param) param = param.value;
			return typeof param === 'string' ? param : [];
		});

		// Note that we don't match the i in `fromAI` to support lower case i (though we miss fromai)
		const overrides = values.reduce(
			(acc, value) => acc + Number(value.startsWith(`={{ ${FROM_AI_AUTO_GENERATED_MARKER} $fromA`)),
			0,
		);

		fromAIOverrideCount += overrides;
		// check for = to avoid scanning lengthy text fields
		// this will re-count overrides
		fromAIExpressionCount +=
			values.reduce(
				(acc, value) => acc + Number(value[0] === '=' && value.includes('$fromA', 2)),
				0,
			) - overrides;
	}

	return {
		aiNodeCount,
		aiToolCount: tools.length,
		fromAIOverrideCount,
		fromAIExpressionCount,
	};
}

export type VectorStoreMetrics = {
	insertedIntoVectorStore: boolean;
	queriedDataFromVectorStore: boolean;
};

export function resolveVectorStoreMetrics(
	nodes: INode[],
	nodeTypes: INodeTypes,
	run: IRun,
): VectorStoreMetrics | {} {
	const resolvedNodes = nodes
		.map((x) => [x, nodeTypes.getByNameAndVersion(x.type, x.typeVersion)] as const)
		.filter((x) => !!x[1]?.description);

	const vectorStores = resolvedNodes.filter(
		(x) =>
			x[1].description.codex?.categories?.includes('AI') &&
			x[1].description.codex?.subcategories?.AI?.includes('Vector Stores'),
	);

	if (vectorStores.length === 0) return {};

	const runData = run?.data?.resultData?.runData;
	const succeededVectorStores = vectorStores.filter((x) =>
		runData?.[x[0].name]?.some((execution) => execution.executionStatus === 'success'),
	);

	const insertingVectorStores = succeededVectorStores.filter(
		(x) => x[0].parameters?.mode === 'insert',
	);
	const retrievingVectorStores = succeededVectorStores.filter((x) =>
		['retrieve-as-tool', 'retrieve', 'load'].find((y) => y === x[0].parameters?.mode),
	);

	return {
		insertedIntoVectorStore: insertingVectorStores.length > 0,
		queriedDataFromVectorStore: retrievingVectorStores.length > 0,
	};
}

type AgentNodeStructuredOutputErrorInfo = {
	output_parser_fail_reason?: string;
	model_name?: string;
	num_tools?: number;
};

/**
 * Extract additional debug information if the last executed node was an agent node
 */
export function extractLastExecutedNodeStructuredOutputErrorInfo(
	workflow: IWorkflowBase,
	nodeTypes: INodeTypes,
	runData: IRun,
): AgentNodeStructuredOutputErrorInfo {
	const info: AgentNodeStructuredOutputErrorInfo = {};

	if (runData?.data.resultData.error && runData.data.resultData.lastNodeExecuted) {
		const lastNode = getNodeTypeForName(workflow, runData.data.resultData.lastNodeExecuted);

		if (lastNode !== undefined) {
			if (lastNode.type === AGENT_LANGCHAIN_NODE_TYPE && lastNode.parameters.hasOutputParser) {
				// Add additional debug info for agent node structured output errors
				const agentOutputError = runData.data.resultData.runData[lastNode.name]?.[0]?.error;
				if (
					agentOutputError &&
					agentOutputError.message === "Model output doesn't fit required format"
				) {
					info.output_parser_fail_reason = agentOutputError.context
						?.outputParserFailReason as string;
				}

				if (workflow.connections) {
					// Count connected tools
					info.num_tools =
						Object.keys(workflow.connections).filter((node) =>
							workflow.connections[node]?.[NodeConnectionTypes.AiTool]?.[0]?.some(
								(connectedNode) => connectedNode.node === lastNode.name,
							),
						)?.length ?? 0;

					// Extract model name from the language model node if connected
					const languageModelNodeName = Object.keys(workflow.connections).find((node) =>
						workflow.connections[node]?.[NodeConnectionTypes.AiLanguageModel]?.[0]?.some(
							(connectedNode) => connectedNode.node === lastNode.name,
						),
					);
					if (languageModelNodeName) {
						const languageModelNode = getNodeTypeForName(workflow, languageModelNodeName);
						if (languageModelNode) {
							const nodeType = nodeTypes.getByNameAndVersion(
								languageModelNode.type,
								languageModelNode.typeVersion,
							);

							if (nodeType) {
								const nodeParameters = getNodeParameters(
									nodeType.description.properties,
									languageModelNode.parameters,
									true,
									false,
									languageModelNode,
									nodeType.description,
								);

								const modelNameKeys = ['model', 'modelName'] as const;
								for (const key of modelNameKeys) {
									if (nodeParameters?.[key]) {
										info.model_name =
											typeof nodeParameters[key] === 'string'
												? nodeParameters[key]
												: ((nodeParameters[key] as INodeParameterResourceLocator).value as string);

										if (info.model_name) {
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return info;
}



================================================
FILE: packages/workflow/src/tool-helpers.ts
================================================
import type { INode } from './interfaces';

/**
 * Converts a node name to a valid tool name by replacing special characters with underscores
 * and collapsing consecutive underscores into a single one.
 */
export function nodeNameToToolName(nodeOrName: INode | string): string {
	const name = typeof nodeOrName === 'string' ? nodeOrName : nodeOrName.name;
	return name.replace(/[^a-zA-Z0-9_-]+/g, '_');
}



================================================
FILE: packages/workflow/src/type-guards.ts
================================================
import type {
	INodeProperties,
	INodePropertyOptions,
	INodePropertyCollection,
	INodeParameterResourceLocator,
	ResourceMapperValue,
	FilterValue,
} from './interfaces';

export function isResourceLocatorValue(value: unknown): value is INodeParameterResourceLocator {
	return Boolean(
		typeof value === 'object' && value && 'mode' in value && 'value' in value && '__rl' in value,
	);
}

export const isINodeProperties = (
	item: INodePropertyOptions | INodeProperties | INodePropertyCollection,
): item is INodeProperties => 'name' in item && 'type' in item && !('value' in item);

export const isINodePropertyOptions = (
	item: INodePropertyOptions | INodeProperties | INodePropertyCollection,
): item is INodePropertyOptions => 'value' in item && 'name' in item && !('displayName' in item);

export const isINodePropertyCollection = (
	item: INodePropertyOptions | INodeProperties | INodePropertyCollection,
): item is INodePropertyCollection => 'values' in item && 'name' in item && 'displayName' in item;

export const isINodePropertiesList = (
	items: INodeProperties['options'],
): items is INodeProperties[] => Array.isArray(items) && items.every(isINodeProperties);

export const isINodePropertyOptionsList = (
	items: INodeProperties['options'],
): items is INodePropertyOptions[] => Array.isArray(items) && items.every(isINodePropertyOptions);

export const isINodePropertyCollectionList = (
	items: INodeProperties['options'],
): items is INodePropertyCollection[] => {
	return Array.isArray(items) && items.every(isINodePropertyCollection);
};

export const isValidResourceLocatorParameterValue = (
	value: INodeParameterResourceLocator,
): boolean => {
	if (typeof value === 'object') {
		if (typeof value.value === 'number') {
			return true; // Accept all numbers
		}
		return !!value.value;
	} else {
		return !!value;
	}
};

export const isResourceMapperValue = (value: unknown): value is ResourceMapperValue => {
	return (
		typeof value === 'object' &&
		value !== null &&
		'mappingMode' in value &&
		'schema' in value &&
		'value' in value
	);
};

export const isFilterValue = (value: unknown): value is FilterValue => {
	return (
		typeof value === 'object' && value !== null && 'conditions' in value && 'combinator' in value
	);
};



================================================
FILE: packages/workflow/src/type-validation.ts
================================================
import isObject from 'lodash/isObject';
import { DateTime } from 'luxon';

import { ApplicationError } from './errors';
import type {
	FieldType,
	FormFieldsParameter,
	INodePropertyOptions,
	ValidationResult,
} from './interfaces';
import { jsonParse } from './utils';

export const tryToParseNumber = (value: unknown): number => {
	const isValidNumber = !isNaN(Number(value));

	if (!isValidNumber) {
		throw new ApplicationError('Failed to parse value to number', { extra: { value } });
	}
	return Number(value);
};

export const tryToParseString = (value: unknown): string => {
	if (typeof value === 'object') return JSON.stringify(value);
	if (typeof value === 'undefined') return '';
	if (
		typeof value === 'string' ||
		typeof value === 'bigint' ||
		typeof value === 'boolean' ||
		typeof value === 'number'
	) {
		return value.toString();
	}

	return String(value);
};
export const tryToParseAlphanumericString = (value: unknown): string => {
	const parsed = tryToParseString(value);
	// We do not allow special characters, only letters, numbers and underscore
	// Numbers not allowed as the first character
	const regex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
	if (!regex.test(parsed)) {
		throw new ApplicationError('Value is not a valid alphanumeric string', { extra: { value } });
	}
	return parsed;
};
export const tryToParseBoolean = (value: unknown): value is boolean => {
	if (typeof value === 'boolean') {
		return value;
	}

	if (typeof value === 'string' && ['true', 'false'].includes(value.toLowerCase())) {
		return value.toLowerCase() === 'true';
	}

	// If value is not a empty string, try to parse it to a number
	if (!(typeof value === 'string' && value.trim() === '')) {
		const num = Number(value);
		if (num === 0) {
			return false;
		} else if (num === 1) {
			return true;
		}
	}

	throw new ApplicationError('Failed to parse value as boolean', {
		extra: { value },
	});
};

export const tryToParseDateTime = (value: unknown, defaultZone?: string): DateTime => {
	if (DateTime.isDateTime(value) && value.isValid) {
		// Ignore the defaultZone if the value is already a DateTime
		// because DateTime objects already contain the zone information
		return value;
	}

	if (value instanceof Date) {
		const fromJSDate = DateTime.fromJSDate(value, { zone: defaultZone });
		if (fromJSDate.isValid) {
			return fromJSDate;
		}
	}

	const dateString = String(value).trim();

	// Rely on luxon to parse different date formats
	const isoDate = DateTime.fromISO(dateString, { zone: defaultZone, setZone: true });
	if (isoDate.isValid) {
		return isoDate;
	}
	const httpDate = DateTime.fromHTTP(dateString, { zone: defaultZone, setZone: true });
	if (httpDate.isValid) {
		return httpDate;
	}
	const rfc2822Date = DateTime.fromRFC2822(dateString, { zone: defaultZone, setZone: true });
	if (rfc2822Date.isValid) {
		return rfc2822Date;
	}
	const sqlDate = DateTime.fromSQL(dateString, { zone: defaultZone, setZone: true });
	if (sqlDate.isValid) {
		return sqlDate;
	}

	const parsedDateTime = DateTime.fromMillis(Date.parse(dateString), { zone: defaultZone });
	if (parsedDateTime.isValid) {
		return parsedDateTime;
	}

	throw new ApplicationError('Value is not a valid date', { extra: { dateString } });
};

export const tryToParseTime = (value: unknown): string => {
	const isTimeInput = /^\d{2}:\d{2}(:\d{2})?((\-|\+)\d{4})?((\-|\+)\d{1,2}(:\d{2})?)?$/s.test(
		String(value),
	);
	if (!isTimeInput) {
		throw new ApplicationError('Value is not a valid time', { extra: { value } });
	}
	return String(value);
};

export const tryToParseArray = (value: unknown): unknown[] => {
	try {
		if (typeof value === 'object' && Array.isArray(value)) {
			return value;
		}

		let parsed: unknown[];
		try {
			parsed = JSON.parse(String(value)) as unknown[];
		} catch (e) {
			parsed = JSON.parse(String(value).replace(/'/g, '"')) as unknown[];
		}

		if (!Array.isArray(parsed)) {
			throw new ApplicationError('Value is not a valid array', { extra: { value } });
		}
		return parsed;
	} catch (e) {
		throw new ApplicationError('Value is not a valid array', { extra: { value } });
	}
};

export const tryToParseObject = (value: unknown): object => {
	if (value && typeof value === 'object' && !Array.isArray(value)) {
		return value;
	}
	try {
		const o = jsonParse<object>(String(value), { acceptJSObject: true });

		if (typeof o !== 'object' || Array.isArray(o)) {
			throw new ApplicationError('Value is not a valid object', { extra: { value } });
		}
		return o;
	} catch (e) {
		throw new ApplicationError('Value is not a valid object', { extra: { value } });
	}
};

const ALLOWED_FORM_FIELDS_KEYS = [
	'fieldLabel',
	'fieldType',
	'placeholder',
	'fieldOptions',
	'multiselect',
	'multipleFiles',
	'acceptFileTypes',
	'formatDate',
	'requiredField',
];

const ALLOWED_FIELD_TYPES = [
	'date',
	'dropdown',
	'email',
	'file',
	'number',
	'password',
	'text',
	'textarea',
];

export const tryToParseJsonToFormFields = (value: unknown): FormFieldsParameter => {
	const fields: FormFieldsParameter = [];

	try {
		const rawFields = jsonParse<Array<{ [key: string]: unknown }>>(value as string, {
			acceptJSObject: true,
		});

		for (const [index, field] of rawFields.entries()) {
			for (const key of Object.keys(field)) {
				if (!ALLOWED_FORM_FIELDS_KEYS.includes(key)) {
					throw new ApplicationError(`Key '${key}' in field ${index} is not valid for form fields`);
				}
				if (
					key !== 'fieldOptions' &&
					!['string', 'number', 'boolean'].includes(typeof field[key])
				) {
					field[key] = String(field[key]);
				} else if (typeof field[key] === 'string') {
					field[key] = field[key].replace(/</g, '&lt;').replace(/>/g, '&gt;');
				}

				if (key === 'fieldType' && !ALLOWED_FIELD_TYPES.includes(field[key] as string)) {
					throw new ApplicationError(
						`Field type '${field[key] as string}' in field ${index} is not valid for form fields`,
					);
				}

				if (key === 'fieldOptions') {
					if (Array.isArray(field[key])) {
						field[key] = { values: field[key] };
					}

					if (
						typeof field[key] !== 'object' ||
						!(field[key] as { [key: string]: unknown }).values
					) {
						throw new ApplicationError(
							`Field dropdown in field ${index} does has no 'values' property that contain an array of options`,
						);
					}

					for (const [optionIndex, option] of (
						(field[key] as { [key: string]: unknown }).values as Array<{
							[key: string]: { option: string };
						}>
					).entries()) {
						if (Object.keys(option).length !== 1 || typeof option.option !== 'string') {
							throw new ApplicationError(
								`Field dropdown in field ${index} has an invalid option ${optionIndex}`,
							);
						}
					}
				}
			}

			fields.push(field as FormFieldsParameter[number]);
		}
	} catch (error) {
		if (error instanceof ApplicationError) throw error;

		throw new ApplicationError('Value is not valid JSON');
	}

	return fields;
};

export const getValueDescription = <T>(value: T): string => {
	if (typeof value === 'object') {
		if (value === null) return "'null'";
		if (Array.isArray(value)) return 'array';
		return 'object';
	}

	return `'${String(value)}'`;
};

export const tryToParseUrl = (value: unknown): string => {
	if (typeof value === 'string' && !value.includes('://')) {
		value = `http://${value}`;
	}
	const urlPattern = /^(https?|ftp|file):\/\/\S+|www\.\S+/;
	if (!urlPattern.test(String(value))) {
		throw new ApplicationError(`The value "${String(value)}" is not a valid url.`, {
			extra: { value },
		});
	}
	return String(value);
};

export const tryToParseJwt = (value: unknown): string => {
	const error = new ApplicationError(`The value "${String(value)}" is not a valid JWT token.`, {
		extra: { value },
	});

	if (!value) throw error;

	const jwtPattern = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_.+/=]*$/;

	if (!jwtPattern.test(String(value))) throw error;

	return String(value);
};

type ValidateFieldTypeOptions = Partial<{
	valueOptions: INodePropertyOptions[];
	strict: boolean;
	parseStrings: boolean;
}>;

// Validates field against the schema and tries to parse it to the correct type
export function validateFieldType<K extends FieldType>(
	fieldName: string,
	value: unknown,
	type: K,
	options?: ValidateFieldTypeOptions,
): ValidationResult<K>;
// eslint-disable-next-line complexity
export function validateFieldType(
	fieldName: string,
	value: unknown,
	type: FieldType,
	options: ValidateFieldTypeOptions = {},
): ValidationResult {
	if (value === null || value === undefined) return { valid: true };
	const strict = options.strict ?? false;
	const valueOptions = options.valueOptions ?? [];
	const parseStrings = options.parseStrings ?? false;

	const defaultErrorMessage = `'${fieldName}' expects a ${type} but we got ${getValueDescription(value)}`;
	switch (type.toLowerCase()) {
		case 'string': {
			if (!parseStrings) return { valid: true, newValue: value };
			try {
				if (strict && typeof value !== 'string') {
					return { valid: false, errorMessage: defaultErrorMessage };
				}
				return { valid: true, newValue: tryToParseString(value) };
			} catch (e) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
		}
		case 'string-alphanumeric': {
			try {
				return { valid: true, newValue: tryToParseAlphanumericString(value) };
			} catch (e) {
				return {
					valid: false,
					errorMessage:
						'Value is not a valid alphanumeric string, only letters, numbers and underscore allowed',
				};
			}
		}
		case 'number': {
			try {
				if (strict && typeof value !== 'number') {
					return { valid: false, errorMessage: defaultErrorMessage };
				}
				return { valid: true, newValue: tryToParseNumber(value) };
			} catch (e) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
		}
		case 'boolean': {
			try {
				if (strict && typeof value !== 'boolean') {
					return { valid: false, errorMessage: defaultErrorMessage };
				}
				return { valid: true, newValue: tryToParseBoolean(value) };
			} catch (e) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
		}
		case 'datetime': {
			try {
				return { valid: true, newValue: tryToParseDateTime(value) };
			} catch (e) {
				const luxonDocsURL =
					'https://moment.github.io/luxon/api-docs/index.html#datetimefromformat';
				const errorMessage = `${defaultErrorMessage} <br/><br/> Consider using <a href="${luxonDocsURL}" target="_blank"><code>DateTime.fromFormat</code></a> to work with custom date formats.`;
				return { valid: false, errorMessage };
			}
		}
		case 'time': {
			try {
				return { valid: true, newValue: tryToParseTime(value) };
			} catch (e) {
				return {
					valid: false,
					errorMessage: `'${fieldName}' expects time (hh:mm:(:ss)) but we got ${getValueDescription(value)}.`,
				};
			}
		}
		case 'object': {
			try {
				if (strict && !isObject(value)) {
					return { valid: false, errorMessage: defaultErrorMessage };
				}
				return { valid: true, newValue: tryToParseObject(value) };
			} catch (e) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
		}
		case 'array': {
			if (strict && !Array.isArray(value)) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
			try {
				return { valid: true, newValue: tryToParseArray(value) };
			} catch (e) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
		}
		case 'options': {
			const validOptions = valueOptions.map((option) => option.value).join(', ');
			const isValidOption = valueOptions.some((option) => option.value === value);

			if (!isValidOption) {
				return {
					valid: false,
					errorMessage: `'${fieldName}' expects one of the following values: [${validOptions}] but we got ${getValueDescription(
						value,
					)}`,
				};
			}
			return { valid: true, newValue: value };
		}
		case 'url': {
			try {
				return { valid: true, newValue: tryToParseUrl(value) };
			} catch (e) {
				return { valid: false, errorMessage: defaultErrorMessage };
			}
		}
		case 'jwt': {
			try {
				return { valid: true, newValue: tryToParseJwt(value) };
			} catch (e) {
				return {
					valid: false,
					errorMessage: 'Value is not a valid JWT token',
				};
			}
		}
		case 'form-fields': {
			try {
				return { valid: true, newValue: tryToParseJsonToFormFields(value) };
			} catch (e) {
				return {
					valid: false,
					errorMessage: (e as Error).message,
				};
			}
		}
		default: {
			return { valid: true, newValue: value };
		}
	}
}



================================================
FILE: packages/workflow/src/types.d.ts
================================================
/// <reference lib="es2022.error" />

declare module '@n8n_io/riot-tmpl' {
	interface Brackets {
		set(token: string): void;
	}

	type ReturnValue = string | null | (() => unknown);
	type TmplFn = (value: string, data: unknown) => ReturnValue;
	interface Tmpl extends TmplFn {
		errorHandler?(error: Error): void;
	}

	let brackets: Brackets;
	let tmpl: Tmpl;
}

interface BigInt {
	toJSON(): string;
}



================================================
FILE: packages/workflow/src/utils.ts
================================================
import { ApplicationError } from '@n8n/errors';
import { parse as esprimaParse, Syntax } from 'esprima-next';
import type { Node as SyntaxNode, ExpressionStatement } from 'esprima-next';
import FormData from 'form-data';
import merge from 'lodash/merge';

import { ALPHABET } from './constants';
import { ExecutionCancelledError } from './errors/execution-cancelled.error';
import type { BinaryFileType, IDisplayOptions, INodeProperties, JsonObject } from './interfaces';
import * as LoggerProxy from './logger-proxy';

const readStreamClasses = new Set(['ReadStream', 'Readable', 'ReadableStream']);

// NOTE: BigInt.prototype.toJSON is not available, which causes JSON.stringify to throw an error
// as well as the flatted stringify method. This is a workaround for that.
BigInt.prototype.toJSON = function () {
	return this.toString();
};

export const isObjectEmpty = (obj: object | null | undefined): boolean => {
	if (obj === undefined || obj === null) return true;
	if (typeof obj === 'object') {
		if (obj instanceof FormData) return obj.getLengthSync() === 0;
		if (Array.isArray(obj)) return obj.length === 0;
		if (obj instanceof Set || obj instanceof Map) return obj.size === 0;
		if (ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer) return obj.byteLength === 0;
		if (Symbol.iterator in obj || readStreamClasses.has(obj.constructor.name)) return false;
		return Object.keys(obj).length === 0;
	}
	return true;
};

export type Primitives = string | number | boolean | bigint | symbol | null | undefined;

/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-argument */
export const deepCopy = <T extends ((object | Date) & { toJSON?: () => string }) | Primitives>(
	source: T,
	hash = new WeakMap(),
	path = '',
): T => {
	const hasOwnProp = Object.prototype.hasOwnProperty.bind(source);
	// Primitives & Null & Function
	if (typeof source !== 'object' || source === null || typeof source === 'function') {
		return source;
	}
	// Date and other objects with toJSON method
	// TODO: remove this when other code parts not expecting objects with `.toJSON` method called and add back checking for Date and cloning it properly
	if (typeof source.toJSON === 'function') {
		return source.toJSON() as T;
	}
	if (hash.has(source)) {
		return hash.get(source);
	}
	// Array
	if (Array.isArray(source)) {
		const clone = [];
		const len = source.length;
		for (let i = 0; i < len; i++) {
			clone[i] = deepCopy(source[i], hash, path + `[${i}]`);
		}
		return clone as T;
	}
	// Object
	const clone = Object.create(Object.getPrototypeOf({}));
	hash.set(source, clone);
	for (const i in source) {
		if (hasOwnProp(i)) {
			clone[i] = deepCopy((source as any)[i], hash, path + `.${i}`);
		}
	}
	return clone;
};
// eslint-enable

function syntaxNodeToValue(expression?: SyntaxNode | null): unknown {
	switch (expression?.type) {
		case Syntax.ObjectExpression:
			return Object.fromEntries(
				expression.properties
					.filter((prop) => prop.type === Syntax.Property)
					.map(({ key, value }) => [syntaxNodeToValue(key), syntaxNodeToValue(value)]),
			);
		case Syntax.Identifier:
			return expression.name;
		case Syntax.Literal:
			return expression.value;
		case Syntax.ArrayExpression:
			return expression.elements.map((exp) => syntaxNodeToValue(exp));
		default:
			return undefined;
	}
}

/**
 * Parse any JavaScript ObjectExpression, including:
 * - single quoted keys
 * - unquoted keys
 */
function parseJSObject(objectAsString: string): object {
	const jsExpression = esprimaParse(`(${objectAsString})`).body.find(
		(node): node is ExpressionStatement =>
			node.type === Syntax.ExpressionStatement && node.expression.type === Syntax.ObjectExpression,
	);

	return syntaxNodeToValue(jsExpression?.expression) as object;
}

type MutuallyExclusive<T, U> =
	| (T & { [k in Exclude<keyof U, keyof T>]?: never })
	| (U & { [k in Exclude<keyof T, keyof U>]?: never });

type JSONParseOptions<T> = { acceptJSObject?: boolean } & MutuallyExclusive<
	{ errorMessage?: string },
	{ fallbackValue?: T }
>;

/**
 * Parses a JSON string into an object with optional error handling and recovery mechanisms.
 *
 * @param {string} jsonString - The JSON string to parse.
 * @param {Object} [options] - Optional settings for parsing the JSON string. Either `fallbackValue` or `errorMessage` can be set, but not both.
 * @param {boolean} [options.acceptJSObject=false] - If true, attempts to recover from common JSON format errors by parsing the JSON string as a JavaScript Object.
 * @param {string} [options.errorMessage] - A custom error message to throw if the JSON string cannot be parsed.
 * @param {*} [options.fallbackValue] - A fallback value to return if the JSON string cannot be parsed.
 * @returns {Object} - The parsed object, or the fallback value if parsing fails and `fallbackValue` is set.
 */
export const jsonParse = <T>(jsonString: string, options?: JSONParseOptions<T>): T => {
	try {
		return JSON.parse(jsonString) as T;
	} catch (error) {
		if (options?.acceptJSObject) {
			try {
				const jsonStringCleaned = parseJSObject(jsonString);
				return jsonStringCleaned as T;
			} catch (e) {
				// Ignore this error and return the original error or the fallback value
			}
		}
		if (options?.fallbackValue !== undefined) {
			if (options.fallbackValue instanceof Function) {
				return options.fallbackValue();
			}
			return options.fallbackValue;
		} else if (options?.errorMessage) {
			throw new ApplicationError(options.errorMessage);
		}

		throw error;
	}
};

type JSONStringifyOptions = {
	replaceCircularRefs?: boolean;
};

/**
 * Decodes a Base64 string with proper UTF-8 character handling.
 *
 * @param str - The Base64 string to decode
 * @returns The decoded UTF-8 string
 */
export const base64DecodeUTF8 = (str: string): string => {
	try {
		// Use modern TextDecoder for proper UTF-8 handling
		const bytes = new Uint8Array(
			atob(str)
				.split('')
				.map((char) => char.charCodeAt(0)),
		);
		return new TextDecoder('utf-8').decode(bytes);
	} catch (error) {
		// Fallback method for older browsers
		console.warn('TextDecoder not available, using fallback method');
		return atob(str);
	}
};

export const replaceCircularReferences = <T>(value: T, knownObjects = new WeakSet()): T => {
	if (typeof value !== 'object' || value === null || value instanceof RegExp) return value;
	if ('toJSON' in value && typeof value.toJSON === 'function') return value.toJSON() as T;
	if (knownObjects.has(value)) return '[Circular Reference]' as T;
	knownObjects.add(value);
	const copy = (Array.isArray(value) ? [] : {}) as T;
	for (const key in value) {
		try {
			copy[key] = replaceCircularReferences(value[key], knownObjects);
		} catch (error: unknown) {
			if (
				error instanceof TypeError &&
				error.message.includes('Cannot assign to read only property')
			) {
				LoggerProxy.error('Error while replacing circular references: ' + error.message, { error });
				continue; // Skip properties that cannot be assigned to (readonly, non-configurable, etc.)
			}
			throw error;
		}
	}
	knownObjects.delete(value);
	return copy;
};

export const jsonStringify = (obj: unknown, options: JSONStringifyOptions = {}): string => {
	return JSON.stringify(options?.replaceCircularRefs ? replaceCircularReferences(obj) : obj);
};

export const sleep = async (ms: number): Promise<void> =>
	await new Promise((resolve) => {
		setTimeout(resolve, ms);
	});

export const sleepWithAbort = async (ms: number, abortSignal?: AbortSignal): Promise<void> =>
	await new Promise((resolve, reject) => {
		if (abortSignal?.aborted) {
			reject(new ExecutionCancelledError(''));
			return;
		}

		const timeout = setTimeout(resolve, ms);

		const abortHandler = () => {
			clearTimeout(timeout);
			reject(new ExecutionCancelledError(''));
		};

		abortSignal?.addEventListener('abort', abortHandler, { once: true });
	});

export function fileTypeFromMimeType(mimeType: string): BinaryFileType | undefined {
	if (mimeType.startsWith('application/json')) return 'json';
	if (mimeType.startsWith('text/html')) return 'html';
	if (mimeType.startsWith('image/')) return 'image';
	if (mimeType.startsWith('audio/')) return 'audio';
	if (mimeType.startsWith('video/')) return 'video';
	if (mimeType.startsWith('text/') || mimeType.startsWith('application/javascript')) return 'text';
	if (mimeType.startsWith('application/pdf')) return 'pdf';
	return;
}

export function assert<T>(condition: T, msg?: string): asserts condition {
	if (!condition) {
		const error = new Error(msg ?? 'Invalid assertion');
		// hide assert stack frame if supported
		if (Error.hasOwnProperty('captureStackTrace')) {
			// V8 only - https://nodejs.org/api/errors.html#errors_error_capturestacktrace_targetobject_constructoropt
			Error.captureStackTrace(error, assert);
		} else if (error.stack) {
			// fallback for IE and Firefox
			error.stack = error.stack
				.split('\n')
				.slice(1) // skip assert function from stack frames
				.join('\n');
		}
		throw error;
	}
}

export const isTraversableObject = (value: any): value is JsonObject => {
	return value && typeof value === 'object' && !Array.isArray(value) && !!Object.keys(value).length;
};

export const removeCircularRefs = (obj: JsonObject, seen = new Set()) => {
	seen.add(obj);
	Object.entries(obj).forEach(([key, value]) => {
		if (isTraversableObject(value)) {
			// eslint-disable-next-line @typescript-eslint/no-unused-expressions
			seen.has(value) ? (obj[key] = { circularReference: true }) : removeCircularRefs(value, seen);
			return;
		}
		if (Array.isArray(value)) {
			value.forEach((val, index) => {
				if (seen.has(val)) {
					value[index] = { circularReference: true };
					return;
				}
				if (isTraversableObject(val)) {
					removeCircularRefs(val, seen);
				}
			});
		}
	});
};

export function updateDisplayOptions(
	displayOptions: IDisplayOptions,
	properties: INodeProperties[],
) {
	return properties.map((nodeProperty) => {
		return {
			...nodeProperty,
			displayOptions: merge({}, nodeProperty.displayOptions, displayOptions),
		};
	});
}

export function randomInt(max: number): number;
export function randomInt(min: number, max: number): number;
/**
 * Generates a random integer within a specified range.
 *
 * @param {number} min - The lower bound of the range. If `max` is not provided, this value is used as the upper bound and the lower bound is set to 0.
 * @param {number} [max] - The upper bound of the range, not inclusive.
 * @returns {number} A random integer within the specified range.
 */
export function randomInt(min: number, max?: number): number {
	if (max === undefined) {
		max = min;
		min = 0;
	}
	return min + (crypto.getRandomValues(new Uint32Array(1))[0] % (max - min));
}

export function randomString(length: number): string;
export function randomString(minLength: number, maxLength: number): string;
/**
 * Generates a random alphanumeric string of a specified length, or within a range of lengths.
 *
 * @param {number} minLength - If `maxLength` is not provided, this is the length of the string to generate. Otherwise, this is the lower bound of the range of possible lengths.
 * @param {number} [maxLength] - The upper bound of the range of possible lengths. If provided, the actual length of the string will be a random number between `minLength` and `maxLength`, inclusive.
 * @returns {string} A random alphanumeric string of the specified length or within the specified range of lengths.
 */
export function randomString(minLength: number, maxLength?: number): string {
	const length = maxLength === undefined ? minLength : randomInt(minLength, maxLength + 1);
	return [...crypto.getRandomValues(new Uint32Array(length))]
		.map((byte) => ALPHABET[byte % ALPHABET.length])
		.join('');
}

/**
 * Checks if a value is an object with a specific key and provides a type guard for the key.
 */
export function hasKey<T extends PropertyKey>(value: unknown, key: T): value is Record<T, unknown> {
	return value !== null && typeof value === 'object' && value.hasOwnProperty(key);
}

const unsafeObjectProperties = new Set(['__proto__', 'prototype', 'constructor', 'getPrototypeOf']);

/**
 * Checks if a property key is safe to use on an object, preventing prototype pollution.
 * setting untrusted properties can alter the object's prototype chain and introduce vulnerabilities.
 *
 * @see setSafeObjectProperty
 */
export function isSafeObjectProperty(property: string) {
	return !unsafeObjectProperties.has(property);
}

/**
 * Safely sets a property on an object, preventing prototype pollution.
 *
 * @see isSafeObjectProperty
 */
export function setSafeObjectProperty(
	target: Record<string, unknown>,
	property: string,
	value: unknown,
) {
	if (isSafeObjectProperty(property)) {
		target[property] = value;
	}
}

export function isDomainAllowed(
	urlString: string,
	options: {
		allowedDomains: string;
	},
): boolean {
	if (!options.allowedDomains || options.allowedDomains.trim() === '') {
		return true; // If no restrictions are set, allow all domains
	}

	try {
		const url = new URL(urlString);
		const hostname = url.hostname;

		const allowedDomainsList = options.allowedDomains
			.split(',')
			.map((domain) => domain.trim())
			.filter(Boolean);

		for (const allowedDomain of allowedDomainsList) {
			// Handle wildcard domains (*.example.com)
			if (allowedDomain.startsWith('*.')) {
				const domainSuffix = allowedDomain.substring(2); // Remove the *. part
				if (hostname.endsWith(domainSuffix)) {
					return true;
				}
			}
			// Exact match
			else if (hostname === allowedDomain) {
				return true;
			}
		}

		return false;
	} catch (error) {
		// If URL parsing fails, deny access to be safe
		return false;
	}
}



================================================
FILE: packages/workflow/src/versioned-node-type.ts
================================================
import type { INodeTypeBaseDescription, IVersionedNodeType, INodeType } from './interfaces';

export class VersionedNodeType implements IVersionedNodeType {
	currentVersion: number;

	nodeVersions: IVersionedNodeType['nodeVersions'];

	description: INodeTypeBaseDescription;

	constructor(
		nodeVersions: IVersionedNodeType['nodeVersions'],
		description: INodeTypeBaseDescription,
	) {
		this.nodeVersions = nodeVersions;
		this.currentVersion = description.defaultVersion ?? this.getLatestVersion();
		this.description = description;
	}

	getLatestVersion() {
		return Math.max(...Object.keys(this.nodeVersions).map(Number));
	}

	getNodeType(version?: number): INodeType {
		if (version) {
			return this.nodeVersions[version];
		} else {
			return this.nodeVersions[this.currentVersion];
		}
	}
}



================================================
FILE: packages/workflow/src/workflow-data-proxy-env-provider.ts
================================================
import { ExpressionError } from './errors/expression.error';

export type EnvProviderState = {
	isProcessAvailable: boolean;
	isEnvAccessBlocked: boolean;
	env: Record<string, string>;
};

/**
 * Captures a snapshot of the environment variables and configuration
 * that can be used to initialize an environment provider.
 */
export function createEnvProviderState(): EnvProviderState {
	const isProcessAvailable = typeof process !== 'undefined';
	const isEnvAccessBlocked = isProcessAvailable
		? process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE === 'true'
		: false;
	const env: Record<string, string> =
		!isProcessAvailable || isEnvAccessBlocked ? {} : (process.env as Record<string, string>);

	return {
		isProcessAvailable,
		isEnvAccessBlocked,
		env,
	};
}

/**
 * Creates a proxy that provides access to the environment variables
 * in the `WorkflowDataProxy`. Use the `createEnvProviderState` to
 * create the default state object that is needed for the proxy,
 * unless you need something specific.
 *
 * @example
 * createEnvProvider(
 *   runIndex,
 *   itemIndex,
 *   createEnvProviderState(),
 * )
 */
export function createEnvProvider(
	runIndex: number,
	itemIndex: number,
	providerState: EnvProviderState,
): Record<string, string> {
	return new Proxy(
		{},
		{
			has() {
				return true;
			},

			get(_, name) {
				if (name === 'isProxy') return true;

				if (!providerState.isProcessAvailable) {
					throw new ExpressionError('not accessible via UI, please run node', {
						runIndex,
						itemIndex,
					});
				}
				if (providerState.isEnvAccessBlocked) {
					throw new ExpressionError('access to env vars denied', {
						causeDetailed:
							'If you need access please contact the administrator to remove the environment variable ‘N8N_BLOCK_ENV_ACCESS_IN_NODE‘',
						runIndex,
						itemIndex,
					});
				}

				return providerState.env[name.toString()];
			},
		},
	);
}



================================================
FILE: packages/workflow/src/workflow-data-proxy-helpers.ts
================================================
import type { INodeExecutionData, Workflow, WorkflowExecuteMode } from '.';

export function getPinDataIfManualExecution(
	workflow: Workflow,
	nodeName: string,
	mode: WorkflowExecuteMode,
): INodeExecutionData[] | undefined {
	if (mode !== 'manual') {
		return undefined;
	}
	return workflow.getPinDataOfNode(nodeName);
}



================================================
FILE: packages/workflow/src/workflow-data-proxy.ts
================================================
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
/* eslint-disable @typescript-eslint/no-this-alias */
/* eslint-disable @typescript-eslint/no-unsafe-return */

import * as jmespath from 'jmespath';
import { DateTime, Duration, Interval, Settings } from 'luxon';

import { augmentArray, augmentObject } from './augment-object';
import { AGENT_LANGCHAIN_NODE_TYPE, SCRIPTING_NODE_TYPES } from './constants';
import { ApplicationError } from '@n8n/errors';
import { ExpressionError, type ExpressionErrorOptions } from './errors/expression.error';
import { getGlobalState } from './global-state';
import { NodeConnectionTypes } from './interfaces';
import type {
	IDataObject,
	IExecuteData,
	INodeExecutionData,
	INodeParameters,
	IPairedItemData,
	IRunExecutionData,
	ISourceData,
	ITaskData,
	IWorkflowDataProxyAdditionalKeys,
	IWorkflowDataProxyData,
	NodeParameterValueType,
	WorkflowExecuteMode,
	ProxyInput,
	INode,
} from './interfaces';
import * as NodeHelpers from './node-helpers';
import { createResultError, createResultOk } from './result';
import { isResourceLocatorValue } from './type-guards';
import { deepCopy, isObjectEmpty } from './utils';
import type { Workflow } from './workflow';
import type { EnvProviderState } from './workflow-data-proxy-env-provider';
import { createEnvProvider, createEnvProviderState } from './workflow-data-proxy-env-provider';
import { getPinDataIfManualExecution } from './workflow-data-proxy-helpers';

const isScriptingNode = (nodeName: string, workflow: Workflow) => {
	const node = workflow.getNode(nodeName);

	return node && SCRIPTING_NODE_TYPES.includes(node.type);
};

const PAIRED_ITEM_METHOD = {
	PAIRED_ITEM: 'pairedItem',
	ITEM_MATCHING: 'itemMatching',
	ITEM: 'item',
	$GET_PAIRED_ITEM: '$getPairedItem',
} as const;

type PairedItemMethod = (typeof PAIRED_ITEM_METHOD)[keyof typeof PAIRED_ITEM_METHOD];

export class WorkflowDataProxy {
	private runExecutionData: IRunExecutionData | null;

	private connectionInputData: INodeExecutionData[];

	private timezone: string;

	// TODO: Clean that up at some point and move all the options into an options object
	constructor(
		private workflow: Workflow,
		runExecutionData: IRunExecutionData | null,
		private runIndex: number,
		private itemIndex: number,
		private activeNodeName: string,
		connectionInputData: INodeExecutionData[],
		private siblingParameters: INodeParameters,
		private mode: WorkflowExecuteMode,
		private additionalKeys: IWorkflowDataProxyAdditionalKeys,
		private executeData?: IExecuteData,
		private defaultReturnRunIndex = -1,
		private selfData: IDataObject = {},
		private contextNodeName: string = activeNodeName,
		private envProviderState?: EnvProviderState,
	) {
		this.runExecutionData = isScriptingNode(this.contextNodeName, workflow)
			? runExecutionData !== null
				? augmentObject(runExecutionData)
				: null
			: runExecutionData;

		this.connectionInputData = isScriptingNode(this.contextNodeName, workflow)
			? augmentArray(connectionInputData)
			: connectionInputData;

		this.timezone = workflow.settings?.timezone ?? getGlobalState().defaultTimezone;
		Settings.defaultZone = this.timezone;
	}

	/**
	 * Returns a proxy which allows to query context data of a given node
	 *
	 * @private
	 * @param {string} nodeName The name of the node to get the context from
	 */
	private nodeContextGetter(nodeName: string) {
		const that = this;
		const node = this.workflow.nodes[nodeName];

		if (!that.runExecutionData?.executionData && that.connectionInputData.length > 0) {
			return {}; // incoming connection has pinned data, so stub context object
		}

		if (!that.runExecutionData?.executionData && !that.runExecutionData?.resultData) {
			throw new ExpressionError(
				"The workflow hasn't been executed yet, so you can't reference any context data",
				{
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
					type: 'no_execution_data',
				},
			);
		}

		return new Proxy(
			{},
			{
				has: () => true,
				ownKeys(target) {
					if (Reflect.ownKeys(target).length === 0) {
						// Target object did not get set yet
						Object.assign(target, NodeHelpers.getContext(that.runExecutionData!, 'node', node));
					}

					return Reflect.ownKeys(target);
				},
				getOwnPropertyDescriptor() {
					return {
						enumerable: true,
						configurable: true,
					};
				},
				get(_, name) {
					if (name === 'isProxy') return true;

					name = name.toString();
					const contextData = NodeHelpers.getContext(that.runExecutionData!, 'node', node);

					return contextData[name];
				},
			},
		);
	}

	private selfGetter() {
		const that = this;

		return new Proxy(
			{},
			{
				has: () => true,
				ownKeys(target) {
					return Reflect.ownKeys(target);
				},

				get(_, name) {
					if (name === 'isProxy') return true;
					name = name.toString();
					return that.selfData[name];
				},
			},
		);
	}

	private buildAgentToolInfo(node: INode) {
		const nodeType = this.workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
		const type = nodeType.description.displayName;
		const params = NodeHelpers.getNodeParameters(
			nodeType.description.properties,
			node.parameters,
			true,
			false,
			node,
			nodeType.description,
		);
		const resourceKey = params?.resource;
		const operationKey = params?.operation;

		const resource =
			nodeType.description.properties
				.find((nodeProperties) => nodeProperties.name === 'resource')
				?.options?.find((option) => 'value' in option && option.value === resourceKey)?.name ??
			null;

		const operation =
			nodeType.description.properties
				.find(
					(nodeProperty) =>
						nodeProperty.name === 'operation' &&
						nodeProperty.displayOptions?.show?.resource?.some((y) => y === resourceKey),
				)
				?.options?.find((y) => 'value' in y && y.value === operationKey)?.name ?? null;

		const hasCredentials = !isObjectEmpty(node.credentials ?? {});

		const hasValidCalendar = nodeType.description.name.includes('googleCalendar')
			? isResourceLocatorValue(node.parameters.calendar) && node.parameters.calendar.value !== ''
			: undefined;

		const aiDefinedFields = Object.entries(node.parameters)
			.map(([key, value]) => [key, isResourceLocatorValue(value) ? value.value : value] as const)
			.filter(([_, value]) => value?.toString().toLowerCase().includes('$fromai'))
			.map(
				([key]) =>
					nodeType.description.properties.find((property) => property.name === key)?.displayName,
			);

		return {
			name: node.name,
			type,
			resource,
			operation,
			hasCredentials,
			hasValidCalendar,
			aiDefinedFields,
		};
	}

	private agentInfo() {
		const agentNode = this.workflow.getNode(this.activeNodeName);
		if (!agentNode || agentNode.type !== AGENT_LANGCHAIN_NODE_TYPE) return undefined;
		const connectedTools = this.workflow
			.getParentNodes(this.activeNodeName, NodeConnectionTypes.AiTool)
			.map((nodeName) => this.workflow.getNode(nodeName))
			.filter((node) => node) as INode[];
		const memoryConnectedToAgent =
			this.workflow.getParentNodes(this.activeNodeName, NodeConnectionTypes.AiMemory).length > 0;
		const allTools = this.workflow.queryNodes((nodeType) => {
			return nodeType.description.name.toLowerCase().includes('tool');
		});

		const unconnectedTools = allTools
			.filter(
				(node) =>
					this.workflow.getChildNodes(node.name, NodeConnectionTypes.AiTool, 1).length === 0,
			)
			.filter((node) => !connectedTools.includes(node));

		return {
			memoryConnectedToAgent,
			tools: [
				...connectedTools.map((node) => ({ connected: true, ...this.buildAgentToolInfo(node) })),
				...unconnectedTools.map((node) => ({ connected: false, ...this.buildAgentToolInfo(node) })),
			],
		};
	}

	/**
	 * Returns a proxy which allows to query parameter data of a given node
	 *
	 * @private
	 * @param {string} nodeName The name of the node to query data from
	 * @param {boolean} [resolveValue=true] If the expression value should get resolved
	 */
	private nodeParameterGetter(nodeName: string, resolveValue = true) {
		const that = this;
		const node = this.workflow.nodes[nodeName];

		// `node` is `undefined` only in expressions in credentials

		return new Proxy(node?.parameters ?? {}, {
			has: () => true,
			ownKeys(target) {
				return Reflect.ownKeys(target);
			},
			getOwnPropertyDescriptor() {
				return {
					enumerable: true,
					configurable: true,
				};
			},
			get(target, name) {
				if (name === 'isProxy') return true;
				if (name === 'toJSON') return () => deepCopy(target);

				name = name.toString();

				let returnValue: NodeParameterValueType;
				if (name[0] === '&') {
					const key = name.slice(1);
					if (!that.siblingParameters.hasOwnProperty(key)) {
						throw new ApplicationError('Could not find sibling parameter on node', {
							extra: { nodeName, parameter: key },
						});
					}
					returnValue = that.siblingParameters[key];
				} else {
					if (!node.parameters.hasOwnProperty(name)) {
						// Parameter does not exist on node
						return undefined;
					}

					returnValue = node.parameters[name];
				}

				// Avoid recursion
				if (returnValue === `={{ $parameter.${name} }}`) return undefined;

				if (isResourceLocatorValue(returnValue)) {
					if (returnValue.__regex && typeof returnValue.value === 'string') {
						const expr = new RegExp(returnValue.__regex);
						const extracted = expr.exec(returnValue.value);
						if (extracted && extracted.length >= 2) {
							returnValue = extracted[1];
						} else {
							return returnValue.value;
						}
					} else {
						returnValue = returnValue.value;
					}
				}

				if (resolveValue && typeof returnValue === 'string' && returnValue.charAt(0) === '=') {
					// The found value is an expression so resolve it
					return that.workflow.expression.getParameterValue(
						returnValue,
						that.runExecutionData,
						that.runIndex,
						that.itemIndex,
						that.activeNodeName,
						that.connectionInputData,
						that.mode,
						that.additionalKeys,
						that.executeData,
						false,
						{},
						that.contextNodeName,
					);
				}

				return returnValue;
			},
		});
	}

	private getNodeExecutionOrPinnedData({
		nodeName,
		branchIndex,
		runIndex,
		shortSyntax = false,
	}: {
		nodeName: string;
		branchIndex?: number;
		runIndex?: number;
		shortSyntax?: boolean;
	}) {
		try {
			return this.getNodeExecutionData(nodeName, shortSyntax, branchIndex, runIndex);
		} catch (e) {
			const pinData = getPinDataIfManualExecution(this.workflow, nodeName, this.mode);
			if (pinData) {
				return pinData;
			}

			throw e;
		}
	}

	/**
	 * Returns the node ExecutionData
	 *
	 * @private
	 * @param {string} nodeName The name of the node query data from
	 * @param {boolean} [shortSyntax=false] If short syntax got used
	 * @param {number} [outputIndex] The index of the output, if not given the first one gets used
	 * @param {number} [runIndex] The index of the run, if not given the current one does get used
	 */
	private getNodeExecutionData(
		nodeName: string,
		shortSyntax = false,
		outputIndex?: number,
		runIndex?: number,
	): INodeExecutionData[] {
		const that = this;

		let executionData: INodeExecutionData[];
		if (!shortSyntax) {
			// Long syntax got used to return data from node in path

			if (that.runExecutionData === null) {
				throw new ExpressionError(
					"The workflow hasn't been executed yet, so you can't reference any output data",
					{
						runIndex: that.runIndex,
						itemIndex: that.itemIndex,
					},
				);
			}

			if (!that.workflow.getNode(nodeName)) {
				throw new ExpressionError("Referenced node doesn't exist", {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
					nodeCause: nodeName,
					descriptionKey: 'nodeNotFound',
				});
			}

			if (
				!that.runExecutionData.resultData.runData.hasOwnProperty(nodeName) &&
				!getPinDataIfManualExecution(that.workflow, nodeName, that.mode)
			) {
				throw new ExpressionError(`Node '${nodeName}' hasn't been executed`, {
					messageTemplate:
						'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
					functionality: 'pairedItem',
					descriptionKey: isScriptingNode(nodeName, that.workflow)
						? 'pairedItemNoConnectionCodeNode'
						: 'pairedItemNoConnection',
					type: 'no_execution_data',
					nodeCause: nodeName,
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
				});
			}

			runIndex = runIndex === undefined ? that.defaultReturnRunIndex : runIndex;
			runIndex =
				runIndex === -1 ? that.runExecutionData.resultData.runData[nodeName].length - 1 : runIndex;

			if (that.runExecutionData.resultData.runData[nodeName].length <= runIndex) {
				throw new ExpressionError(`Run ${runIndex} of node "${nodeName}" not found`, {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
				});
			}

			const taskData = that.runExecutionData.resultData.runData[nodeName][runIndex].data!;

			if (!taskData.main?.length || taskData.main[0] === null) {
				// throw new ApplicationError('No data found for item-index', { extra: { itemIndex } });
				throw new ExpressionError('No data found from `main` input', {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
				});
			}

			// Check from which output to read the data.
			// Depends on how the nodes are connected.
			// (example "IF" node. If node is connected to "true" or to "false" output)
			if (outputIndex === undefined) {
				const nodeConnection = that.workflow.getNodeConnectionIndexes(
					that.contextNodeName,
					nodeName,
					NodeConnectionTypes.Main,
				);

				if (nodeConnection === undefined) {
					throw new ExpressionError(`connect "${that.contextNodeName}" to "${nodeName}"`, {
						runIndex: that.runIndex,
						itemIndex: that.itemIndex,
					});
				}
				outputIndex = nodeConnection.sourceIndex;
			}

			if (outputIndex === undefined) {
				outputIndex = 0;
			}

			if (taskData.main.length <= outputIndex) {
				throw new ExpressionError(`Node "${nodeName}" has no branch with index ${outputIndex}.`, {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
				});
			}

			executionData = taskData.main[outputIndex] as INodeExecutionData[];
		} else {
			// Short syntax got used to return data from active node
			executionData = that.connectionInputData;
		}

		return executionData;
	}

	/**
	 * Returns a proxy which allows to query data of a given node
	 *
	 * @private
	 * @param {string} nodeName The name of the node query data from
	 * @param {boolean} [shortSyntax=false] If short syntax got used
	 * @param {boolean} [throwOnMissingExecutionData=true] If an error should get thrown if no execution data is available
	 */
	private nodeDataGetter(
		nodeName: string,
		shortSyntax = false,
		throwOnMissingExecutionData = true,
	) {
		const that = this;
		const node = this.workflow.nodes[nodeName];

		return new Proxy(
			{ binary: undefined, data: undefined, json: undefined },
			{
				has: () => true,
				get(target, name, receiver) {
					if (name === 'isProxy') return true;
					name = name.toString();

					if (!node) {
						throw new ExpressionError('Referenced node does not exist', {
							messageTemplate: 'Make sure to double-check the node name for typos',
							functionality: 'pairedItem',
							descriptionKey: isScriptingNode(nodeName, that.workflow)
								? 'pairedItemNoConnectionCodeNode'
								: 'pairedItemNoConnection',
							type: 'paired_item_no_connection',
							nodeCause: nodeName,
							runIndex: that.runIndex,
							itemIndex: that.itemIndex,
						});
					}

					if (['binary', 'data', 'json'].includes(name)) {
						const executionData = that.getNodeExecutionOrPinnedData({
							nodeName,
							shortSyntax,
						});

						if (executionData.length === 0 && !throwOnMissingExecutionData) {
							return undefined;
						}

						// Ultra-simple execution-based validation: if no execution data exists, throw error
						if (executionData.length === 0) {
							throw new ExpressionError(`Node '${nodeName}' hasn't been executed`, {
								messageTemplate:
									'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
								functionality: 'pairedItem',
								descriptionKey: isScriptingNode(nodeName, that.workflow)
									? 'pairedItemNoConnectionCodeNode'
									: 'pairedItemNoConnection',
								type: 'no_execution_data',
								nodeCause: nodeName,
								runIndex: that.runIndex,
								itemIndex: that.itemIndex,
							});
						}

						if (executionData.length <= that.itemIndex) {
							throw new ExpressionError(
								`"${nodeName}" node has ${executionData.length} item(s) but you're trying to access item ${that.itemIndex}`,
								{
									messageTemplate:
										'Adjust your expression to access an existing item index (0-{{maxIndex}})',
									functionality: 'pairedItem',
									descriptionKey: 'pairedItemInvalidIndex',
									type: 'no_execution_data',
									nodeCause: nodeName,
									runIndex: that.runIndex,
									itemIndex: that.itemIndex,
								},
							);
						}

						if (['data', 'json'].includes(name)) {
							// JSON-Data
							return executionData[that.itemIndex].json;
						}
						if (name === 'binary') {
							// Binary-Data
							const returnData: IDataObject = {};

							if (!executionData[that.itemIndex].binary) {
								return returnData;
							}

							const binaryKeyData = executionData[that.itemIndex].binary!;
							for (const keyName of Object.keys(binaryKeyData)) {
								returnData[keyName] = {};

								const binaryData = binaryKeyData[keyName];
								for (const propertyName in binaryData) {
									if (propertyName === 'data') {
										// Skip the data property

										continue;
									}
									(returnData[keyName] as IDataObject)[propertyName] = binaryData[propertyName];
								}
							}

							return returnData;
						}
					} else if (name === 'context') {
						return that.nodeContextGetter(nodeName);
					} else if (name === 'parameter') {
						// Get node parameter data
						return that.nodeParameterGetter(nodeName);
					} else if (name === 'runIndex') {
						if (!that.runExecutionData?.resultData.runData[nodeName]) {
							return -1;
						}
						return that.runExecutionData.resultData.runData[nodeName].length - 1;
					}

					return Reflect.get(target, name, receiver);
				},
			},
		);
	}

	private prevNodeGetter() {
		const allowedValues = ['name', 'outputIndex', 'runIndex'];
		const that = this;

		return new Proxy(
			{},
			{
				has: () => true,
				ownKeys() {
					return allowedValues;
				},
				getOwnPropertyDescriptor() {
					return {
						enumerable: true,
						configurable: true,
					};
				},
				get(target, name, receiver) {
					if (name === 'isProxy') return true;

					if (!that.executeData?.source) {
						// Means the previous node did not get executed yet
						return undefined;
					}

					const sourceData: ISourceData = that.executeData.source.main[0] as ISourceData;

					if (name === 'name') {
						return sourceData.previousNode;
					}
					if (name === 'outputIndex') {
						return sourceData.previousNodeOutput || 0;
					}
					if (name === 'runIndex') {
						return sourceData.previousNodeRun || 0;
					}

					return Reflect.get(target, name, receiver);
				},
			},
		);
	}

	/**
	 * Returns a proxy to query data from the workflow
	 *
	 * @private
	 */
	private workflowGetter() {
		const allowedValues = ['active', 'id', 'name'];
		const that = this;

		return new Proxy(
			{},
			{
				has: () => true,
				ownKeys() {
					return allowedValues;
				},
				getOwnPropertyDescriptor() {
					return {
						enumerable: true,
						configurable: true,
					};
				},
				get(target, name, receiver) {
					if (name === 'isProxy') return true;

					if (allowedValues.includes(name.toString())) {
						const value = that.workflow[name as keyof typeof target];

						if (value === undefined && name === 'id') {
							throw new ExpressionError('save workflow to view', {
								description: 'Please save the workflow first to use $workflow',
								runIndex: that.runIndex,
								itemIndex: that.itemIndex,
							});
						}

						return value;
					}

					return Reflect.get(target, name, receiver);
				},
			},
		);
	}

	/**
	 * Returns a proxy to query data of all nodes
	 *
	 * @private
	 */
	private nodeGetter() {
		const that = this;
		return new Proxy(
			{},
			{
				has: () => true,
				get(_, name) {
					if (name === 'isProxy') return true;

					const nodeName = name.toString();

					if (that.workflow.getNode(nodeName) === null) {
						throw new ExpressionError("Referenced node doesn't exist", {
							runIndex: that.runIndex,
							itemIndex: that.itemIndex,
							nodeCause: nodeName,
							descriptionKey: 'nodeNotFound',
						});
					}

					return that.nodeDataGetter(nodeName);
				},
			},
		);
	}

	/**
	 * Returns the data proxy object which allows to query data from current run
	 *
	 */
	getDataProxy(opts?: { throwOnMissingExecutionData: boolean }): IWorkflowDataProxyData {
		const that = this;

		// replacing proxies with the actual data.
		const jmespathWrapper = (data: IDataObject | IDataObject[], query: string) => {
			if (typeof data !== 'object' || typeof query !== 'string') {
				throw new ExpressionError('expected two arguments (Object, string) for this function', {
					runIndex: that.runIndex,
					itemIndex: that.itemIndex,
				});
			}

			if (!Array.isArray(data) && typeof data === 'object') {
				return jmespath.search({ ...data }, query);
			}
			return jmespath.search(data, query);
		};

		const createExpressionError = (
			message: string,
			context?: ExpressionErrorOptions & {
				moreInfoLink?: boolean;
				functionOverrides?: {
					// Custom data to display for Function-Nodes
					message?: string;
					description?: string;
				};
			},
		) => {
			if (isScriptingNode(that.activeNodeName, that.workflow) && context?.functionOverrides) {
				// If the node in which the error is thrown is a function node,
				// display a different error message in case there is one defined
				message = context.functionOverrides.message || message;
				context.description = context.functionOverrides.description || context.description;
				// The error will be in the code and not on an expression on a parameter
				// so remove the messageTemplate as it would overwrite the message
				context.messageTemplate = undefined;
			}

			if (context?.nodeCause) {
				const nodeName = context.nodeCause;
				const pinData = getPinDataIfManualExecution(that.workflow, nodeName, that.mode);

				if (pinData) {
					if (!context) {
						context = {};
					}
					message = `Unpin '${nodeName}' to execute`;
					context.messageTemplate = undefined;
					context.descriptionKey = 'pairedItemPinned';
				}

				if (context.moreInfoLink && (pinData || isScriptingNode(nodeName, that.workflow))) {
					const moreInfoLink =
						' <a target="_blank" href="https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-errors/">More info</a>';

					context.description += moreInfoLink;
					if (context.descriptionTemplate) context.descriptionTemplate += moreInfoLink;
				}
			}

			return new ExpressionError(message, {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex,
				...context,
			});
		};

		const createInvalidPairedItemError = ({ nodeName }: { nodeName: string }) => {
			return createExpressionError("Can't get data for expression", {
				messageTemplate: 'Expression info invalid',
				functionality: 'pairedItem',
				functionOverrides: {
					message: "Can't get data",
				},
				nodeCause: nodeName,
				descriptionKey: 'pairedItemInvalidInfo',
				type: 'paired_item_invalid_info',
			});
		};

		const createMissingPairedItemError = (
			nodeCause: string,
			usedMethodName: PairedItemMethod = PAIRED_ITEM_METHOD.PAIRED_ITEM,
		) => {
			const pinData = getPinDataIfManualExecution(that.workflow, nodeCause, that.mode);
			const message = pinData
				? `Using the ${usedMethodName} method doesn't work with pinned data in this scenario. Please unpin '${nodeCause}' and try again.`
				: `Paired item data for ${usedMethodName} from node '${nodeCause}' is unavailable. Ensure '${nodeCause}' is providing the required output.`;

			return new ExpressionError(message, {
				runIndex: that.runIndex,
				itemIndex: that.itemIndex,
				functionality: 'pairedItem',
				descriptionKey: isScriptingNode(nodeCause, that.workflow)
					? 'pairedItemNoInfoCodeNode'
					: 'pairedItemNoInfo',
				nodeCause,
				causeDetailed: `Missing pairedItem data (node '${nodeCause}' probably didn't supply it)`,
				type: 'paired_item_no_info',
			});
		};

		const createNoConnectionError = (nodeCause: string) => {
			return createExpressionError('Invalid expression', {
				messageTemplate: 'No path back to referenced node',
				functionality: 'pairedItem',
				descriptionKey: isScriptingNode(nodeCause, that.workflow)
					? 'pairedItemNoConnectionCodeNode'
					: 'pairedItemNoConnection',
				type: 'paired_item_no_connection',
				moreInfoLink: true,
				nodeCause,
			});
		};

		function createBranchNotFoundError(node: string, item: number, cause?: string) {
			return createExpressionError('Branch not found', {
				messageTemplate: 'Paired item references non-existent branch',
				functionality: 'pairedItem',
				nodeCause: cause,
				functionOverrides: { message: 'Invalid branch reference' },
				description: `Item ${item} in node ${node} references a branch that doesn't exist.`,
				type: 'paired_item_invalid_info',
			});
		}

		function createPairedItemNotFound(destNode: string, cause?: string) {
			return createExpressionError('Paired item resolution failed', {
				messageTemplate: 'Unable to find paired item source',
				functionality: 'pairedItem',
				nodeCause: cause,
				functionOverrides: { message: 'Data not found' },
				description: `Could not trace back to node '${destNode}'`,
				type: 'paired_item_no_info',
				moreInfoLink: true,
			});
		}

		function createPairedItemMultipleItemsFound(destNode: string, itemIndex: number) {
			return createExpressionError('Multiple matches found', {
				messageTemplate: `Multiple matching items for item [${itemIndex}]`,
				functionality: 'pairedItem',
				functionOverrides: { message: 'Multiple matches' },
				nodeCause: destNode,
				descriptionKey: isScriptingNode(destNode, that.workflow)
					? 'pairedItemMultipleMatchesCodeNode'
					: 'pairedItemMultipleMatches',
				type: 'paired_item_multiple_matches',
			});
		}

		function normalizeInputs(
			pairedItem: IPairedItemData,
			sourceData: ISourceData | null,
		): [IPairedItemData, ISourceData | null] {
			if (typeof pairedItem === 'number') {
				pairedItem = { item: pairedItem };
			}
			const finalSource = pairedItem.sourceOverwrite || sourceData;
			return [pairedItem, finalSource];
		}

		function pinDataToTask(pinData: INodeExecutionData[] | undefined): ITaskData | undefined {
			if (!pinData) return undefined;
			return {
				data: { main: [pinData] },
				startTime: 0,
				executionTime: 0,
				executionIndex: 0,
				source: [],
			};
		}

		function getTaskData(source: ISourceData): ITaskData | undefined {
			return (
				that.runExecutionData?.resultData?.runData?.[source.previousNode]?.[
					source.previousNodeRun || 0
				] ??
				pinDataToTask(getPinDataIfManualExecution(that.workflow, source.previousNode, that.mode))
			);
		}

		function getNodeOutput(
			taskData: ITaskData | undefined,
			source: ISourceData,
			nodeCause?: string,
		): INodeExecutionData[] {
			const outputIndex = source.previousNodeOutput || 0;
			const outputs = taskData?.data?.main?.[outputIndex];
			if (!outputs) {
				throw createExpressionError('Can’t get data for expression', {
					messageTemplate: 'Missing output data',
					functionOverrides: { message: 'Missing output' },
					nodeCause,
					description: `Expected output #${outputIndex} from node ${source.previousNode}`,
					type: 'internal',
				});
			}
			return outputs;
		}

		const normalizePairedItem = (
			paired: number | IPairedItemData | Array<number | IPairedItemData> | null | undefined,
		): IPairedItemData[] => {
			if (paired === null || paired === undefined) {
				return [];
			}

			const pairedItems = Array.isArray(paired) ? paired : [paired];

			return pairedItems.map((p) => (typeof p === 'number' ? { item: p } : p));
		};

		const getPairedItem = (
			destinationNodeName: string,
			incomingSourceData: ISourceData | null,
			initialPairedItem: IPairedItemData,
			usedMethodName: PairedItemMethod = PAIRED_ITEM_METHOD.$GET_PAIRED_ITEM,
			nodeBeforeLast?: string,
		): INodeExecutionData => {
			// Normalize inputs
			const [pairedItem, sourceData] = normalizeInputs(initialPairedItem, incomingSourceData);

			if (!sourceData) {
				throw createPairedItemNotFound(destinationNodeName, nodeBeforeLast);
			}

			const taskData = getTaskData(sourceData);
			const outputData = getNodeOutput(taskData, sourceData, nodeBeforeLast);
			const item = outputData[pairedItem.item];
			const sourceArray = taskData?.source ?? [];

			// Done: reached the destination node in the ancestry chain
			if (sourceData.previousNode === destinationNodeName) {
				if (pairedItem.item >= outputData.length) {
					throw createInvalidPairedItemError({ nodeName: sourceData.previousNode });
				}

				return item;
			}

			// Normalize paired item to always be IPairedItemData[]
			const nextPairedItems = normalizePairedItem(item.pairedItem);

			if (nextPairedItems.length === 0) {
				throw createMissingPairedItemError(sourceData.previousNode, usedMethodName);
			}

			// Recursively traverse ancestry to find the destination node + paired item
			const results = nextPairedItems.flatMap((nextPairedItem) => {
				const inputIndex = nextPairedItem.input ?? 0;

				if (inputIndex >= sourceArray.length) return [];

				const nextSource = nextPairedItem.sourceOverwrite ?? sourceArray[inputIndex];

				try {
					return createResultOk(
						getPairedItem(
							destinationNodeName,
							nextSource,
							{ ...nextPairedItem, input: inputIndex },
							usedMethodName,
							sourceData.previousNode,
						),
					);
				} catch (error) {
					return createResultError(error);
				}
			});

			if (results.every((result) => !result.ok)) {
				throw results[0].error;
			}

			const matchedItems = results.filter((result) => result.ok).map((result) => result.result);

			if (matchedItems.length === 0) {
				if (sourceArray.length === 0) throw createNoConnectionError(destinationNodeName);
				throw createBranchNotFoundError(sourceData.previousNode, pairedItem.item, nodeBeforeLast);
			}

			const [first, ...rest] = matchedItems;
			if (rest.some((r) => r !== first)) {
				throw createPairedItemMultipleItemsFound(destinationNodeName, pairedItem.item);
			}

			return first;
		};

		const handleFromAi = (
			name: string,
			_description?: string,
			_type: string = 'string',
			defaultValue?: unknown,
		) => {
			const { itemIndex, runIndex } = that;
			if (!name || name === '') {
				throw new ExpressionError("Add a key, e.g. $fromAI('placeholder_name')", {
					runIndex,
					itemIndex,
				});
			}
			const nameValidationRegex = /^[a-zA-Z0-9_-]{0,64}$/;
			if (!nameValidationRegex.test(name)) {
				throw new ExpressionError(
					'Invalid parameter key, must be between 1 and 64 characters long and only contain lowercase letters, uppercase letters, numbers, underscores, and hyphens',
					{
						runIndex,
						itemIndex,
					},
				);
			}
			const inputData =
				that.runExecutionData?.resultData.runData[that.activeNodeName]?.[runIndex].inputOverride;
			const placeholdersDataInputData =
				inputData?.[NodeConnectionTypes.AiTool]?.[0]?.[itemIndex].json;

			if (!placeholdersDataInputData) {
				throw new ExpressionError('No execution data available', {
					runIndex,
					itemIndex,
					type: 'no_execution_data',
				});
			}
			return (
				// TS does not know that the key exists, we need to address this in refactor
				(placeholdersDataInputData?.query as Record<string, unknown>)?.[name] ??
				placeholdersDataInputData?.[name] ??
				defaultValue
			);
		};

		const base = {
			$: (nodeName: string) => {
				if (!nodeName) {
					throw createExpressionError('When calling $(), please specify a node');
				}

				const referencedNode = that.workflow.getNode(nodeName);
				if (referencedNode === null) {
					throw createExpressionError("Referenced node doesn't exist", {
						runIndex: that.runIndex,
						itemIndex: that.itemIndex,
						nodeCause: nodeName,
						descriptionKey: 'nodeNotFound',
					});
				}

				const ensureNodeExecutionData = () => {
					if (
						!that?.runExecutionData?.resultData?.runData.hasOwnProperty(nodeName) &&
						!getPinDataIfManualExecution(that.workflow, nodeName, that.mode)
					) {
						throw createExpressionError(`Node '${nodeName}' hasn't been executed`, {
							messageTemplate:
								'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
							functionality: 'pairedItem',
							descriptionKey: isScriptingNode(nodeName, that.workflow)
								? 'pairedItemNoConnectionCodeNode'
								: 'pairedItemNoConnection',
							type: 'no_execution_data',
							nodeCause: nodeName,
							runIndex: that.runIndex,
							itemIndex: that.itemIndex,
						});
					}
				};

				return new Proxy(
					{},
					{
						has: () => true,
						ownKeys() {
							return [
								PAIRED_ITEM_METHOD.PAIRED_ITEM,
								'isExecuted',
								PAIRED_ITEM_METHOD.ITEM_MATCHING,
								PAIRED_ITEM_METHOD.ITEM,
								'first',
								'last',
								'all',
								'context',
								'params',
							];
						},
						get(target, property, receiver) {
							if (property === 'isProxy') return true;

							if (property === 'isExecuted') {
								return (
									that?.runExecutionData?.resultData?.runData.hasOwnProperty(nodeName) ?? false
								);
							}

							if (
								property === PAIRED_ITEM_METHOD.PAIRED_ITEM ||
								property === PAIRED_ITEM_METHOD.ITEM_MATCHING ||
								property === PAIRED_ITEM_METHOD.ITEM
							) {
								// Before resolving the pairedItem make sure that the requested node comes in the
								// graph before the current one
								const activeNode = that.workflow.getNode(that.activeNodeName);

								let contextNode = that.contextNodeName;
								if (activeNode) {
									const parentMainInputNode = that.workflow.getParentMainInputNode(activeNode);
									contextNode = parentMainInputNode?.name ?? contextNode;
								}
								const parentNodes = that.workflow.getParentNodes(contextNode);
								if (!parentNodes.includes(nodeName)) {
									throw createNoConnectionError(nodeName);
								}

								ensureNodeExecutionData();

								const pairedItemMethod = (itemIndex?: number) => {
									if (itemIndex === undefined) {
										if (property === PAIRED_ITEM_METHOD.ITEM_MATCHING) {
											throw createExpressionError('Missing item index for .itemMatching()', {
												itemIndex,
											});
										}
										itemIndex = that.itemIndex;
									}

									if (!that.connectionInputData.length) {
										const pinnedData = getPinDataIfManualExecution(
											that.workflow,
											nodeName,
											that.mode,
										);

										if (pinnedData) {
											return pinnedData[itemIndex];
										}
									}

									const executionData = that.connectionInputData;
									const input = executionData?.[itemIndex];
									if (!input) {
										throw createExpressionError('Can’t get data for expression', {
											messageTemplate: 'Can’t get data for expression under ‘%%PARAMETER%%’ field',
											functionality: 'pairedItem',
											functionOverrides: {
												description: `Some intermediate nodes between ‘<strong>${nodeName}</strong>‘ and  ‘<strong>${that.activeNodeName}</strong>‘ have not executed yet.`,
												message: 'Can’t get data',
											},
											description: `Some intermediate nodes between ‘<strong>${nodeName}</strong>‘ and  ‘<strong>${that.activeNodeName}</strong>‘ have not executed yet.`,
											causeDetailed: `pairedItem can\'t be found when intermediate nodes between ‘<strong>${nodeName}</strong>‘ and  ‘<strong>${that.activeNodeName}</strong> have not executed yet.`,
											itemIndex,
											type: 'paired_item_intermediate_nodes',
										});
									}

									// As we operate on the incoming item we can be sure that pairedItem is not an
									// array. After all can it only come from exactly one previous node via a certain
									// input. For that reason do we not have to consider the array case.
									const pairedItem = input.pairedItem as IPairedItemData;

									if (pairedItem === undefined) {
										throw createMissingPairedItemError(that.activeNodeName, property);
									}

									if (!that.executeData?.source) {
										throw createExpressionError('Can’t get data for expression', {
											messageTemplate: 'Can’t get data for expression under ‘%%PARAMETER%%’ field',
											functionality: 'pairedItem',
											functionOverrides: {
												message: 'Can’t get data',
											},
											description:
												'Apologies, this is an internal error. See details for more information',
											causeDetailed: 'Missing sourceData (probably an internal error)',
											itemIndex,
										});
									}

									const sourceData: ISourceData | null =
										that.executeData.source.main[pairedItem.input || 0] ??
										that.executeData.source.main[0];

									return getPairedItem(nodeName, sourceData, pairedItem, property);
								};

								if (property === PAIRED_ITEM_METHOD.ITEM) {
									return pairedItemMethod();
								}
								return pairedItemMethod;
							}

							if (property === 'first') {
								ensureNodeExecutionData();
								return (branchIndex?: number, runIndex?: number) => {
									branchIndex =
										branchIndex ??
										// default to the output the active node is connected to
										that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName)
											?.sourceIndex ??
										0;
									const executionData = that.getNodeExecutionOrPinnedData({
										nodeName,
										branchIndex,
										runIndex,
									});
									if (executionData[0]) return executionData[0];
									return undefined;
								};
							}
							if (property === 'last') {
								ensureNodeExecutionData();
								return (branchIndex?: number, runIndex?: number) => {
									branchIndex =
										branchIndex ??
										// default to the output the active node is connected to
										that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName)
											?.sourceIndex ??
										0;
									const executionData = that.getNodeExecutionOrPinnedData({
										nodeName,
										branchIndex,
										runIndex,
									});
									if (!executionData.length) return undefined;
									if (executionData[executionData.length - 1]) {
										return executionData[executionData.length - 1];
									}
									return undefined;
								};
							}
							if (property === 'all') {
								ensureNodeExecutionData();
								return (branchIndex?: number, runIndex?: number) => {
									branchIndex =
										branchIndex ??
										// default to the output the active node is connected to
										that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName)
											?.sourceIndex ??
										0;
									return that.getNodeExecutionOrPinnedData({ nodeName, branchIndex, runIndex });
								};
							}
							if (property === 'context') {
								return that.nodeContextGetter(nodeName);
							}
							if (property === 'params') {
								return that.workflow.getNode(nodeName)?.parameters;
							}
							return Reflect.get(target, property, receiver);
						},
					},
				);
			},

			$input: new Proxy({} as ProxyInput, {
				has: () => true,
				ownKeys() {
					return ['all', 'context', 'first', 'item', 'last', 'params'];
				},
				getOwnPropertyDescriptor() {
					return {
						enumerable: true,
						configurable: true,
					};
				},
				get(target, property, receiver) {
					if (property === 'isProxy') return true;

					if (that.connectionInputData.length === 0) {
						throw createExpressionError('No execution data available', {
							runIndex: that.runIndex,
							itemIndex: that.itemIndex,
							type: 'no_execution_data',
						});
					}

					if (property === 'item') {
						return that.connectionInputData[that.itemIndex];
					}
					if (property === 'first') {
						return (...args: unknown[]) => {
							if (args.length) {
								throw createExpressionError('$input.first() should have no arguments');
							}

							const result = that.connectionInputData;
							if (result[0]) {
								return result[0];
							}
							return undefined;
						};
					}
					if (property === 'last') {
						return (...args: unknown[]) => {
							if (args.length) {
								throw createExpressionError('$input.last() should have no arguments');
							}

							const result = that.connectionInputData;
							if (result.length && result[result.length - 1]) {
								return result[result.length - 1];
							}
							return undefined;
						};
					}
					if (property === 'all') {
						return () => {
							const result = that.connectionInputData;
							if (result.length) {
								return result;
							}
							return [];
						};
					}

					if (['context', 'params'].includes(property as string)) {
						// For the following properties we need the source data so fail in case it is missing
						// for some reason (even though that should actually never happen)
						if (!that.executeData?.source) {
							throw createExpressionError('Can’t get data for expression', {
								messageTemplate: 'Can’t get data for expression under ‘%%PARAMETER%%’ field',
								functionOverrides: {
									message: 'Can’t get data',
								},
								description:
									'Apologies, this is an internal error. See details for more information',
								causeDetailed: 'Missing sourceData (probably an internal error)',
								runIndex: that.runIndex,
							});
						}

						const sourceData: ISourceData = that.executeData.source.main[0] as ISourceData;

						if (property === 'context') {
							return that.nodeContextGetter(sourceData.previousNode);
						}
						if (property === 'params') {
							return that.workflow.getNode(sourceData.previousNode)?.parameters;
						}
					}

					return Reflect.get(target, property, receiver);
				},
			}),

			$binary: {}, // Placeholder
			$data: {}, // Placeholder
			$env: createEnvProvider(
				that.runIndex,
				that.itemIndex,
				that.envProviderState ?? createEnvProviderState(),
			),
			$evaluateExpression: (expression: string, itemIndex?: number) => {
				itemIndex = itemIndex || that.itemIndex;
				return that.workflow.expression.getParameterValue(
					`=${expression}`,
					that.runExecutionData,
					that.runIndex,
					itemIndex,
					that.activeNodeName,
					that.connectionInputData,
					that.mode,
					that.additionalKeys,
					that.executeData,
					false,
					{},
					that.contextNodeName,
				);
			},
			$item: (itemIndex: number, runIndex?: number) => {
				const defaultReturnRunIndex = runIndex === undefined ? -1 : runIndex;
				const dataProxy = new WorkflowDataProxy(
					this.workflow,
					this.runExecutionData,
					this.runIndex,
					itemIndex,
					this.activeNodeName,
					this.connectionInputData,
					that.siblingParameters,
					that.mode,
					that.additionalKeys,
					that.executeData,
					defaultReturnRunIndex,
					{},
					that.contextNodeName,
				);
				return dataProxy.getDataProxy();
			},
			$fromAI: handleFromAi,
			// Make sure mis-capitalized $fromAI is handled correctly even though we don't auto-complete it
			$fromai: handleFromAi,
			$fromAi: handleFromAi,
			$items: (nodeName?: string, outputIndex?: number, runIndex?: number) => {
				if (nodeName === undefined) {
					nodeName = (that.prevNodeGetter() as { name: string }).name;
					const node = this.workflow.nodes[nodeName];
					let result = that.connectionInputData;
					if (node.executeOnce === true) {
						result = result.slice(0, 1);
					}
					if (result.length) {
						return result;
					}
					return [];
				}

				outputIndex = outputIndex || 0;
				runIndex = runIndex === undefined ? -1 : runIndex;

				return that.getNodeExecutionData(nodeName, false, outputIndex, runIndex);
			},
			$json: {}, // Placeholder
			$node: this.nodeGetter(),
			$self: this.selfGetter(),
			$parameter: this.nodeParameterGetter(this.activeNodeName),
			$rawParameter: this.nodeParameterGetter(this.activeNodeName, false),
			$prevNode: this.prevNodeGetter(),
			$runIndex: this.runIndex,
			$mode: this.mode,
			$workflow: this.workflowGetter(),
			$itemIndex: this.itemIndex,
			$now: DateTime.now(),
			$today: DateTime.now().set({ hour: 0, minute: 0, second: 0, millisecond: 0 }),
			$jmesPath: jmespathWrapper,

			DateTime,

			Interval,

			Duration,
			...that.additionalKeys,
			$getPairedItem: getPairedItem,

			// deprecated
			$jmespath: jmespathWrapper,
			$position: this.itemIndex,
			$thisItem: that.connectionInputData[that.itemIndex],
			$thisItemIndex: this.itemIndex,
			$thisRunIndex: this.runIndex,
			$nodeVersion: that.workflow.getNode(that.activeNodeName)?.typeVersion,
			$nodeId: that.workflow.getNode(that.activeNodeName)?.id,
			$agentInfo: this.agentInfo(),
			$webhookId: that.workflow.getNode(that.activeNodeName)?.webhookId,
		};
		const throwOnMissingExecutionData = opts?.throwOnMissingExecutionData ?? true;

		return new Proxy(base, {
			has: () => true,
			get(target, name, receiver) {
				if (name === 'isProxy') return true;

				if (['$data', '$json'].includes(name as string)) {
					return that.nodeDataGetter(that.contextNodeName, true, throwOnMissingExecutionData)?.json;
				}
				if (name === '$binary') {
					return that.nodeDataGetter(that.contextNodeName, true, throwOnMissingExecutionData)
						?.binary;
				}

				return Reflect.get(target, name, receiver);
			},
		});
	}
}



================================================
FILE: packages/workflow/src/workflow.ts
================================================
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-for-in-array */
import {
	getConnectedNodes,
	getChildNodes,
	getParentNodes,
	mapConnectionsByDestination,
} from './common';

import {
	MANUAL_CHAT_TRIGGER_LANGCHAIN_NODE_TYPE,
	NODES_WITH_RENAMABLE_CONTENT,
	NODES_WITH_RENAMABLE_FORM_HTML_CONTENT,
	NODES_WITH_RENAMEABLE_TOPLEVEL_HTML_CONTENT,
	STARTING_NODE_TYPES,
} from './constants';
import { UserError } from './errors';
import { ApplicationError } from '@n8n/errors';
import { Expression } from './expression';
import { getGlobalState } from './global-state';
import type {
	IConnections,
	INode,
	INodeExecutionData,
	INodeParameters,
	INodes,
	INodeType,
	INodeTypes,
	IPinData,
	IWorkflowSettings,
	IConnection,
	IConnectedNode,
	IDataObject,
	INodeConnection,
	IObservableObject,
	NodeParameterValueType,
	NodeConnectionType,
} from './interfaces';
import { NodeConnectionTypes } from './interfaces';
import * as NodeHelpers from './node-helpers';
import { renameFormFields } from './node-parameters/rename-node-utils';
import { applyAccessPatterns } from './node-reference-parser-utils';
import * as ObservableObject from './observable-object';

function dedupe<T>(arr: T[]): T[] {
	return [...new Set(arr)];
}

export interface WorkflowParameters {
	id?: string;
	name?: string;
	nodes: INode[];
	connections: IConnections;
	active: boolean;
	nodeTypes: INodeTypes;
	staticData?: IDataObject;
	settings?: IWorkflowSettings;
	pinData?: IPinData;
}

export class Workflow {
	id: string;

	name: string | undefined;

	nodes: INodes = {};

	connectionsBySourceNode: IConnections = {};

	connectionsByDestinationNode: IConnections = {};

	nodeTypes: INodeTypes;

	expression: Expression;

	active: boolean;

	settings: IWorkflowSettings = {};

	readonly timezone: string;

	// To save workflow specific static data like for example
	// ids of registered webhooks of nodes
	staticData: IDataObject;

	testStaticData: IDataObject | undefined;

	pinData?: IPinData;

	constructor(parameters: WorkflowParameters) {
		this.id = parameters.id as string; // @tech_debt Ensure this is not optional
		this.name = parameters.name;
		this.nodeTypes = parameters.nodeTypes;

		let nodeType: INodeType | undefined;
		for (const node of parameters.nodes) {
			nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);

			if (nodeType === undefined) {
				// Go on to next node when its type is not known.
				// For now do not error because that causes problems with
				// expression resolution also then when the unknown node
				// does not get used.
				continue;
				// throw new ApplicationError(`Node with unknown node type`, {
				// 	tags: { nodeType: node.type },
				// 	extra: { node },
				// });
			}

			// Add default values
			const nodeParameters = NodeHelpers.getNodeParameters(
				nodeType.description.properties,
				node.parameters,
				true,
				false,
				node,
				nodeType.description,
			);
			node.parameters = nodeParameters !== null ? nodeParameters : {};
		}

		this.setNodes(parameters.nodes);
		this.setConnections(parameters.connections);
		this.setPinData(parameters.pinData);
		this.setSettings(parameters.settings ?? {});

		this.active = parameters.active || false;

		this.staticData = ObservableObject.create(parameters.staticData || {}, undefined, {
			ignoreEmptyOnFirstChild: true,
		});

		this.timezone = this.settings.timezone ?? getGlobalState().defaultTimezone;

		this.expression = new Expression(this);
	}

	// Save nodes in workflow as object to be able to get the nodes easily by their name.
	setNodes(nodes: INode[]) {
		this.nodes = {};
		for (const node of nodes) {
			this.nodes[node.name] = node;
		}
	}

	setConnections(connections: IConnections) {
		this.connectionsBySourceNode = connections;
		this.connectionsByDestinationNode = mapConnectionsByDestination(this.connectionsBySourceNode);
	}

	setPinData(pinData: IPinData | undefined) {
		this.pinData = pinData;
	}

	setSettings(settings: IWorkflowSettings) {
		this.settings = settings;
	}

	overrideStaticData(staticData?: IDataObject) {
		this.staticData = ObservableObject.create(staticData || {}, undefined, {
			ignoreEmptyOnFirstChild: true,
		});
		this.staticData.__dataChanged = true;
	}

	static getConnectionsByDestination(connections: IConnections): IConnections {
		const returnConnection: IConnections = {};

		let connectionInfo;
		let maxIndex: number;
		for (const sourceNode in connections) {
			if (!connections.hasOwnProperty(sourceNode)) {
				continue;
			}

			for (const type of Object.keys(connections[sourceNode]) as NodeConnectionType[]) {
				if (!connections[sourceNode].hasOwnProperty(type)) {
					continue;
				}
				for (const inputIndex in connections[sourceNode][type]) {
					if (!connections[sourceNode][type].hasOwnProperty(inputIndex)) {
						continue;
					}

					for (connectionInfo of connections[sourceNode][type][inputIndex] ?? []) {
						if (!returnConnection.hasOwnProperty(connectionInfo.node)) {
							returnConnection[connectionInfo.node] = {};
						}
						if (!returnConnection[connectionInfo.node].hasOwnProperty(connectionInfo.type)) {
							returnConnection[connectionInfo.node][connectionInfo.type] = [];
						}

						maxIndex = returnConnection[connectionInfo.node][connectionInfo.type].length - 1;
						for (let j = maxIndex; j < connectionInfo.index; j++) {
							returnConnection[connectionInfo.node][connectionInfo.type].push([]);
						}

						returnConnection[connectionInfo.node][connectionInfo.type][connectionInfo.index]?.push({
							node: sourceNode,
							type,
							index: parseInt(inputIndex, 10),
						});
					}
				}
			}
		}

		return returnConnection;
	}

	/**
	 * Returns the static data of the workflow.
	 * It gets saved with the workflow and will be the same for
	 * all workflow-executions.
	 *
	 * @param {string} type The type of data to return ("global"|"node")
	 * @param {INode} [node] If type is set to "node" then the node has to be provided
	 */
	getStaticData(type: string, node?: INode): IDataObject {
		let key: string;
		if (type === 'global') {
			key = 'global';
		} else if (type === 'node') {
			if (node === undefined) {
				throw new ApplicationError(
					'The request data of context type "node" the node parameter has to be set!',
				);
			}
			key = `node:${node.name}`;
		} else {
			throw new ApplicationError('Unknown context type. Only `global` and `node` are supported.', {
				extra: { contextType: type },
			});
		}

		if (this.testStaticData?.[key]) return this.testStaticData[key] as IDataObject;

		if (this.staticData[key] === undefined) {
			// Create it as ObservableObject that we can easily check if the data changed
			// to know if the workflow with its data has to be saved afterwards or not.
			this.staticData[key] = ObservableObject.create({}, this.staticData as IObservableObject);
		}

		return this.staticData[key] as IDataObject;
	}

	setTestStaticData(testStaticData: IDataObject) {
		this.testStaticData = testStaticData;
	}

	/**
	 * Returns all the trigger nodes in the workflow.
	 *
	 */
	getTriggerNodes(): INode[] {
		return this.queryNodes((nodeType: INodeType) => !!nodeType.trigger);
	}

	/**
	 * Returns all the poll nodes in the workflow
	 *
	 */
	getPollNodes(): INode[] {
		return this.queryNodes((nodeType: INodeType) => !!nodeType.poll);
	}

	/**
	 * Returns all the nodes in the workflow for which the given
	 * checkFunction return true
	 *
	 * @param {(nodeType: INodeType) => boolean} checkFunction
	 */
	queryNodes(checkFunction: (nodeType: INodeType) => boolean): INode[] {
		const returnNodes: INode[] = [];

		// Check if it has any of them
		let node: INode;
		let nodeType: INodeType | undefined;

		for (const nodeName of Object.keys(this.nodes)) {
			node = this.nodes[nodeName];

			if (node.disabled === true) {
				continue;
			}

			nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);

			if (nodeType !== undefined && checkFunction(nodeType)) {
				returnNodes.push(node);
			}
		}

		return returnNodes;
	}

	/**
	 * Returns the node with the given name if it exists else null
	 *
	 * @param {string} nodeName Name of the node to return
	 */
	getNode(nodeName: string): INode | null {
		return this.nodes[nodeName] ?? null;
	}

	/**
	 * Returns the nodes with the given names if they exist.
	 * If a node cannot be found it will be ignored, meaning the returned array
	 * of nodes can be smaller than the array of names.
	 */
	getNodes(nodeNames: string[]): INode[] {
		const nodes: INode[] = [];
		for (const name of nodeNames) {
			const node = this.getNode(name);
			if (!node) {
				console.warn(
					`Could not find a node with the name ${name} in the workflow. This was passed in as a dirty node name.`,
				);
				continue;
			}
			nodes.push(node);
		}

		return nodes;
	}

	/**
	 * Returns the pinData of the node with the given name if it exists
	 *
	 * @param {string} nodeName Name of the node to return the pinData of
	 */
	getPinDataOfNode(nodeName: string): INodeExecutionData[] | undefined {
		return this.pinData ? this.pinData[nodeName] : undefined;
	}

	renameNodeInParameterValue(
		parameterValue: NodeParameterValueType,
		currentName: string,
		newName: string,
		{ hasRenamableContent } = { hasRenamableContent: false },
	): NodeParameterValueType {
		if (typeof parameterValue !== 'object') {
			// Reached the actual value
			if (
				typeof parameterValue === 'string' &&
				(parameterValue.charAt(0) === '=' || hasRenamableContent)
			) {
				parameterValue = applyAccessPatterns(parameterValue, currentName, newName);
			}

			return parameterValue;
		}

		if (Array.isArray(parameterValue)) {
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			const returnArray: any[] = [];

			for (const currentValue of parameterValue) {
				returnArray.push(
					this.renameNodeInParameterValue(
						currentValue as NodeParameterValueType,
						currentName,
						newName,
					),
				);
			}

			return returnArray;
		}

		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const returnData: any = {};

		for (const parameterName of Object.keys(parameterValue || {})) {
			returnData[parameterName] = this.renameNodeInParameterValue(
				parameterValue![parameterName as keyof typeof parameterValue],
				currentName,
				newName,
				{ hasRenamableContent },
			);
		}

		return returnData;
	}

	/**
	 * Rename a node in the workflow
	 *
	 * @param {string} currentName The current name of the node
	 * @param {string} newName The new name
	 */
	renameNode(currentName: string, newName: string) {
		// These keys are excluded to prevent accidental modification of inherited properties and
		// to avoid any issues related to JavaScript's built-in methods that can cause unexpected behavior
		const restrictedKeys = [
			'hasOwnProperty',
			'isPrototypeOf',
			'propertyIsEnumerable',
			'toLocaleString',
			'toString',
			'valueOf',
			'constructor',
			'prototype',
			'__proto__',
			'__defineGetter__',
			'__defineSetter__',
			'__lookupGetter__',
			'__lookupSetter__',
		];

		if (restrictedKeys.map((k) => k.toLowerCase()).includes(newName.toLowerCase())) {
			throw new UserError(`Node name "${newName}" is a restricted name.`, {
				description: `Node names cannot be any of the following: ${restrictedKeys.join(', ')}`,
			});
		}
		// Rename the node itself
		if (this.nodes[currentName] !== undefined) {
			this.nodes[newName] = this.nodes[currentName];
			this.nodes[newName].name = newName;
			delete this.nodes[currentName];
		}

		// Update the expressions which reference the node
		// with its old name
		for (const node of Object.values(this.nodes)) {
			node.parameters = this.renameNodeInParameterValue(
				node.parameters,
				currentName,
				newName,
			) as INodeParameters;

			if (NODES_WITH_RENAMABLE_CONTENT.has(node.type)) {
				node.parameters.jsCode = this.renameNodeInParameterValue(
					node.parameters.jsCode,
					currentName,
					newName,
					{ hasRenamableContent: true },
				);
			}
			if (NODES_WITH_RENAMEABLE_TOPLEVEL_HTML_CONTENT.has(node.type)) {
				node.parameters.html = this.renameNodeInParameterValue(
					node.parameters.html,
					currentName,
					newName,
					{ hasRenamableContent: true },
				);
			}
			if (NODES_WITH_RENAMABLE_FORM_HTML_CONTENT.has(node.type)) {
				renameFormFields(node, (p) =>
					this.renameNodeInParameterValue(p, currentName, newName, {
						hasRenamableContent: true,
					}),
				);
			}
		}

		// Change all source connections
		if (this.connectionsBySourceNode.hasOwnProperty(currentName)) {
			this.connectionsBySourceNode[newName] = this.connectionsBySourceNode[currentName];
			delete this.connectionsBySourceNode[currentName];
		}

		// Change all destination connections
		let sourceNode: string;
		let type: string;
		let sourceIndex: string;
		let connectionIndex: string;
		let connectionData: IConnection | undefined;
		for (sourceNode of Object.keys(this.connectionsBySourceNode)) {
			for (type of Object.keys(this.connectionsBySourceNode[sourceNode])) {
				for (sourceIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type])) {
					for (connectionIndex of Object.keys(
						this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)] || [],
					)) {
						connectionData =
							this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)]?.[
								parseInt(connectionIndex, 10)
							];
						if (connectionData?.node === currentName) {
							connectionData.node = newName;
						}
					}
				}
			}
		}
	}

	/**
	 * Finds the highest parent nodes of the node with the given name
	 *
	 * @param {NodeConnectionType} [type='main']
	 */
	getHighestNode(
		nodeName: string,
		nodeConnectionIndex?: number,
		checkedNodes?: string[],
	): string[] {
		const currentHighest: string[] = [];
		if (this.nodes[nodeName].disabled === false) {
			// If the current node is not disabled itself is the highest
			currentHighest.push(nodeName);
		}

		if (!this.connectionsByDestinationNode.hasOwnProperty(nodeName)) {
			// Node does not have incoming connections
			return currentHighest;
		}

		if (!this.connectionsByDestinationNode[nodeName].hasOwnProperty(NodeConnectionTypes.Main)) {
			// Node does not have incoming connections of given type
			return currentHighest;
		}

		checkedNodes = checkedNodes || [];

		if (checkedNodes.includes(nodeName)) {
			// Node got checked already before
			return currentHighest;
		}

		checkedNodes.push(nodeName);

		const returnNodes: string[] = [];
		let addNodes: string[];

		let connectionsByIndex: IConnection[] | null;
		for (
			let connectionIndex = 0;
			connectionIndex <
			this.connectionsByDestinationNode[nodeName][NodeConnectionTypes.Main].length;
			connectionIndex++
		) {
			if (nodeConnectionIndex !== undefined && nodeConnectionIndex !== connectionIndex) {
				// If a connection-index is given ignore all other ones
				continue;
			}
			connectionsByIndex =
				this.connectionsByDestinationNode[nodeName][NodeConnectionTypes.Main][connectionIndex];

			connectionsByIndex?.forEach((connection) => {
				if (checkedNodes.includes(connection.node)) {
					// Node got checked already before
					return;
				}

				// Ignore connections for nodes that don't exist in this workflow
				if (!(connection.node in this.nodes)) return;

				addNodes = this.getHighestNode(connection.node, undefined, checkedNodes);

				if (addNodes.length === 0) {
					// The checked node does not have any further parents so add it
					// if it is not disabled
					if (this.nodes[connection.node].disabled !== true) {
						addNodes = [connection.node];
					}
				}

				addNodes.forEach((name) => {
					// Only add if node is not on the list already anyway
					if (returnNodes.indexOf(name) === -1) {
						returnNodes.push(name);
					}
				});
			});
		}

		return returnNodes;
	}

	/**
	 * Returns all the after the given one
	 *
	 * @param {string} [type='main']
	 * @param {*} [depth=-1]
	 */
	getChildNodes(
		nodeName: string,
		type: NodeConnectionType | 'ALL' | 'ALL_NON_MAIN' = NodeConnectionTypes.Main,
		depth = -1,
	): string[] {
		return getChildNodes(this.connectionsBySourceNode, nodeName, type, depth);
	}

	/**
	 * Returns all the nodes before the given one
	 *
	 * @param {NodeConnectionType} [type='main']
	 * @param {*} [depth=-1]
	 */
	getParentNodes(
		nodeName: string,
		type: NodeConnectionType | 'ALL' | 'ALL_NON_MAIN' = NodeConnectionTypes.Main,
		depth = -1,
	): string[] {
		return getParentNodes(this.connectionsByDestinationNode, nodeName, type, depth);
	}

	/**
	 * Gets all the nodes which are connected nodes starting from
	 * the given one
	 *
	 * @param {NodeConnectionType} [type='main']
	 * @param {*} [depth=-1]
	 */
	getConnectedNodes(
		connections: IConnections,
		nodeName: string,
		connectionType: NodeConnectionType | 'ALL' | 'ALL_NON_MAIN' = NodeConnectionTypes.Main,
		depth = -1,
		checkedNodesIncoming?: string[],
	): string[] {
		return getConnectedNodes(connections, nodeName, connectionType, depth, checkedNodesIncoming);
	}

	/**
	 * Returns all the nodes before the given one
	 *
	 * @param {*} [maxDepth=-1]
	 */
	getParentNodesByDepth(nodeName: string, maxDepth = -1): IConnectedNode[] {
		return this.searchNodesBFS(this.connectionsByDestinationNode, nodeName, maxDepth);
	}

	/**
	 * Gets all the nodes which are connected nodes starting from
	 * the given one
	 * Uses BFS traversal
	 *
	 * @param {*} [maxDepth=-1]
	 */
	searchNodesBFS(connections: IConnections, sourceNode: string, maxDepth = -1): IConnectedNode[] {
		const returnConns: IConnectedNode[] = [];

		const type: NodeConnectionType = NodeConnectionTypes.Main;
		let queue: IConnectedNode[] = [];
		queue.push({
			name: sourceNode,
			depth: 0,
			indicies: [],
		});

		const visited: { [key: string]: IConnectedNode } = {};

		let depth = 0;
		while (queue.length > 0) {
			if (maxDepth !== -1 && depth > maxDepth) {
				break;
			}
			depth++;

			const toAdd = [...queue];
			queue = [];

			toAdd.forEach((curr) => {
				if (visited[curr.name]) {
					visited[curr.name].indicies = dedupe(visited[curr.name].indicies.concat(curr.indicies));
					return;
				}

				visited[curr.name] = curr;
				if (curr.name !== sourceNode) {
					returnConns.push(curr);
				}

				if (
					!connections.hasOwnProperty(curr.name) ||
					!connections[curr.name].hasOwnProperty(type)
				) {
					return;
				}

				connections[curr.name][type].forEach((connectionsByIndex) => {
					connectionsByIndex?.forEach((connection) => {
						queue.push({
							name: connection.node,
							indicies: [connection.index],
							depth,
						});
					});
				});
			});
		}

		return returnConns;
	}

	getParentMainInputNode(node: INode): INode {
		if (node) {
			const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
			if (!nodeType?.description.outputs) {
				return node;
			}

			const outputs = NodeHelpers.getNodeOutputs(this, node, nodeType.description);
			const nonMainConnectionTypes: NodeConnectionType[] = [];

			// Defensive check: NodeHelpers.getNodeOutputs should always return an array,
			// but in some edge cases (particularly during testing with incomplete node setup),
			// it may return undefined or null
			if (Array.isArray(outputs)) {
				for (const output of outputs) {
					const type = typeof output === 'string' ? output : output.type;
					if (type !== NodeConnectionTypes.Main) {
						nonMainConnectionTypes.push(type);
					}
				}
			}

			// Sort for deterministic behavior: prevents non-deterministic selection when multiple
			// non-main outputs exist (AI agents with multiple tools). Object.keys() ordering
			// can vary across runs, causing inconsistent first-choice selection.
			nonMainConnectionTypes.sort();

			if (nonMainConnectionTypes.length > 0) {
				const nonMainNodesConnected: string[] = [];
				const nodeConnections = this.connectionsBySourceNode[node.name];

				for (const type of nonMainConnectionTypes) {
					// Only include connection types that exist in actual execution data
					if (nodeConnections?.[type]) {
						const childNodes = this.getChildNodes(node.name, type);
						if (childNodes.length > 0) {
							nonMainNodesConnected.push(...childNodes);
						}
					}
				}

				if (nonMainNodesConnected.length) {
					// Sort for deterministic behavior, then get first node
					nonMainNodesConnected.sort();
					const returnNode = this.getNode(nonMainNodesConnected[0]);
					if (!returnNode) {
						throw new ApplicationError(`Node "${nonMainNodesConnected[0]}" not found`);
					}
					return this.getParentMainInputNode(returnNode);
				}
			}
		}

		return node;
	}

	/**
	 * Returns via which output of the parent-node and index the current node
	 * they are connected
	 *
	 * @param {string} nodeName The node to check how it is connected with parent node
	 * @param {string} parentNodeName The parent node to get the output index of
	 * @param {string} [type='main']
	 */
	getNodeConnectionIndexes(
		nodeName: string,
		parentNodeName: string,
		type: NodeConnectionType = NodeConnectionTypes.Main,
	): INodeConnection | undefined {
		// This method has been optimized for performance. If you make any changes to it,
		// make sure the performance is not degraded.
		const parentNode = this.getNode(parentNodeName);
		if (parentNode === null) {
			return undefined;
		}

		const visitedNodes = new Set<string>();
		const queue: string[] = [nodeName];

		// Cache the connections by destination node to avoid reference lookups
		const connectionsByDest = this.connectionsByDestinationNode;

		while (queue.length > 0) {
			const currentNodeName = queue.shift()!;

			if (visitedNodes.has(currentNodeName)) {
				continue;
			}

			visitedNodes.add(currentNodeName);

			const typeConnections = connectionsByDest[currentNodeName]?.[type];
			if (!typeConnections) {
				continue;
			}

			for (
				let typedConnectionIdx = 0;
				typedConnectionIdx < typeConnections.length;
				typedConnectionIdx++
			) {
				const connectionsByIndex = typeConnections[typedConnectionIdx];
				if (!connectionsByIndex) {
					continue;
				}

				for (
					let destinationIndex = 0;
					destinationIndex < connectionsByIndex.length;
					destinationIndex++
				) {
					const connection = connectionsByIndex[destinationIndex];

					if (parentNodeName === connection.node) {
						return {
							sourceIndex: connection.index,
							destinationIndex,
						};
					}

					if (!visitedNodes.has(connection.node)) {
						queue.push(connection.node);
					}
				}
			}
		}

		return undefined;
	}

	/**
	 * Returns from which of the given nodes the workflow should get started from
	 *
	 * @param {string[]} nodeNames The potential start nodes
	 */
	__getStartNode(nodeNames: string[]): INode | undefined {
		// Check if there are any trigger or poll nodes and then return the first one
		let node: INode;
		let nodeType: INodeType;

		if (nodeNames.length === 1) {
			node = this.nodes[nodeNames[0]];
			if (node && !node.disabled) {
				return node;
			}
		}

		for (const nodeName of nodeNames) {
			node = this.nodes[nodeName];
			nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);

			// TODO: Identify later differently
			if (nodeType.description.name === MANUAL_CHAT_TRIGGER_LANGCHAIN_NODE_TYPE) {
				continue;
			}

			if (nodeType && (nodeType.trigger !== undefined || nodeType.poll !== undefined)) {
				if (node.disabled === true) {
					continue;
				}
				return node;
			}
		}

		const sortedNodeNames = Object.values(this.nodes)
			.sort((a, b) => STARTING_NODE_TYPES.indexOf(a.type) - STARTING_NODE_TYPES.indexOf(b.type))
			.map((n) => n.name);

		for (const nodeName of sortedNodeNames) {
			node = this.nodes[nodeName];
			if (STARTING_NODE_TYPES.includes(node.type)) {
				if (node.disabled === true) {
					continue;
				}
				return node;
			}
		}

		return undefined;
	}

	/**
	 * Returns the start node to start the workflow from
	 *
	 */
	getStartNode(destinationNode?: string): INode | undefined {
		if (destinationNode) {
			// Find the highest parent nodes of the given one
			const nodeNames = this.getHighestNode(destinationNode);

			if (nodeNames.length === 0) {
				// If no parent nodes have been found then only the destination-node
				// is in the tree so add that one
				nodeNames.push(destinationNode);
			}

			// Check which node to return as start node
			const node = this.__getStartNode(nodeNames);
			if (node !== undefined) {
				return node;
			}

			// If none of the above did find anything simply return the
			// first parent node in the list
			return this.nodes[nodeNames[0]];
		}

		return this.__getStartNode(Object.keys(this.nodes));
	}

	getConnectionsBetweenNodes(
		sources: string[],
		targets: string[],
	): Array<[IConnection, IConnection]> {
		const result: Array<[IConnection, IConnection]> = [];

		for (const source of sources) {
			for (const type of Object.keys(this.connectionsBySourceNode[source] ?? {})) {
				for (const sourceIndex of Object.keys(this.connectionsBySourceNode[source][type])) {
					for (const connectionIndex of Object.keys(
						this.connectionsBySourceNode[source][type][parseInt(sourceIndex, 10)] ?? [],
					)) {
						const targetConnectionData =
							this.connectionsBySourceNode[source][type][parseInt(sourceIndex, 10)]?.[
								parseInt(connectionIndex, 10)
							];
						if (targetConnectionData && targets.includes(targetConnectionData?.node)) {
							result.push([
								{
									node: source,
									index: parseInt(sourceIndex, 10),
									type: type as NodeConnectionType,
								},
								targetConnectionData,
							]);
						}
					}
				}
			}
		}

		return result;
	}
}



================================================
FILE: packages/workflow/src/common/get-child-nodes.ts
================================================
import { getConnectedNodes } from './get-connected-nodes';
import { NodeConnectionTypes } from '../interfaces';
import type { IConnections, NodeConnectionType } from '../interfaces';

export function getChildNodes(
	connectionsBySourceNode: IConnections,
	nodeName: string,
	type: NodeConnectionType | 'ALL' | 'ALL_NON_MAIN' = NodeConnectionTypes.Main,
	depth = -1,
): string[] {
	return getConnectedNodes(connectionsBySourceNode, nodeName, type, depth);
}



================================================
FILE: packages/workflow/src/common/get-connected-nodes.ts
================================================
import { NodeConnectionTypes } from '../interfaces';
import type { IConnections, NodeConnectionType } from '../interfaces';

/**
 * Gets all the nodes which are connected nodes starting from
 * the given one
 *
 * @param {NodeConnectionType} [type='main']
 * @param {*} [depth=-1]
 */
export function getConnectedNodes(
	connections: IConnections,
	nodeName: string,
	connectionType: NodeConnectionType | 'ALL' | 'ALL_NON_MAIN' = NodeConnectionTypes.Main,
	depth = -1,
	checkedNodesIncoming?: string[],
): string[] {
	const newDepth = depth === -1 ? depth : depth - 1;
	if (depth === 0) {
		// Reached max depth
		return [];
	}

	if (!connections.hasOwnProperty(nodeName)) {
		// Node does not have incoming connections
		return [];
	}

	let types: NodeConnectionType[];
	if (connectionType === 'ALL') {
		types = Object.keys(connections[nodeName]) as NodeConnectionType[];
	} else if (connectionType === 'ALL_NON_MAIN') {
		types = Object.keys(connections[nodeName]).filter(
			(type) => type !== 'main',
		) as NodeConnectionType[];
	} else {
		types = [connectionType];
	}

	let addNodes: string[];
	let nodeIndex: number;
	let i: number;
	let parentNodeName: string;
	const returnNodes: string[] = [];

	types.forEach((type) => {
		if (!connections[nodeName].hasOwnProperty(type)) {
			// Node does not have incoming connections of given type
			return;
		}

		const checkedNodes = checkedNodesIncoming ? [...checkedNodesIncoming] : [];

		if (checkedNodes.includes(nodeName)) {
			// Node got checked already before
			return;
		}

		checkedNodes.push(nodeName);

		connections[nodeName][type].forEach((connectionsByIndex) => {
			connectionsByIndex?.forEach((connection) => {
				if (checkedNodes.includes(connection.node)) {
					// Node got checked already before
					return;
				}

				returnNodes.unshift(connection.node);

				addNodes = getConnectedNodes(
					connections,
					connection.node,
					connectionType,
					newDepth,
					checkedNodes,
				);

				for (i = addNodes.length; i--; i > 0) {
					// Because nodes can have multiple parents it is possible that
					// parts of the tree is parent of both and to not add nodes
					// twice check first if they already got added before.
					parentNodeName = addNodes[i];
					nodeIndex = returnNodes.indexOf(parentNodeName);

					if (nodeIndex !== -1) {
						// Node got found before so remove it from current location
						// that node-order stays correct
						returnNodes.splice(nodeIndex, 1);
					}

					returnNodes.unshift(parentNodeName);
				}
			});
		});
	});

	return returnNodes;
}



================================================
FILE: packages/workflow/src/common/get-node-by-name.ts
================================================
import type { INode, INodes } from '../interfaces';

/**
 * Returns the node with the given name if it exists else null
 *
 * @param {INodes} nodes Nodes to search in
 * @param {string} name Name of the node to return
 */
export function getNodeByName(nodes: INodes | INode[], name: string) {
	if (Array.isArray(nodes)) {
		return nodes.find((node) => node.name === name) || null;
	}

	if (nodes.hasOwnProperty(name)) {
		return nodes[name];
	}

	return null;
}



================================================
FILE: packages/workflow/src/common/get-parent-nodes.ts
================================================
import { getConnectedNodes } from './get-connected-nodes';
import { NodeConnectionTypes } from '../interfaces';
import type { IConnections, NodeConnectionType } from '../interfaces';

/**
 * Returns all the nodes before the given one
 *
 * @param {NodeConnectionType} [type='main']
 * @param {*} [depth=-1]
 */
export function getParentNodes(
	connectionsByDestinationNode: IConnections,
	nodeName: string,
	type: NodeConnectionType | 'ALL' | 'ALL_NON_MAIN' = NodeConnectionTypes.Main,
	depth = -1,
): string[] {
	return getConnectedNodes(connectionsByDestinationNode, nodeName, type, depth);
}



================================================
FILE: packages/workflow/src/common/index.ts
================================================
export * from './get-child-nodes';
export * from './get-connected-nodes';
export * from './get-node-by-name';
export * from './get-parent-nodes';
export * from './map-connections-by-destination';



================================================
FILE: packages/workflow/src/common/map-connections-by-destination.ts
================================================
/* eslint-disable @typescript-eslint/no-for-in-array */

import type { IConnections, NodeConnectionType } from '../interfaces';

export function mapConnectionsByDestination(connections: IConnections) {
	const returnConnection: IConnections = {};

	let connectionInfo;
	let maxIndex: number;
	for (const sourceNode in connections) {
		if (!connections.hasOwnProperty(sourceNode)) {
			continue;
		}

		for (const type of Object.keys(connections[sourceNode]) as NodeConnectionType[]) {
			if (!connections[sourceNode].hasOwnProperty(type)) {
				continue;
			}

			for (const inputIndex in connections[sourceNode][type]) {
				if (!connections[sourceNode][type].hasOwnProperty(inputIndex)) {
					continue;
				}

				for (connectionInfo of connections[sourceNode][type][inputIndex] ?? []) {
					if (!returnConnection.hasOwnProperty(connectionInfo.node)) {
						returnConnection[connectionInfo.node] = {};
					}
					if (!returnConnection[connectionInfo.node].hasOwnProperty(connectionInfo.type)) {
						returnConnection[connectionInfo.node][connectionInfo.type] = [];
					}

					maxIndex = returnConnection[connectionInfo.node][connectionInfo.type].length - 1;
					for (let j = maxIndex; j < connectionInfo.index; j++) {
						returnConnection[connectionInfo.node][connectionInfo.type].push([]);
					}

					returnConnection[connectionInfo.node][connectionInfo.type][connectionInfo.index]?.push({
						node: sourceNode,
						type,
						index: parseInt(inputIndex, 10),
					});
				}
			}
		}
	}

	return returnConnection;
}



================================================
FILE: packages/workflow/src/errors/cli-subworkflow-operation.error.ts
================================================
import { SubworkflowOperationError } from './subworkflow-operation.error';

export class CliWorkflowOperationError extends SubworkflowOperationError {}



================================================
FILE: packages/workflow/src/errors/db-connection-timeout-error.ts
================================================
import { ApplicationError } from '@n8n/errors';

export type DbConnectionTimeoutErrorOpts = {
	configuredTimeoutInMs: number;
	cause: Error;
};

export class DbConnectionTimeoutError extends ApplicationError {
	constructor(opts: DbConnectionTimeoutErrorOpts) {
		const numberFormat = Intl.NumberFormat();
		const errorMessage = `Could not establish database connection within the configured timeout of ${numberFormat.format(opts.configuredTimeoutInMs)} ms. Please ensure the database is configured correctly and the server is reachable. You can increase the timeout by setting the 'DB_POSTGRESDB_CONNECTION_TIMEOUT' environment variable.`;
		super(errorMessage, { cause: opts.cause });
	}
}



================================================
FILE: packages/workflow/src/errors/ensure-error.ts
================================================
/** Ensures `error` is an `Error */
export function ensureError(error: unknown): Error {
	return error instanceof Error
		? error
		: new Error('Error that was not an instance of Error was thrown', {
				// We should never throw anything except something that derives from Error
				cause: error,
			});
}



================================================
FILE: packages/workflow/src/errors/execution-cancelled.error.ts
================================================
import { ExecutionBaseError } from './abstract/execution-base.error';

export class ExecutionCancelledError extends ExecutionBaseError {
	constructor(executionId: string) {
		super('The execution was cancelled', {
			level: 'warning',
			extra: { executionId },
		});
	}
}



================================================
FILE: packages/workflow/src/errors/expression-extension.error.ts
================================================
import { ExpressionError } from './expression.error';

export class ExpressionExtensionError extends ExpressionError {}



================================================
FILE: packages/workflow/src/errors/expression.error.ts
================================================
import type { IDataObject } from '../interfaces';
import { ExecutionBaseError } from './abstract/execution-base.error';

export interface ExpressionErrorOptions {
	cause?: Error;
	causeDetailed?: string;
	description?: string;
	descriptionKey?: string;
	descriptionTemplate?: string;
	functionality?: 'pairedItem';
	itemIndex?: number;
	messageTemplate?: string;
	nodeCause?: string;
	parameter?: string;
	runIndex?: number;
	type?:
		| 'no_execution_data'
		| 'no_node_execution_data'
		| 'no_input_connection'
		| 'internal'
		| 'paired_item_invalid_info'
		| 'paired_item_no_info'
		| 'paired_item_multiple_matches'
		| 'paired_item_no_connection'
		| 'paired_item_intermediate_nodes';
}

/**
 * Class for instantiating an expression error
 */
export class ExpressionError extends ExecutionBaseError {
	constructor(message: string, options?: ExpressionErrorOptions) {
		super(message, { cause: options?.cause, level: 'warning' });

		if (options?.description !== undefined) {
			this.description = options.description;
		}

		const allowedKeys = [
			'causeDetailed',
			'descriptionTemplate',
			'descriptionKey',
			'itemIndex',
			'messageTemplate',
			'nodeCause',
			'parameter',
			'runIndex',
			'type',
		];

		if (options !== undefined) {
			if (options.functionality !== undefined) {
				this.functionality = options.functionality;
			}

			Object.keys(options as IDataObject).forEach((key) => {
				if (allowedKeys.includes(key)) {
					this.context[key] = (options as IDataObject)[key];
				}
			});
		}
	}
}



================================================
FILE: packages/workflow/src/errors/index.ts
================================================
export { BaseError, type BaseErrorOptions } from './base/base.error';
export { OperationalError, type OperationalErrorOptions } from './base/operational.error';
export { UnexpectedError, type UnexpectedErrorOptions } from './base/unexpected.error';
export { UserError, type UserErrorOptions } from './base/user.error';
export { ApplicationError } from '@n8n/errors';
export { ExpressionError } from './expression.error';
export { ExecutionCancelledError } from './execution-cancelled.error';
export { NodeApiError } from './node-api.error';
export { NodeOperationError } from './node-operation.error';
export { NodeSslError } from './node-ssl.error';
export { WebhookPathTakenError } from './webhook-taken.error';
export { WorkflowActivationError } from './workflow-activation.error';
export { WorkflowDeactivationError } from './workflow-deactivation.error';
export { WorkflowOperationError } from './workflow-operation.error';
export { SubworkflowOperationError } from './subworkflow-operation.error';
export { CliWorkflowOperationError } from './cli-subworkflow-operation.error';
export { TriggerCloseError } from './trigger-close.error';

export { NodeError } from './abstract/node.error';
export { ExecutionBaseError } from './abstract/execution-base.error';
export { ExpressionExtensionError } from './expression-extension.error';
export { DbConnectionTimeoutError } from './db-connection-timeout-error';
export { ensureError } from './ensure-error';



================================================
FILE: packages/workflow/src/errors/node-api.error.ts
================================================
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
import type { AxiosError } from 'axios';
import { parseString } from 'xml2js';

import { NodeError } from './abstract/node.error';
import type { ErrorLevel } from '@n8n/errors';
import {
	NO_OP_NODE_TYPE,
	UNKNOWN_ERROR_DESCRIPTION,
	UNKNOWN_ERROR_MESSAGE,
	UNKNOWN_ERROR_MESSAGE_CRED,
} from '../constants';
import type {
	INode,
	JsonObject,
	IDataObject,
	IStatusCodeMessages,
	Functionality,
	RelatedExecution,
} from '../interfaces';
import { removeCircularRefs } from '../utils';

export interface NodeOperationErrorOptions {
	message?: string;
	description?: string;
	runIndex?: number;
	itemIndex?: number;
	level?: ErrorLevel;
	messageMapping?: { [key: string]: string }; // allows to pass custom mapping for error messages scoped to a node
	functionality?: Functionality;
	type?: string;
	metadata?: {
		subExecution?: RelatedExecution;
		parentExecution?: RelatedExecution;
	};
}

interface NodeApiErrorOptions extends NodeOperationErrorOptions {
	message?: string;
	httpCode?: string;
	parseXml?: boolean;
}

/**
 * Top-level properties where an error message can be found in an API response.
 * order is important, precedence is from top to bottom
 */
const POSSIBLE_ERROR_MESSAGE_KEYS = [
	'cause',
	'error',
	'message',
	'Message',
	'msg',
	'messages',
	'description',
	'reason',
	'detail',
	'details',
	'errors',
	'errorMessage',
	'errorMessages',
	'ErrorMessage',
	'error_message',
	'_error_message',
	'errorDescription',
	'error_description',
	'error_summary',
	'error_info',
	'title',
	'text',
	'field',
	'err',
	'type',
];

/**
 * Properties where a nested object can be found in an API response.
 */
const POSSIBLE_NESTED_ERROR_OBJECT_KEYS = ['Error', 'error', 'err', 'response', 'body', 'data'];

/**
 * Top-level properties where an HTTP error code can be found in an API response.
 */
const POSSIBLE_ERROR_STATUS_KEYS = [
	'statusCode',
	'status',
	'code',
	'status_code',
	'errorCode',
	'error_code',
];

/**
 * Descriptive messages for common HTTP status codes
 * this is used by NodeApiError class
 */
const STATUS_CODE_MESSAGES: IStatusCodeMessages = {
	'4XX': 'Your request is invalid or could not be processed by the service',
	'400': 'Bad request - please check your parameters',
	'401': 'Authorization failed - please check your credentials',
	'402': 'Payment required - perhaps check your payment details?',
	'403': 'Forbidden - perhaps check your credentials?',
	'404': 'The resource you are requesting could not be found',
	'405': 'Method not allowed - please check you are using the right HTTP method',
	'429': 'The service is receiving too many requests from you',

	'5XX': 'The service failed to process your request',
	'500': 'The service was not able to process your request',
	'502': 'Bad gateway - the service failed to handle your request',
	'503':
		'Service unavailable - try again later or consider setting this node to retry automatically (in the node settings)',
	'504': 'Gateway timed out - perhaps try again later?',
};

/**
 * Class for instantiating an error in an API response, e.g. a 404 Not Found response,
 * with an HTTP error code, an error message and a description.
 */
export class NodeApiError extends NodeError {
	httpCode: string | null = null;

	// eslint-disable-next-line complexity
	constructor(
		node: INode,
		errorResponse: JsonObject,
		{
			message,
			description,
			httpCode,
			parseXml,
			runIndex,
			itemIndex,
			level,
			functionality,
			messageMapping,
		}: NodeApiErrorOptions = {},
	) {
		if (errorResponse instanceof NodeApiError) {
			return errorResponse;
		}

		super(node, errorResponse);

		this.addToMessages(errorResponse.message as string);

		if (
			!httpCode &&
			errorResponse instanceof Error &&
			errorResponse.constructor?.name === 'AxiosError'
		) {
			httpCode = (errorResponse as unknown as AxiosError).response?.status?.toString();
		}

		// only for request library error
		if (errorResponse.error) {
			removeCircularRefs(errorResponse.error as JsonObject);
		}

		// if not description provided, try to find it in the error object

		if (
			!description &&
			(errorResponse.description || (errorResponse?.reason as IDataObject)?.description)
		) {
			// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
			this.description = (errorResponse.description ||
				(errorResponse?.reason as IDataObject)?.description) as string;
		}

		// if not message provided, try to find it in the error object or set description as message

		if (
			!message &&
			(errorResponse.message || (errorResponse?.reason as IDataObject)?.message || description)
		) {
			// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
			this.message = (errorResponse.message ||
				// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
				(errorResponse?.reason as IDataObject)?.message ||
				description) as string;
		}

		// if it's an error generated by axios
		// look for descriptions in the response object
		if (errorResponse.reason) {
			const reason: IDataObject = errorResponse.reason as unknown as IDataObject;

			if (reason.isAxiosError && reason.response) {
				errorResponse = reason.response as JsonObject;
			}
		}

		// set http code of this error
		if (httpCode) {
			this.httpCode = httpCode;
		} else if (errorResponse.httpCode) {
			this.httpCode = errorResponse.httpCode as string;
		} else {
			this.httpCode =
				this.findProperty(
					errorResponse,
					POSSIBLE_ERROR_STATUS_KEYS,
					POSSIBLE_NESTED_ERROR_OBJECT_KEYS,
				) ?? null;
		}

		this.level = level ?? 'warning';

		if (
			errorResponse?.response &&
			typeof errorResponse?.response === 'object' &&
			!Array.isArray(errorResponse.response) &&
			errorResponse.response.data &&
			typeof errorResponse.response.data === 'object' &&
			!Array.isArray(errorResponse.response.data)
		) {
			const data = errorResponse.response.data;

			if (data.message) {
				description = data.message as string;
			} else if (data.error && ((data.error as IDataObject) || {}).message) {
				description = (data.error as IDataObject).message as string;
			}

			this.context.data = data;
		}

		// set description of this error
		if (description) {
			this.description = description;
		}

		if (!this.description) {
			if (parseXml) {
				this.setDescriptionFromXml(errorResponse.error as string);
			} else {
				this.description = this.findProperty(
					errorResponse,
					POSSIBLE_ERROR_MESSAGE_KEYS,
					POSSIBLE_NESTED_ERROR_OBJECT_KEYS,
				);
			}
		}

		// set message if provided
		// set default message based on http code
		// or use raw error message
		if (message) {
			this.message = message;
		} else {
			this.setDefaultStatusCodeMessage();
		}

		// if message and description are the same, unset redundant description
		if (this.message === this.description) {
			this.description = undefined;
		}

		// if message contain common error code set descriptive message and update description
		[this.message, this.messages] = this.setDescriptiveErrorMessage(
			this.message,
			this.messages,
			// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
			this.httpCode ||
				(errorResponse?.code as string) ||
				((errorResponse?.reason as JsonObject)?.code as string) ||
				undefined,
			messageMapping,
		);

		if (functionality !== undefined) this.functionality = functionality;
		if (runIndex !== undefined) this.context.runIndex = runIndex;
		if (itemIndex !== undefined) this.context.itemIndex = itemIndex;
	}

	private setDescriptionFromXml(xml: string) {
		parseString(xml, { explicitArray: false }, (_, result) => {
			if (!result) return;

			const topLevelKey = Object.keys(result)[0];
			this.description = this.findProperty(
				result[topLevelKey],
				POSSIBLE_ERROR_MESSAGE_KEYS,
				POSSIBLE_NESTED_ERROR_OBJECT_KEYS,
			);
		});
	}

	/**
	 * Set the error's message based on the HTTP status code.
	 */
	private setDefaultStatusCodeMessage() {
		// Set generic error message for 502 Bad Gateway
		if (!this.httpCode && this.message && this.message.toLowerCase().includes('bad gateway')) {
			this.httpCode = '502';
		}

		if (!this.httpCode) {
			this.httpCode = null;

			if (!this.message) {
				if (this.description) {
					this.message = this.description;
					this.description = undefined;
				} else {
					this.message = UNKNOWN_ERROR_MESSAGE;
					this.description = UNKNOWN_ERROR_DESCRIPTION;
				}
			}
			return;
		}

		if (STATUS_CODE_MESSAGES[this.httpCode]) {
			this.addToMessages(this.message);
			this.message = STATUS_CODE_MESSAGES[this.httpCode];
			return;
		}

		switch (this.httpCode.charAt(0)) {
			case '4':
				this.addToMessages(this.message);
				this.message = STATUS_CODE_MESSAGES['4XX'];
				break;
			case '5':
				this.addToMessages(this.message);
				this.message = STATUS_CODE_MESSAGES['5XX'];
				break;
			default:
				if (!this.message) {
					if (this.description) {
						this.message = this.description;
						this.description = undefined;
					} else {
						this.message = UNKNOWN_ERROR_MESSAGE;
						this.description = UNKNOWN_ERROR_DESCRIPTION;
					}
				}
		}
		if (this.node.type === NO_OP_NODE_TYPE && this.message === UNKNOWN_ERROR_MESSAGE) {
			this.message = `${UNKNOWN_ERROR_MESSAGE_CRED} - ${this.httpCode}`;
		}
	}
}



================================================
FILE: packages/workflow/src/errors/node-operation.error.ts
================================================
import { NodeError } from './abstract/node.error';
import { ApplicationError } from '@n8n/errors';
import type { NodeOperationErrorOptions } from './node-api.error';
import type { INode, JsonObject } from '../interfaces';

/**
 * Class for instantiating an operational error, e.g. an invalid credentials error.
 */
export class NodeOperationError extends NodeError {
	type: string | undefined;

	constructor(
		node: INode,
		error: Error | string | JsonObject,
		options: NodeOperationErrorOptions = {},
	) {
		if (error instanceof NodeOperationError) {
			return error;
		}

		if (typeof error === 'string') {
			error = new ApplicationError(error, { level: options.level ?? 'warning' });
		}

		super(node, error);

		if (error instanceof NodeError && error?.messages?.length) {
			error.messages.forEach((message) => this.addToMessages(message));
		}

		if (options.message) this.message = options.message;
		this.level = options.level ?? 'warning';
		if (options.functionality) this.functionality = options.functionality;
		if (options.type) this.type = options.type;
		this.description = options.description;
		this.context.runIndex = options.runIndex;
		this.context.itemIndex = options.itemIndex;
		this.context.metadata = options.metadata;

		if (this.message === this.description) {
			this.description = undefined;
		}

		[this.message, this.messages] = this.setDescriptiveErrorMessage(
			this.message,
			this.messages,
			undefined,
			options.messageMapping,
		);
	}
}



================================================
FILE: packages/workflow/src/errors/node-ssl.error.ts
================================================
import { ExecutionBaseError } from './abstract/execution-base.error';

export class NodeSslError extends ExecutionBaseError {
	constructor(cause: Error) {
		super("SSL Issue: consider using the 'Ignore SSL issues' option", { cause });
	}
}



================================================
FILE: packages/workflow/src/errors/subworkflow-operation.error.ts
================================================
import { WorkflowOperationError } from './workflow-operation.error';

export class SubworkflowOperationError extends WorkflowOperationError {
	override description = '';

	override cause: Error;

	constructor(message: string, description: string) {
		super(message);
		this.name = this.constructor.name;
		this.description = description;

		this.cause = {
			name: this.name,
			message,
			stack: this.stack as string,
		};
	}
}



================================================
FILE: packages/workflow/src/errors/trigger-close.error.ts
================================================
import { ApplicationError, type ErrorLevel } from '@n8n/errors';
import type { INode } from '../interfaces';

interface TriggerCloseErrorOptions extends ErrorOptions {
	level: ErrorLevel;
}

export class TriggerCloseError extends ApplicationError {
	constructor(
		readonly node: INode,
		{ cause, level }: TriggerCloseErrorOptions,
	) {
		super('Trigger Close Failed', { cause, extra: { nodeName: node.name } });
		this.level = level;
	}
}



================================================
FILE: packages/workflow/src/errors/webhook-taken.error.ts
================================================
import { WorkflowActivationError } from './workflow-activation.error';

export class WebhookPathTakenError extends WorkflowActivationError {
	constructor(nodeName: string, cause?: Error) {
		super(
			`The URL path that the "${nodeName}" node uses is already taken. Please change it to something else.`,
			{ level: 'warning', cause },
		);
	}
}



================================================
FILE: packages/workflow/src/errors/workflow-activation.error.ts
================================================
import { ExecutionBaseError } from './abstract/execution-base.error';
import type { ApplicationError } from '@n8n/errors';
import type { INode } from '../interfaces';

interface WorkflowActivationErrorOptions {
	cause?: Error;
	node?: INode;
	level?: ApplicationError['level'];
	workflowId?: string;
}

/**
 * Class for instantiating an workflow activation error
 */
export class WorkflowActivationError extends ExecutionBaseError {
	node: INode | undefined;

	workflowId: string | undefined;

	constructor(
		message: string,
		{ cause, node, level, workflowId }: WorkflowActivationErrorOptions = {},
	) {
		let error = cause as Error;
		if (cause instanceof ExecutionBaseError) {
			error = new Error(cause.message);
			error.constructor = cause.constructor;
			error.name = cause.name;
			error.stack = cause.stack;
		}
		super(message, { cause: error });
		this.node = node;
		this.workflowId = workflowId;
		this.message = message;
		this.setLevel(level);
	}

	private setLevel(level?: ApplicationError['level']) {
		if (level) {
			this.level = level;
			return;
		}

		if (
			[
				'etimedout', // Node.js
				'econnrefused', // Node.js
				'eauth', // OAuth
				'temporary authentication failure', // IMAP server
				'invalid credentials',
			].some((str) => this.message.toLowerCase().includes(str))
		) {
			this.level = 'warning';
			return;
		}

		this.level = 'error';
	}
}



================================================
FILE: packages/workflow/src/errors/workflow-deactivation.error.ts
================================================
import { WorkflowActivationError } from './workflow-activation.error';

export class WorkflowDeactivationError extends WorkflowActivationError {}



================================================
FILE: packages/workflow/src/errors/workflow-operation.error.ts
================================================
import type { INode } from '../interfaces';
import { ExecutionBaseError } from './abstract/execution-base.error';

/**
 * Class for instantiating an operational error, e.g. a timeout error.
 */
export class WorkflowOperationError extends ExecutionBaseError {
	node: INode | undefined;

	override timestamp: number;

	constructor(message: string, node?: INode, description?: string) {
		super(message, { cause: undefined });
		this.level = 'warning';
		this.name = this.constructor.name;
		if (description) this.description = description;
		this.node = node;
		this.timestamp = Date.now();
	}
}



================================================
FILE: packages/workflow/src/errors/abstract/execution-base.error.ts
================================================
import { ApplicationError, type ReportingOptions } from '@n8n/errors';

import type { Functionality, IDataObject, JsonObject } from '../../interfaces';

interface ExecutionBaseErrorOptions extends ReportingOptions {
	cause?: Error;
	errorResponse?: JsonObject;
}

export abstract class ExecutionBaseError extends ApplicationError {
	description: string | null | undefined;

	override cause?: Error;

	errorResponse?: JsonObject;

	timestamp: number;

	context: IDataObject = {};

	lineNumber: number | undefined;

	functionality: Functionality = 'regular';

	constructor(message: string, options: ExecutionBaseErrorOptions = {}) {
		super(message, options);

		this.name = this.constructor.name;
		this.timestamp = Date.now();

		const { cause, errorResponse } = options;
		if (cause instanceof ExecutionBaseError) {
			this.context = cause.context;
		} else if (cause && !(cause instanceof Error)) {
			this.cause = cause;
		}

		if (errorResponse) this.errorResponse = errorResponse;
	}

	toJSON?() {
		return {
			message: this.message,
			lineNumber: this.lineNumber,
			timestamp: this.timestamp,
			name: this.name,
			description: this.description,
			context: this.context,
			cause: this.cause,
		};
	}
}



================================================
FILE: packages/workflow/src/errors/abstract/node.error.ts
================================================
import { ExecutionBaseError } from './execution-base.error';
import type { IDataObject, INode, JsonObject } from '../../interfaces';
import { isTraversableObject, jsonParse } from '../../utils';

/**
 * Descriptive messages for common errors.
 */
const COMMON_ERRORS: IDataObject = {
	// nodeJS errors
	ECONNREFUSED: 'The service refused the connection - perhaps it is offline',
	ECONNRESET:
		'The connection to the server was closed unexpectedly, perhaps it is offline. You can retry the request immediately or wait and retry later.',
	ENOTFOUND:
		'The connection cannot be established, this usually occurs due to an incorrect host (domain) value',
	ETIMEDOUT:
		"The connection timed out, consider setting the 'Retry on Fail' option in the node settings",
	ERRADDRINUSE:
		'The port is already occupied by some other application, if possible change the port or kill the application that is using it',
	EADDRNOTAVAIL: 'The address is not available, ensure that you have the right IP address',
	ECONNABORTED: 'The connection was aborted, perhaps the server is offline',
	EHOSTUNREACH: 'The host is unreachable, perhaps the server is offline',
	EAI_AGAIN: 'The DNS server returned an error, perhaps the server is offline',
	ENOENT: 'The file or directory does not exist',
	EISDIR: 'The file path was expected but the given path is a directory',
	ENOTDIR: 'The directory path was expected but the given path is a file',
	EACCES: 'Forbidden by access permissions, make sure you have the right permissions',
	EEXIST: 'The file or directory already exists',
	EPERM: 'Operation not permitted, make sure you have the right permissions',
	// other errors
	GETADDRINFO: 'The server closed the connection unexpectedly',
};

/**
 * Base class for specific NodeError-types, with functionality for finding
 * a value recursively inside an error object.
 */
export abstract class NodeError extends ExecutionBaseError {
	messages: string[] = [];

	constructor(
		readonly node: INode,
		error: Error | JsonObject,
	) {
		const isError = error instanceof Error;
		const message = isError ? error.message : '';
		const options = isError ? { cause: error } : { errorResponse: error };
		super(message, options);

		if (error instanceof NodeError) {
			this.tags.reWrapped = true;
		}
	}

	/**
	 * Finds property through exploration based on potential keys and traversal keys.
	 * Depth-first approach.
	 *
	 * This method iterates over `potentialKeys` and, if the value at the key is a
	 * truthy value, the type of the value is checked:
	 * (1) if a string or number, the value is returned as a string; or
	 * (2) if an array,
	 * 		its string or number elements are collected as a long string,
	 * 		its object elements are traversed recursively (restart this function
	 *    with each object as a starting point), or
	 * (3) if it is an object, it traverses the object and nested ones recursively
	 * 		based on the `potentialKeys` and returns a string if found.
	 *
	 * If nothing found via `potentialKeys` this method iterates over `traversalKeys` and
	 * if the value at the key is a traversable object, it restarts with the object as the
	 * new starting point (recursion).
	 * If nothing found for any of the `traversalKeys`, exploration continues with remaining
	 * `traversalKeys`.
	 *
	 * Otherwise, if all the paths have been exhausted and no value is eligible, `null` is
	 * returned.
	 *
	 */
	protected findProperty(
		jsonError: JsonObject,
		potentialKeys: string[],
		traversalKeys: string[] = [],
	): string | null {
		for (const key of potentialKeys) {
			let value = jsonError[key];
			if (value) {
				if (typeof value === 'string') {
					try {
						value = jsonParse(value);
					} catch (error) {
						return value as string;
					}
					if (typeof value === 'string') return value;
				}
				if (typeof value === 'number') return value.toString();
				if (Array.isArray(value)) {
					const resolvedErrors: string[] = value

						.map((jsonError) => {
							if (typeof jsonError === 'string') return jsonError;
							if (typeof jsonError === 'number') return jsonError.toString();
							if (isTraversableObject(jsonError)) {
								return this.findProperty(jsonError, potentialKeys);
							}
							return null;
						})
						.filter((errorValue): errorValue is string => errorValue !== null);

					if (resolvedErrors.length === 0) {
						return null;
					}
					return resolvedErrors.join(' | ');
				}
				if (isTraversableObject(value)) {
					const property = this.findProperty(value, potentialKeys);
					if (property) {
						return property;
					}
				}
			}
		}

		for (const key of traversalKeys) {
			const value = jsonError[key];
			if (isTraversableObject(value)) {
				const property = this.findProperty(value, potentialKeys, traversalKeys);
				if (property) {
					return property;
				}
			}
		}

		return null;
	}

	/**
	 * Preserve the original error message before setting the new one
	 */
	protected addToMessages(message: string): void {
		if (message && !this.messages.includes(message)) {
			this.messages.push(message);
		}
	}

	/**
	 * Set descriptive error message if code is provided or if message contains any of the common errors,
	 * update description to include original message plus the description
	 */
	protected setDescriptiveErrorMessage(
		message: string,
		messages: string[],
		code?: string | null,
		messageMapping?: { [key: string]: string },
	): [string, string[]] {
		let newMessage = message;

		if (messageMapping) {
			for (const [mapKey, mapMessage] of Object.entries(messageMapping)) {
				if ((message || '').toUpperCase().includes(mapKey.toUpperCase())) {
					newMessage = mapMessage;
					messages.push(message);
					break;
				}
			}
			if (newMessage !== message) {
				return [newMessage, messages];
			}
		}

		// if code is provided and it is in the list of common errors set the message and return early
		if (code && typeof code === 'string' && COMMON_ERRORS[code.toUpperCase()]) {
			newMessage = COMMON_ERRORS[code] as string;
			messages.push(message);
			return [newMessage, messages];
		}

		// check if message contains any of the common errors and set the message and description
		for (const [errorCode, errorDescriptiveMessage] of Object.entries(COMMON_ERRORS)) {
			if ((message || '').toUpperCase().includes(errorCode.toUpperCase())) {
				newMessage = errorDescriptiveMessage as string;
				messages.push(message);
				break;
			}
		}

		return [newMessage, messages];
	}
}



================================================
FILE: packages/workflow/src/errors/base/base.error.ts
================================================
import type { Event } from '@sentry/node';
import callsites from 'callsites';

import type { ErrorTags, ErrorLevel, ReportingOptions } from '@n8n/errors';

export type BaseErrorOptions = { description?: string | undefined | null } & ErrorOptions &
	ReportingOptions;
/**
 * Base class for all errors
 */
export abstract class BaseError extends Error {
	/**
	 * Error level. Defines which level the error should be logged/reported
	 * @default 'error'
	 */
	level: ErrorLevel;

	/**
	 * Whether the error should be reported to Sentry.
	 * @default true
	 */
	readonly shouldReport: boolean;

	readonly description: string | null | undefined;

	readonly tags: ErrorTags;

	readonly extra?: Event['extra'];

	readonly packageName?: string;

	constructor(
		message: string,
		{
			level = 'error',
			description,
			shouldReport,
			tags = {},
			extra,
			...rest
		}: BaseErrorOptions = {},
	) {
		super(message, rest);

		this.level = level;
		this.shouldReport = shouldReport ?? (level === 'error' || level === 'fatal');
		this.description = description;
		this.tags = tags;
		this.extra = extra;

		try {
			const filePath = callsites()[2].getFileName() ?? '';
			const match = /packages\/([^\/]+)\//.exec(filePath)?.[1];

			if (match) this.tags.packageName = match;
		} catch {}
	}
}



================================================
FILE: packages/workflow/src/errors/base/operational.error.ts
================================================
import type { BaseErrorOptions } from './base.error';
import { BaseError } from './base.error';

export type OperationalErrorOptions = Omit<BaseErrorOptions, 'level'> & {
	level?: 'info' | 'warning' | 'error';
};

/**
 * Error that indicates a transient issue, like a network request failing,
 * a database query timing out, etc. These are expected to happen, are
 * transient by nature and should be handled gracefully.
 *
 * Default level: warning
 */
export class OperationalError extends BaseError {
	constructor(message: string, opts: OperationalErrorOptions = {}) {
		opts.level = opts.level ?? 'warning';

		super(message, opts);
	}
}



================================================
FILE: packages/workflow/src/errors/base/unexpected.error.ts
================================================
import type { BaseErrorOptions } from './base.error';
import { BaseError } from './base.error';

export type UnexpectedErrorOptions = Omit<BaseErrorOptions, 'level'> & {
	level?: 'error' | 'fatal';
};

/**
 * Error that indicates something is wrong in the code: logic mistakes,
 * unhandled cases, assertions that fail. These are not recoverable and
 * should be brought to developers' attention.
 *
 * Default level: error
 */
export class UnexpectedError extends BaseError {
	constructor(message: string, opts: UnexpectedErrorOptions = {}) {
		opts.level = opts.level ?? 'error';

		super(message, opts);
	}
}



================================================
FILE: packages/workflow/src/errors/base/user.error.ts
================================================
import type { BaseErrorOptions } from './base.error';
import { BaseError } from './base.error';

export type UserErrorOptions = Omit<BaseErrorOptions, 'level'> & {
	level?: 'info' | 'warning';
	description?: string | null | undefined;
};

/**
 * Error that indicates the user performed an action that caused an error.
 * E.g. provided invalid input, tried to access a resource they’re not
 * authorized to, or violates a business rule.
 *
 * Default level: info
 */
export class UserError extends BaseError {
	declare readonly description: string | null | undefined;

	constructor(message: string, opts: UserErrorOptions = {}) {
		opts.level = opts.level ?? 'info';

		super(message, opts);
	}
}



================================================
FILE: packages/workflow/src/expressions/expression-helpers.ts
================================================
/**
 * Checks if the given value is an expression. An expression is a string that
 * starts with '='.
 */
export const isExpression = (expr: unknown): expr is string => {
	if (typeof expr !== 'string') return false;

	return expr.charAt(0) === '=';
};



================================================
FILE: packages/workflow/src/extensions/array-extensions.ts
================================================
import isEqual from 'lodash/isEqual';
import uniqWith from 'lodash/uniqWith';

import type { Extension, ExtensionMap } from './extensions';
import { compact as oCompact } from './object-extensions';
import { ExpressionExtensionError } from '../errors/expression-extension.error';
import { ExpressionError } from '../errors/expression.error';
import { randomInt } from '../utils';

function first(value: unknown[]): unknown {
	return value[0];
}

function isEmpty(value: unknown[]): boolean {
	return value.length === 0;
}

function isNotEmpty(value: unknown[]): boolean {
	return value.length > 0;
}

function last(value: unknown[]): unknown {
	return value[value.length - 1];
}

function pluck(value: unknown[], extraArgs: unknown[]): unknown[] {
	if (!Array.isArray(extraArgs)) {
		throw new ExpressionError('arguments must be passed to pluck');
	}
	if (!extraArgs || extraArgs.length === 0) {
		return value;
	}
	const plucked = value.reduce<unknown[]>((pluckedFromObject, current) => {
		if (current && typeof current === 'object') {
			const p: unknown[] = [];
			Object.keys(current).forEach((k) => {
				(extraArgs as string[]).forEach((field) => {
					if (current && field === k) {
						p.push((current as { [key: string]: unknown })[k]);
					}
				});
			});
			if (p.length > 0) {
				pluckedFromObject.push(p.length === 1 ? p[0] : p);
			}
		}
		return pluckedFromObject;
	}, new Array<unknown>());
	return plucked;
}

function randomItem(value: unknown[]): unknown {
	const len = value === undefined ? 0 : value.length;
	return len ? value[randomInt(len)] : undefined;
}

function unique(value: unknown[], extraArgs: string[]): unknown[] {
	const mapForEqualityCheck = (item: unknown): unknown => {
		if (extraArgs.length > 0 && item && typeof item === 'object') {
			return extraArgs.reduce<Record<string, unknown>>((acc, key) => {
				acc[key] = (item as Record<string, unknown>)[key];
				return acc;
			}, {});
		}
		return item;
	};
	return uniqWith(value, (a, b) => isEqual(mapForEqualityCheck(a), mapForEqualityCheck(b)));
}

const ensureNumberArray = (arr: unknown[], { fnName }: { fnName: string }) => {
	if (arr.some((i) => typeof i !== 'number')) {
		throw new ExpressionExtensionError(`${fnName}(): all array elements must be numbers`);
	}
};

function sum(value: unknown[]): number {
	ensureNumberArray(value, { fnName: 'sum' });

	return value.reduce((p: number, c: unknown) => {
		if (typeof c === 'string') {
			return p + parseFloat(c);
		}
		if (typeof c !== 'number') {
			return NaN;
		}
		return p + c;
	}, 0);
}

function min(value: unknown[]): number {
	ensureNumberArray(value, { fnName: 'min' });

	return Math.min(
		...value.map((v) => {
			if (typeof v === 'string') {
				return parseFloat(v);
			}
			if (typeof v !== 'number') {
				return NaN;
			}
			return v;
		}),
	);
}

function max(value: unknown[]): number {
	ensureNumberArray(value, { fnName: 'max' });

	return Math.max(
		...value.map((v) => {
			if (typeof v === 'string') {
				return parseFloat(v);
			}
			if (typeof v !== 'number') {
				return NaN;
			}
			return v;
		}),
	);
}

export function average(value: unknown[]) {
	ensureNumberArray(value, { fnName: 'average' });

	// This would usually be NaN but I don't think users
	// will expect that
	if (value.length === 0) {
		return 0;
	}
	return sum(value) / value.length;
}

function compact(value: unknown[]): unknown[] {
	return value
		.filter((v) => {
			if (v && typeof v === 'object' && Object.keys(v).length === 0) return false;

			return v !== null && v !== undefined && v !== 'nil' && v !== '';
		})
		.map((v) => {
			if (typeof v === 'object' && v !== null) {
				return oCompact(v);
			}
			return v;
		});
}

function smartJoin(value: unknown[], extraArgs: string[]): object {
	const [keyField, valueField] = extraArgs;
	if (!keyField || !valueField || typeof keyField !== 'string' || typeof valueField !== 'string') {
		throw new ExpressionExtensionError(
			'smartJoin(): expected two string args, e.g. .smartJoin("name", "value")',
		);
	}
	// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return
	return value.reduce<any>((o, v) => {
		if (typeof v === 'object' && v !== null && keyField in v && valueField in v) {
			// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
			o[(v as any)[keyField]] = (v as any)[valueField];
		}
		// eslint-disable-next-line @typescript-eslint/no-unsafe-return
		return o;
	}, {});
}

function chunk(value: unknown[], extraArgs: number[]) {
	const [chunkSize] = extraArgs;
	if (typeof chunkSize !== 'number' || chunkSize === 0) {
		throw new ExpressionExtensionError('chunk(): expected non-zero numeric arg, e.g. .chunk(5)');
	}
	const chunks: unknown[][] = [];
	for (let i = 0; i < value.length; i += chunkSize) {
		// I have no clue why eslint thinks 2 numbers could be anything but that but here we are

		chunks.push(value.slice(i, i + chunkSize));
	}
	return chunks;
}

function renameKeys(value: unknown[], extraArgs: string[]): unknown[] {
	if (extraArgs.length === 0 || extraArgs.length % 2 !== 0) {
		throw new ExpressionExtensionError(
			'renameKeys(): expected an even amount of args: from1, to1 [, from2, to2, ...]. e.g. .renameKeys("name", "title")',
		);
	}
	return value.map((v) => {
		if (typeof v !== 'object' || v === null) {
			return v;
		}
		// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
		const newObj = { ...(v as any) };
		const chunkedArgs = chunk(extraArgs, [2]) as string[][];
		chunkedArgs.forEach(([from, to]) => {
			if (from in newObj) {
				// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
				newObj[to] = newObj[from];
				// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
				delete newObj[from];
			}
		});
		// eslint-disable-next-line @typescript-eslint/no-unsafe-return
		return newObj;
	});
}

function mergeObjects(value: Record<string, unknown>, extraArgs: unknown[]): unknown {
	const [other] = extraArgs;

	if (!other) {
		return value;
	}

	if (typeof other !== 'object') {
		throw new ExpressionExtensionError('merge(): expected object arg');
	}

	const newObject = { ...value };
	for (const [key, val] of Object.entries(other)) {
		if (!(key in newObject)) {
			newObject[key] = val;
		}
	}
	return newObject;
}

function merge(value: unknown[], extraArgs: unknown[][]): unknown {
	const [others] = extraArgs;

	if (others === undefined) {
		// If there are no arguments passed, merge all objects within the array
		const merged = value.reduce((combined, current) => {
			if (current !== null && typeof current === 'object' && !Array.isArray(current)) {
				combined = mergeObjects(combined as Record<string, unknown>, [current]);
			}
			return combined;
		}, {});
		return merged;
	}

	if (!Array.isArray(others)) {
		throw new ExpressionExtensionError(
			'merge(): expected array arg, e.g. .merge([{ id: 1, otherValue: 3 }])',
		);
	}
	const listLength = value.length > others.length ? value.length : others.length;
	let merged = {};
	for (let i = 0; i < listLength; i++) {
		if (value[i] !== undefined) {
			if (typeof value[i] === 'object' && typeof others[i] === 'object') {
				merged = Object.assign(
					merged,
					mergeObjects(value[i] as Record<string, unknown>, [others[i]]),
				);
			}
		}
	}
	return merged;
}

function union(value: unknown[], extraArgs: unknown[][]): unknown[] {
	const [others] = extraArgs;
	if (!Array.isArray(others)) {
		throw new ExpressionExtensionError('union(): expected array arg, e.g. .union([1, 2, 3, 4])');
	}
	const newArr: unknown[] = Array.from(value);
	for (const v of others) {
		if (newArr.findIndex((w) => isEqual(w, v)) === -1) {
			newArr.push(v);
		}
	}
	return unique(newArr, []);
}

function difference(value: unknown[], extraArgs: unknown[][]): unknown[] {
	const [others] = extraArgs;
	if (!Array.isArray(others)) {
		throw new ExpressionExtensionError(
			'difference(): expected array arg, e.g. .difference([1, 2, 3, 4])',
		);
	}
	const newArr: unknown[] = [];
	for (const v of value) {
		if (others.findIndex((w) => isEqual(w, v)) === -1) {
			newArr.push(v);
		}
	}
	return unique(newArr, []);
}

function intersection(value: unknown[], extraArgs: unknown[][]): unknown[] {
	const [others] = extraArgs;
	if (!Array.isArray(others)) {
		throw new ExpressionExtensionError(
			'intersection(): expected array arg, e.g. .intersection([1, 2, 3, 4])',
		);
	}
	const newArr: unknown[] = [];
	for (const v of value) {
		if (others.findIndex((w) => isEqual(w, v)) !== -1) {
			newArr.push(v);
		}
	}
	for (const v of others) {
		if (value.findIndex((w) => isEqual(w, v)) !== -1) {
			newArr.push(v);
		}
	}
	return unique(newArr, []);
}

function append(value: unknown[], extraArgs: unknown[][]): unknown[] {
	return value.concat(extraArgs);
}

export function toJsonString(value: unknown[]) {
	return JSON.stringify(value);
}

export function toInt() {
	return undefined;
}

export function toFloat() {
	return undefined;
}

export function toBoolean() {
	return undefined;
}

export function toDateTime() {
	return undefined;
}

average.doc = {
	name: 'average',
	description:
		'Returns the average of the numbers in the array. Throws an error if there are any non-numbers.',
	examples: [{ example: '[12, 1, 5].average()', evaluated: '6' }],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-average',
};

compact.doc = {
	name: 'compact',
	description:
		'Removes any empty values from the array. <code>null</code>, <code>""</code> and <code>undefined</code> count as empty.',
	examples: [{ example: '[2, null, 1, ""].compact()', evaluated: '[2, 1]' }],
	returnType: 'Array',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-compact',
};

isEmpty.doc = {
	name: 'isEmpty',
	description: 'Returns <code>true</code> if the array has no elements or is <code>null</code>',
	examples: [
		{ example: '[].isEmpty()', evaluated: 'true' },
		{ example: "['quick', 'brown', 'fox'].isEmpty()", evaluated: 'false' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isEmpty',
};

isNotEmpty.doc = {
	name: 'isNotEmpty',
	description: 'Returns <code>true</code> if the array has at least one element',
	examples: [
		{ example: "['quick', 'brown', 'fox'].isNotEmpty()", evaluated: 'true' },
		{ example: '[].isNotEmpty()', evaluated: 'false' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isNotEmpty',
};

first.doc = {
	name: 'first',
	description: 'Returns the first element of the array',
	examples: [{ example: "['quick', 'brown', 'fox'].first()", evaluated: "'quick'" }],
	returnType: 'any',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-first',
};

last.doc = {
	name: 'last',
	description: 'Returns the last element of the array',
	examples: [{ example: "['quick', 'brown', 'fox'].last()", evaluated: "'fox'" }],
	returnType: 'any',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-last',
};

max.doc = {
	name: 'max',
	description:
		'Returns the largest number in the array. Throws an error if there are any non-numbers.',
	examples: [{ example: '[1, 12, 5].max()', evaluated: '12' }],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-max',
};

min.doc = {
	name: 'min',
	description:
		'Returns the smallest number in the array. Throws an error if there are any non-numbers.',
	examples: [{ example: '[12, 1, 5].min()', evaluated: '1' }],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-min',
};

randomItem.doc = {
	name: 'randomItem',
	description: 'Returns a randomly-chosen element from the array',
	examples: [
		{ example: "['quick', 'brown', 'fox'].randomItem()", evaluated: "'brown'" },
		{ example: "['quick', 'brown', 'fox'].randomItem()", evaluated: "'quick'" },
	],
	returnType: 'any',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-randomItem',
};

sum.doc = {
	name: 'sum',
	description:
		'Returns the total of all the numbers in the array. Throws an error if there are any non-numbers.',
	examples: [{ example: '[12, 1, 5].sum()', evaluated: '18' }],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-sum',
};

chunk.doc = {
	name: 'chunk',
	description: 'Splits the array into an array of sub-arrays, each with the given length',
	examples: [{ example: '[1, 2, 3, 4, 5, 6].chunk(2)', evaluated: '[[1,2],[3,4],[5,6]]' }],
	returnType: 'Array',
	args: [
		{
			name: 'length',
			optional: false,
			description: 'The number of elements in each chunk',
			type: 'number',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-chunk',
};

difference.doc = {
	name: 'difference',
	description:
		"Compares two arrays. Returns all elements in the base array that aren't present\nin <code>otherArray</code>.",
	examples: [{ example: '[1, 2, 3].difference([2, 3])', evaluated: '[1]' }],
	returnType: 'Array',
	args: [
		{
			name: 'otherArray',
			optional: false,
			description: 'The array to compare to the base array',
			type: 'Array',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-difference',
};

intersection.doc = {
	name: 'intersection',
	description:
		'Compares two arrays. Returns all elements in the base array that are also present in the other array.',
	examples: [{ example: '[1, 2].intersection([2, 3])', evaluated: '[2]' }],
	returnType: 'Array',
	args: [
		{
			name: 'otherArray',
			optional: false,
			description: 'The array to compare to the base array',
			type: 'Array',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-intersection',
};

merge.doc = {
	name: 'merge',
	description:
		'Merges two Object-arrays into one object by merging the key-value pairs of each element.',
	examples: [
		{
			example:
				"[{ name: 'Nathan' }, { age: 42 }].merge([{ city: 'Berlin' }, { country: 'Germany' }])",
			evaluated: "{ name: 'Nathan', age: 42, city: 'Berlin', country: 'Germany' }",
		},
	],
	returnType: 'Object',
	args: [
		{
			name: 'otherArray',
			optional: false,
			description: 'The array to merge into the base array',
			type: 'Array',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-merge',
};

pluck.doc = {
	name: 'pluck',
	description:
		'Returns an array containing the values of the given field(s) in each Object of the array. Ignores any array elements that aren’t Objects or don’t have a key matching the field name(s) provided.',
	examples: [
		{
			example: "[{ name: 'Nathan', age: 42 },{ name: 'Jan', city: 'Berlin' }].pluck('name')",
			evaluated: '["Nathan", "Jan"]',
		},
		{
			example: "[{ name: 'Nathan', age: 42 },{ name: 'Jan', city: 'Berlin' }].pluck('age')",
			evaluated: '[42]',
		},
	],
	returnType: 'Array',
	args: [
		{
			name: 'fieldNames',
			optional: false,
			variadic: true,
			description: 'The keys to retrieve the value of',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-pluck',
};

renameKeys.doc = {
	name: 'renameKeys',
	description:
		'Changes all matching keys (field names) of any Objects in the array. Rename more than one key by\nadding extra arguments, i.e. <code>from1, to1, from2, to2, ...</code>.',
	examples: [
		{
			example: "[{ name: 'bob' }, { name: 'meg' }].renameKeys('name', 'x')",
			evaluated: "[{ x: 'bob' }, { x: 'meg' }]",
		},
	],
	returnType: 'Array',
	args: [
		{
			name: 'from',
			optional: false,
			description: 'The key to rename',
			type: 'string',
		},
		{ name: 'to', optional: false, description: 'The new key name', type: 'string' },
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-renameKeys',
};

smartJoin.doc = {
	name: 'smartJoin',
	description:
		'Creates a single Object from an array of Objects. Each Object in the array provides one field for the returned Object. Each Object in the array must contain a field with the key name and a field with the value.',
	examples: [
		{
			example:
				"[{ field: 'age', value: 2 }, { field: 'city', value: 'Berlin' }].smartJoin('field', 'value')",
			evaluated: "{ age: 2, city: 'Berlin' }",
		},
	],
	returnType: 'Object',
	args: [
		{
			name: 'keyField',
			optional: false,
			description: 'The field in each Object containing the key name',
			type: 'string',
		},
		{
			name: 'nameField',
			optional: false,
			description: 'The field in each Object containing the value',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-smartJoin',
};

union.doc = {
	name: 'union',
	description: 'Concatenates two arrays and then removes any duplicates',
	examples: [{ example: '[1, 2].union([2, 3])', evaluated: '[1, 2, 3]' }],
	returnType: 'Array',
	args: [
		{
			name: 'otherArray',
			optional: false,
			description: 'The array to union with the base array',
			type: 'Array',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-union',
};

unique.doc = {
	name: 'unique',
	description: 'Removes any duplicate elements from the array',
	examples: [
		{ example: "['quick', 'brown', 'quick'].unique()", evaluated: "['quick', 'brown']" },
		{
			example: "[{ name: 'Nathan', age: 42 }, { name: 'Nathan', age: 22 }].unique()",
			evaluated: "[{ name: 'Nathan', age: 42 }, { name: 'Nathan', age: 22 }]",
		},
		{
			example: "[{ name: 'Nathan', age: 42 }, { name: 'Nathan', age: 22 }].unique('name')",
			evaluated: "[{ name: 'Nathan', age: 42 }]",
		},
	],
	returnType: 'any',
	aliases: ['removeDuplicates'],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-unique',
	args: [
		{
			name: 'fieldNames',
			optional: false,
			variadic: true,
			description: 'The object keys to check for equality',
			type: 'any',
		},
	],
};

toJsonString.doc = {
	name: 'toJsonString',
	description:
		"Converts the array to a JSON string. The same as JavaScript's <code>JSON.stringify()</code>.",
	examples: [
		{
			example: "['quick', 'brown', 'fox'].toJsonString()",
			evaluated: '\'["quick","brown","fox"]\'',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-toJsonString',
	returnType: 'string',
};

append.doc = {
	name: 'append',
	description:
		'Adds new elements to the end of the array. Similar to <code>push()</code>, but returns the modified array. Consider using spread syntax instead (see examples).',
	examples: [
		{ example: "['forget', 'me'].append('not')", evaluated: "['forget', 'me', 'not']" },
		{ example: '[9, 0, 2].append(1, 0)', evaluated: '[9, 0, 2, 1, 0]' },
		{
			example: '[...[9, 0, 2], 1, 0]',
			evaluated: '[9, 0, 2, 1, 0]',
			description: 'Consider using spread syntax instead',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-append',
	returnType: 'Array',
	args: [
		{
			name: 'elements',
			optional: false,
			variadic: true,
			description: 'The elements to append, in order',
			type: 'any',
		},
	],
};

const removeDuplicates: Extension = unique.bind({});
removeDuplicates.doc = { ...unique.doc, hidden: true };

export const arrayExtensions: ExtensionMap = {
	typeName: 'Array',
	functions: {
		removeDuplicates,
		unique,
		first,
		last,
		pluck,
		randomItem,
		sum,
		min,
		max,
		average,
		isNotEmpty,
		isEmpty,
		compact,
		smartJoin,
		chunk,
		renameKeys,
		merge,
		union,
		difference,
		intersection,
		append,
		toJsonString,
		toInt,
		toFloat,
		toBoolean,
		toDateTime,
	},
};



================================================
FILE: packages/workflow/src/extensions/boolean-extensions.ts
================================================
import type { Extension, ExtensionMap } from './extensions';

export function toBoolean(value: boolean) {
	return value;
}

export function toInt(value: boolean) {
	return value ? 1 : 0;
}

export function toDateTime() {
	return undefined;
}

const toFloat = toInt;
const toNumber: Extension = toInt.bind({});

toNumber.doc = {
	name: 'toNumber',
	description:
		'Converts <code>true</code> to <code>1</code> and <code>false</code> to <code>0</code>.',
	examples: [
		{ example: 'true.toNumber()', evaluated: '1' },
		{ example: 'false.toNumber()', evaluated: '0' },
	],
	section: 'cast',
	returnType: 'number',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/booleans/#boolean-toNumber',
};

export const booleanExtensions: ExtensionMap = {
	typeName: 'Boolean',
	functions: {
		toBoolean,
		toInt,
		toFloat,
		toNumber,
		toDateTime,
	},
};



================================================
FILE: packages/workflow/src/extensions/date-extensions.ts
================================================
import { DateTime } from 'luxon';
import type {
	DateTimeUnit,
	DurationLike,
	DurationObjectUnits,
	LocaleOptions,
	WeekdayNumbers,
} from 'luxon';

import type { ExtensionMap } from './extensions';
import { toDateTime as stringToDateTime } from './string-extensions';
import { convertToDateTime } from './utils';
import { ExpressionExtensionError } from '../errors/expression-extension.error';

const durationUnits = [
	'milliseconds',
	'seconds',
	'minutes',
	'hours',
	'days',
	'weeks',
	'months',
	'quarters',
	'years',
] as const;
type DurationUnit = (typeof durationUnits)[number];

const dateParts = [
	'day',
	'week',
	'month',
	'year',
	'hour',
	'minute',
	'second',
	'millisecond',
	'weekNumber',
	'yearDayNumber',
	'weekday',
] as const;
type DatePart = (typeof dateParts)[number];

const DURATION_MAP: Record<string, DurationUnit> = {
	day: 'days',
	month: 'months',
	year: 'years',
	week: 'weeks',
	hour: 'hours',
	minute: 'minutes',
	second: 'seconds',
	millisecond: 'milliseconds',
	ms: 'milliseconds',
	sec: 'seconds',
	secs: 'seconds',
	hr: 'hours',
	hrs: 'hours',
	min: 'minutes',
	mins: 'minutes',
};

const DATETIMEUNIT_MAP: Record<string, DateTimeUnit> = {
	days: 'day',
	months: 'month',
	years: 'year',
	hours: 'hour',
	minutes: 'minute',
	seconds: 'second',
	milliseconds: 'millisecond',
	hrs: 'hour',
	hr: 'hour',
	mins: 'minute',
	min: 'minute',
	secs: 'second',
	sec: 'second',
	ms: 'millisecond',
};

function isDateTime(date: unknown): date is DateTime {
	return date ? DateTime.isDateTime(date) : false;
}

function toDateTime(date: string | Date | DateTime): DateTime {
	if (isDateTime(date)) return date;

	if (typeof date === 'string') {
		return stringToDateTime(date);
	}

	return DateTime.fromJSDate(date);
}

function generateDurationObject(durationValue: number, unit: DurationUnit): DurationObjectUnits {
	const convertedUnit = DURATION_MAP[unit] || unit;
	return { [`${convertedUnit}`]: durationValue };
}

function beginningOf(date: Date | DateTime, extraArgs: DurationUnit[]): Date | DateTime {
	const [rawUnit = 'week'] = extraArgs;

	const unit = DATETIMEUNIT_MAP[rawUnit] || rawUnit;

	if (isDateTime(date)) return date.startOf(unit);

	return DateTime.fromJSDate(date).startOf(unit).toJSDate();
}

function endOfMonth(date: Date | DateTime): Date | DateTime {
	if (isDateTime(date)) return date.endOf('month');

	return DateTime.fromJSDate(date).endOf('month').toJSDate();
}

function extract(date: Date | DateTime, args: DatePart[]): number {
	let [part = 'week'] = args;

	if (part === 'yearDayNumber') {
		date = isDateTime(date) ? date.toJSDate() : date;

		const firstDayOfTheYear = new Date(date.getFullYear(), 0, 0);

		const diff =
			date.getTime() -
			firstDayOfTheYear.getTime() +
			(firstDayOfTheYear.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000;

		return Math.floor(diff / (1000 * 60 * 60 * 24));
	}

	if (part === 'week') part = 'weekNumber';

	const unit = (DATETIMEUNIT_MAP[part] as keyof DateTime) || part;

	if (isDateTime(date)) return date.get(unit);

	return DateTime.fromJSDate(date).get(unit);
}

function format(date: Date | DateTime, extraArgs: unknown[]): string {
	const [dateFormat, localeOpts = {}] = extraArgs as [string, LocaleOptions];
	if (isDateTime(date)) {
		return date.toFormat(dateFormat, { ...localeOpts });
	}
	return DateTime.fromJSDate(date).toFormat(dateFormat, { ...localeOpts });
}

function isBetween(
	date: Date | DateTime,
	extraArgs: Array<string | Date | DateTime>,
): boolean | undefined {
	if (extraArgs.length !== 2) {
		throw new ExpressionExtensionError('isBetween(): expected exactly two args');
	}

	const [first, second] = extraArgs;

	const firstDate = convertToDateTime(first);
	const secondDate = convertToDateTime(second);

	if (!firstDate || !secondDate) {
		return;
	}

	if (firstDate > secondDate) {
		return secondDate < date && date < firstDate;
	}
	return secondDate > date && date > firstDate;
}

function isDst(date: Date | DateTime): boolean {
	if (isDateTime(date)) {
		return date.isInDST;
	}
	return DateTime.fromJSDate(date).isInDST;
}

function isInLast(date: Date | DateTime, extraArgs: unknown[]): boolean {
	const [durationValue = 0, unit = 'minutes'] = extraArgs as [number, DurationUnit];

	const dateInThePast = DateTime.now().minus(generateDurationObject(durationValue, unit));
	let thisDate = date;
	if (!isDateTime(thisDate)) {
		thisDate = DateTime.fromJSDate(thisDate);
	}
	return dateInThePast <= thisDate && thisDate <= DateTime.now();
}

const WEEKEND_DAYS: WeekdayNumbers[] = [6, 7];
function isWeekend(date: Date | DateTime): boolean {
	const { weekday } = isDateTime(date) ? date : DateTime.fromJSDate(date);
	return WEEKEND_DAYS.includes(weekday);
}

function minus(
	date: Date | DateTime,
	args: [DurationLike] | [number, DurationUnit],
): Date | DateTime {
	if (args.length === 1) {
		const [arg] = args;

		if (isDateTime(date)) return date.minus(arg);

		return DateTime.fromJSDate(date).minus(arg).toJSDate();
	}

	const [durationValue = 0, unit = 'minutes'] = args;

	const duration = generateDurationObject(durationValue, unit);

	if (isDateTime(date)) return date.minus(duration);

	return DateTime.fromJSDate(date).minus(duration).toJSDate();
}

function plus(
	date: Date | DateTime,
	args: [DurationLike] | [number, DurationUnit],
): Date | DateTime {
	if (args.length === 1) {
		const [arg] = args;

		if (isDateTime(date)) return date.plus(arg);

		return DateTime.fromJSDate(date).plus(arg).toJSDate();
	}

	const [durationValue = 0, unit = 'minutes'] = args;

	const duration = generateDurationObject(durationValue, unit);

	if (isDateTime(date)) return date.plus(duration);

	return DateTime.fromJSDate(date).plus(duration).toJSDate();
}

function diffTo(date: DateTime, args: [string | Date | DateTime, DurationUnit | DurationUnit[]]) {
	const [otherDate, unit = 'days'] = args;
	let units = Array.isArray(unit) ? unit : [unit];

	if (units.length === 0) {
		units = ['days'];
	}

	const allowedUnitSet = new Set([...dateParts, ...durationUnits]);
	const errorUnit = units.find((u) => !allowedUnitSet.has(u));

	if (errorUnit) {
		throw new ExpressionExtensionError(
			`Unsupported unit '${String(errorUnit)}'. Supported: ${durationUnits
				.map((u) => `'${u}'`)
				.join(', ')}.`,
		);
	}

	const diffResult = date.diff(toDateTime(otherDate), units);

	if (units.length > 1) {
		return diffResult.toObject();
	}

	return diffResult.as(units[0]);
}

function diffToNow(date: DateTime, args: [DurationUnit | DurationUnit[]]) {
	const [unit] = args;
	return diffTo(date, [DateTime.now(), unit]);
}

function toInt(date: Date | DateTime): number {
	if (isDateTime(date)) {
		return date.toMillis();
	}
	return date.getTime();
}

const toFloat = toInt;

function toBoolean() {
	return undefined;
}

// Only null/undefined return true, this is handled in ExpressionExtension.ts
function isEmpty(): boolean {
	return false;
}

function isNotEmpty(): boolean {
	return true;
}

endOfMonth.doc = {
	name: 'endOfMonth',
	returnType: 'DateTime',
	hidden: true,
	description: 'Transforms a date to the last possible moment that lies within the month.',
	section: 'edit',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-endOfMonth',
};

isDst.doc = {
	name: 'isDst',
	returnType: 'boolean',
	hidden: true,
	description: 'Checks if a Date is within Daylight Savings Time.',
	section: 'query',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isDst',
};

isWeekend.doc = {
	name: 'isWeekend',
	returnType: 'boolean',
	hidden: true,
	description: 'Checks if the Date falls on a Saturday or Sunday.',
	section: 'query',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isWeekend',
};

beginningOf.doc = {
	name: 'beginningOf',
	description: 'Transform a Date to the start of the given time period. Default unit is `week`.',
	section: 'edit',
	hidden: true,
	returnType: 'DateTime',
	args: [{ name: 'unit?', type: 'DurationUnit' }],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-beginningOf',
};

extract.doc = {
	name: 'extract',
	description:
		'Extracts a part of the date or time, e.g. the month, as a number. To extract textual names instead, see <code>format()</code>.',
	examples: [
		{ example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.extract('month')", evaluated: '3' },
		{ example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.extract('hour')", evaluated: '18' },
	],
	section: 'query',
	returnType: 'number',
	args: [
		{
			name: 'unit',
			optional: true,
			description:
				'The part of the date or time to return. One of: <code>year</code>, <code>month</code>, <code>week</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>',
			default: '"week"',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-extract',
};

format.doc = {
	name: 'format',
	description:
		'Converts the DateTime to a string, using the format specified. <a target="_blank" href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens">Formatting guide</a>. For common formats, <code>toLocaleString()</code> may be easier.',
	examples: [
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.format('dd/LL/yyyy')",
			evaluated: "'30/04/2024'",
		},
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.format('dd LLL yy')",
			evaluated: "'30 Apr 24'",
		},
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.setLocale('fr').format('dd LLL yyyy')",
			evaluated: "'30 avr. 2024'",
		},
		{
			example: "dt = '2024-04-30T18:49'.toDateTime()\ndt.format(\"HH 'hours and' mm 'minutes'\")",
			evaluated: "'18 hours and 49 minutes'",
		},
	],
	returnType: 'string',
	section: 'format',
	args: [
		{
			name: 'fmt',
			description:
				'The <a target="_blank" href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens">format</a> of the string to return ',
			default: "'yyyy-MM-dd'",
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-format',
};

isBetween.doc = {
	name: 'isBetween',
	description: 'Returns <code>true</code> if the DateTime lies between the two moments specified',
	examples: [
		{
			example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.isBetween('2020-06-01', '2025-06-01')",
			evaluated: 'true',
		},
		{
			example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.isBetween('2020', '2025')",
			evaluated: 'true',
		},
	],
	section: 'compare',
	returnType: 'boolean',
	args: [
		{
			name: 'date1',
			description:
				'The moment that the base DateTime must be after. Can be an ISO date string or a Luxon DateTime.',
			type: 'string | DateTime',
		},
		{
			name: 'date2',
			description:
				'The moment that the base DateTime must be before. Can be an ISO date string or a Luxon DateTime.',
			type: 'string | DateTime',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isBetween',
};

isInLast.doc = {
	name: 'isInLast',
	hidden: true,
	description: 'Checks if a Date is within a given time period. Default unit is `minute`.',
	section: 'query',
	returnType: 'boolean',
	args: [
		{ name: 'n', type: 'number' },
		{ name: 'unit?', type: 'DurationUnit' },
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-isInLast',
};

toDateTime.doc = {
	name: 'toDateTime',
	description:
		'Converts a JavaScript Date to a Luxon DateTime. The DateTime contains the same information, but is easier to manipulate.',
	examples: [
		{
			example: "jsDate = new Date('2024-03-30T18:49')\njsDate.toDateTime().plus(5, 'days')",
			evaluated: '[DateTime: 2024-05-05T18:49:00.000Z]',
		},
	],
	returnType: 'DateTime',
	hidden: true,
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-toDateTime',
};

minus.doc = {
	name: 'minus',
	description: 'Subtracts a given period of time from the DateTime',
	examples: [
		{
			example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.minus(7, 'days')",
			evaluated: '[DateTime: 2024-04-23T18:49:00.000Z]',
		},
		{
			example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.minus(4, 'years')",
			evaluated: '[DateTime: 2020-04-30T18:49:00.000Z]',
		},
	],
	section: 'edit',
	returnType: 'DateTime',
	args: [
		{
			name: 'n',
			description:
				'The number of units to subtract. Or use a Luxon <a target="_blank" href=”https://moment.github.io/luxon/api-docs/index.html#duration”>Duration</a> object to subtract multiple units at once.',
			type: 'number | object',
		},
		{
			name: 'unit',
			optional: true,
			description:
				'The units of the number. One of: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>',
			default: '"milliseconds"',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-minus',
};

plus.doc = {
	name: 'plus',
	description: 'Adds a given period of time to the DateTime',
	examples: [
		{
			example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.plus(7, 'days')",
			evaluated: '[DateTime: 2024-04-07T18:49:00.000Z]',
		},
		{
			example: "dt = '2024-03-30T18:49'.toDateTime()\ndt.plus(4, 'years')",
			evaluated: '[DateTime: 2028-03-30T18:49:00.000Z]',
		},
	],
	section: 'edit',
	returnType: 'DateTime',
	args: [
		{
			name: 'n',
			description:
				'The number of units to add. Or use a Luxon <a target="_blank" href=”https://moment.github.io/luxon/api-docs/index.html#duration”>Duration</a> object to add multiple units at once.',
			type: 'number | object',
		},
		{
			name: 'unit',
			optional: true,
			description:
				'The units of the number. One of: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>',
			default: '"milliseconds"',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-plus',
};

diffTo.doc = {
	name: 'diffTo',
	description: 'Returns the difference between two DateTimes, in the given unit(s)',
	examples: [
		{
			example: "dt = '2025-01-01'.toDateTime()\ndt.diffTo('2024-03-30T18:49:07.234', 'days')",
			evaluated: '276.21',
		},
		{
			example:
				"dt1 = '2025-01-01T00:00:00.000'.toDateTime();\ndt2 = '2024-03-30T18:49:07.234'.toDateTime();\ndt1.diffTo(dt2, ['months', 'days'])",
			evaluated: '{ months: 9, days: 1.21 }',
		},
	],
	section: 'compare',
	returnType: 'number | Record<DurationUnit, number>',
	args: [
		{
			name: 'otherDateTime',
			default: '$now',
			description:
				'The moment to subtract the base DateTime from. Can be an ISO date string or a Luxon DateTime.',
			type: 'string | DateTime',
		},
		{
			name: 'unit',
			default: "'days'",
			description:
				'The unit, or array of units, to return the result in. Possible values: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>.',
			type: 'string | string[]',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-diffTo',
};

diffToNow.doc = {
	name: 'diffToNow',
	description:
		'Returns the difference between the current moment and the DateTime, in the given unit(s). For a textual representation, use <code>toRelative()</code> instead.',
	examples: [
		{
			example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.diffToNow('days')",
			evaluated: '371.9',
		},
		{
			example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.diffToNow(['months', 'days'])",
			evaluated: '{ months: 12, days: 5.9 }',
		},
	],
	section: 'compare',
	returnType: 'number | Record<DurationUnit, number>',
	args: [
		{
			name: 'unit',
			description:
				'The unit, or array of units, to return the result in. Possible values: <code>years</code>, <code>months</code>, <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, <code>milliseconds</code>.',
			default: "'days'",
			type: 'string | string[]',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/dates/#date-diffToNow',
};

isEmpty.doc = {
	name: 'isEmpty',
	description:
		'Returns <code>false</code> for all DateTimes. Returns <code>true</code> for <code>null</code>.',
	examples: [
		{ example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.isEmpty()", evaluated: 'false' },
		{ example: 'dt = null\ndt.isEmpty()', evaluated: 'true' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isEmpty',
};

isNotEmpty.doc = {
	name: 'isNotEmpty',
	description:
		'Returns <code>true</code> for all DateTimes. Returns <code>false</code> for <code>null</code>.',
	examples: [
		{ example: "dt = '2023-03-30T18:49:07.234'.toDateTime()\ndt.isNotEmpty()", evaluated: 'true' },
		{ example: 'dt = null\ndt.isNotEmpty()', evaluated: 'false' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/arrays/#array-isNotEmpty',
};

export const dateExtensions: ExtensionMap = {
	typeName: 'Date',
	functions: {
		beginningOf,
		endOfMonth,
		extract,
		isBetween,
		isDst,
		isInLast,
		isWeekend,
		minus,
		plus,
		format,
		toDateTime,
		diffTo,
		diffToNow,
		toInt,
		toFloat,
		toBoolean,
		isEmpty,
		isNotEmpty,
	},
};



================================================
FILE: packages/workflow/src/extensions/expression-extension.ts
================================================
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import type { ExpressionKind } from 'ast-types/gen/kinds';
import type { Config as EsprimaConfig } from 'esprima-next';
import { parse as esprimaParse } from 'esprima-next';
import { DateTime } from 'luxon';
import { parse, visit, types, print } from 'recast';
import { getOption } from 'recast/lib/util';

import { arrayExtensions } from './array-extensions';
import { booleanExtensions } from './boolean-extensions';
import { dateExtensions } from './date-extensions';
import { joinExpression, splitExpression } from './expression-parser';
import type { ExpressionChunk, ExpressionCode } from './expression-parser';
import type { ExtensionMap } from './extensions';
import { numberExtensions } from './number-extensions';
import { objectExtensions } from './object-extensions';
import { stringExtensions } from './string-extensions';
import { checkIfValueDefinedOrThrow } from './utils';
import { ExpressionExtensionError } from '../errors/expression-extension.error';

const EXPRESSION_EXTENDER = 'extend';
const EXPRESSION_EXTENDER_OPTIONAL = 'extendOptional';

function isEmpty(value: unknown) {
	return value === null || value === undefined || !value;
}

function isNotEmpty(value: unknown) {
	return !isEmpty(value);
}

export const EXTENSION_OBJECTS: ExtensionMap[] = [
	arrayExtensions,
	dateExtensions,
	numberExtensions,
	objectExtensions,
	stringExtensions,
	booleanExtensions,
];

// eslint-disable-next-line @typescript-eslint/no-restricted-types
const genericExtensions: Record<string, Function> = {
	isEmpty,
	isNotEmpty,
};

const EXPRESSION_EXTENSION_METHODS = Array.from(
	new Set([
		...Object.keys(stringExtensions.functions),
		...Object.keys(numberExtensions.functions),
		...Object.keys(dateExtensions.functions),
		...Object.keys(arrayExtensions.functions),
		...Object.keys(objectExtensions.functions),
		...Object.keys(booleanExtensions.functions),
		...Object.keys(genericExtensions),
	]),
);

const EXPRESSION_EXTENSION_REGEX = new RegExp(
	`(\\$if|\\.(${EXPRESSION_EXTENSION_METHODS.join('|')})\\s*(\\?\\.)?)\\s*\\(`,
);

const isExpressionExtension = (str: string) => EXPRESSION_EXTENSION_METHODS.some((m) => m === str);

export const hasExpressionExtension = (str: string): boolean =>
	EXPRESSION_EXTENSION_REGEX.test(str);

export const hasNativeMethod = (method: string): boolean => {
	if (hasExpressionExtension(method)) {
		return false;
	}
	const methods = method
		.replace(/[^\w\s]/gi, ' ')
		.split(' ')
		.filter(Boolean); // DateTime.now().toLocaleString().format() => [DateTime,now,toLocaleString,format]
	return methods.every((methodName) => {
		return [String.prototype, Array.prototype, Number.prototype, Date.prototype].some(
			(nativeType) => {
				if (methodName in nativeType) {
					return true;
				}

				return false;
			},
		);
	});
};

// /**
//  * recast's types aren't great and we need to use a lot of anys
//  */

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function parseWithEsprimaNext(source: string, options?: any): any {
	const ast = esprimaParse(source, {
		loc: true,
		locations: true,
		comment: true,
		range: getOption(options, 'range', false) as boolean,
		tolerant: getOption(options, 'tolerant', true) as boolean,
		tokens: true,
		jsx: getOption(options, 'jsx', false) as boolean,
		sourceType: getOption(options, 'sourceType', 'module') as string,
	} as EsprimaConfig);

	return ast;
}

/**
 * A function to inject an extender function call into the AST of an expression.
 * This uses recast to do the transform.
 *
 * This function also polyfills optional chaining if using extended functions.
 *
 * ```ts
 * 'a'.method('x') // becomes
 * extend('a', 'method', ['x']);
 *
 * 'a'.first('x').second('y') // becomes
 * extend(extend('a', 'first', ['x']), 'second', ['y']));
 * ```
 */
export const extendTransform = (expression: string): { code: string } | undefined => {
	try {
		const ast = parse(expression, { parser: { parse: parseWithEsprimaNext } }) as types.ASTNode;

		let currentChain = 1;

		// Polyfill optional chaining
		visit(ast, {
			// eslint-disable-next-line complexity
			visitChainExpression(path) {
				this.traverse(path);
				const chainNumber = currentChain;
				currentChain += 1;

				// This is to match behavior in our original expression evaluator (tmpl)
				const globalIdentifier = types.builders.identifier(
					typeof window !== 'object' ? 'global' : 'window',
				);
				// We want to define all of our commonly used identifiers and member
				// expressions now so we don't have to create multiple instances
				const undefinedIdentifier = types.builders.identifier('undefined');
				const cancelIdentifier = types.builders.identifier(`chainCancelToken${chainNumber}`);
				const valueIdentifier = types.builders.identifier(`chainValue${chainNumber}`);
				const cancelMemberExpression = types.builders.memberExpression(
					globalIdentifier,
					cancelIdentifier,
				);
				const valueMemberExpression = types.builders.memberExpression(
					globalIdentifier,
					valueIdentifier,
				);

				const patchedStack: ExpressionKind[] = [];

				// This builds the cancel check. This lets us slide to the end of the expression
				// if it's undefined/null at any of the optional points of the chain.
				const buildCancelCheckWrapper = (node: ExpressionKind): ExpressionKind => {
					return types.builders.conditionalExpression(
						types.builders.binaryExpression(
							'===',
							cancelMemberExpression,
							types.builders.booleanLiteral(true),
						),
						undefinedIdentifier,
						node,
					);
				};

				// This is just a quick small wrapper to create the assignment expression
				// for the running value.
				const buildValueAssignWrapper = (node: ExpressionKind): ExpressionKind => {
					return types.builders.assignmentExpression('=', valueMemberExpression, node);
				};

				// This builds what actually does the comparison. It wraps the current
				// chunk of the expression with a nullish coalescing operator that returns
				// undefined if it's null or undefined. We do this because optional chains
				// always return undefined if they fail part way, even if the value they
				// fail on is null.
				const buildOptionalWrapper = (node: ExpressionKind): ExpressionKind => {
					return types.builders.binaryExpression(
						'===',
						types.builders.logicalExpression(
							'??',
							buildValueAssignWrapper(node),
							undefinedIdentifier,
						),
						undefinedIdentifier,
					);
				};

				// Another small wrapper, but for assigning to the cancel token this time.
				const buildCancelAssignWrapper = (node: ExpressionKind): ExpressionKind => {
					return types.builders.assignmentExpression('=', cancelMemberExpression, node);
				};

				let currentNode: ExpressionKind = path.node.expression;
				let currentPatch: ExpressionKind | null = null;
				let patchTop: ExpressionKind | null = null;
				let wrapNextTopInOptionalExtend = false;

				// This patches the previous node to use our current one as it's left hand value.
				// It takes `window.chainValue1.test1` and `window.chainValue1.test2` and turns it
				// into `window.chainValue1.test2.test1`.
				const updatePatch = (toPatch: ExpressionKind, node: ExpressionKind) => {
					if (toPatch.type === 'MemberExpression' || toPatch.type === 'OptionalMemberExpression') {
						toPatch.object = node;
					} else if (
						toPatch.type === 'CallExpression' ||
						toPatch.type === 'OptionalCallExpression'
					) {
						toPatch.callee = node;
					}
				};

				// This loop walks down an optional chain from the top. This will walk
				// from right to left through an optional chain. We keep track of our current
				// top of the chain (furthest right) and create a chain below it. This chain
				// contains all of the (member and call) expressions that we need. These are
				// patched versions that reference our current chain value. We then push this
				// chain onto a stack when we hit an optional point in our chain.
				while (true) {
					// This should only ever be these types but you can optional chain on
					// JSX nodes, which we don't support.
					if (
						currentNode.type === 'MemberExpression' ||
						currentNode.type === 'OptionalMemberExpression' ||
						currentNode.type === 'CallExpression' ||
						currentNode.type === 'OptionalCallExpression'
					) {
						let patchNode: ExpressionKind;
						// Here we take the current node and extract the parts we actually care
						// about.
						// In the case of a member expression we take the property it's trying to
						// access and make the object it's accessing be our chain value.
						if (
							currentNode.type === 'MemberExpression' ||
							currentNode.type === 'OptionalMemberExpression'
						) {
							patchNode = types.builders.memberExpression(
								valueMemberExpression,
								currentNode.property,
							);
							// In the case of a call expression we take the arguments and make the
							// callee our chain value.
						} else {
							patchNode = types.builders.callExpression(
								valueMemberExpression,
								currentNode.arguments,
							);
						}

						// If we have a previous node we patch it here.
						if (currentPatch) {
							updatePatch(currentPatch, patchNode);
						}

						// If we have no top patch (first run, or just pushed onto the stack) we
						// note it here.
						if (!patchTop) {
							patchTop = patchNode;
						}

						currentPatch = patchNode;

						// This is an optional in our chain. In here we'll push the node onto the
						// stack. We also do a polyfill if the top of the stack is function call
						// that might be a extended function.
						if (currentNode.optional) {
							// Implement polyfill described below
							if (wrapNextTopInOptionalExtend) {
								wrapNextTopInOptionalExtend = false;
								// This shouldn't ever happen
								if (
									patchTop.type === 'MemberExpression' &&
									patchTop.property.type === 'Identifier'
								) {
									patchTop = types.builders.callExpression(
										types.builders.identifier(EXPRESSION_EXTENDER_OPTIONAL),
										[patchTop.object, types.builders.stringLiteral(patchTop.property.name)],
									);
								}
							}

							patchedStack.push(patchTop);
							patchTop = null;
							currentPatch = null;

							// Attempting to optional chain on an extended function. If we don't
							// polyfill this most calls will always be undefined. Marking that the
							// next part of the chain should be wrapped in our polyfill.
							if (
								(currentNode.type === 'CallExpression' ||
									currentNode.type === 'OptionalCallExpression') &&
								(currentNode.callee.type === 'MemberExpression' ||
									currentNode.callee.type === 'OptionalMemberExpression') &&
								currentNode.callee.property.type === 'Identifier' &&
								isExpressionExtension(currentNode.callee.property.name)
							) {
								wrapNextTopInOptionalExtend = true;
							}
						}

						// Finally we get the next point AST to walk down.
						if (
							currentNode.type === 'MemberExpression' ||
							currentNode.type === 'OptionalMemberExpression'
						) {
							currentNode = currentNode.object;
						} else {
							currentNode = currentNode.callee;
						}
					} else {
						// We update the final patch to point to the first part of the optional chain
						// which is probably an identifier for an object.
						if (currentPatch) {
							updatePatch(currentPatch, currentNode);
							if (!patchTop) {
								patchTop = currentPatch;
							}
						}

						if (wrapNextTopInOptionalExtend) {
							wrapNextTopInOptionalExtend = false;
							// This shouldn't ever happen
							if (
								patchTop?.type === 'MemberExpression' &&
								patchTop.property.type === 'Identifier'
							) {
								patchTop = types.builders.callExpression(
									types.builders.identifier(EXPRESSION_EXTENDER_OPTIONAL),
									[patchTop.object, types.builders.stringLiteral(patchTop.property.name)],
								);
							}
						}

						// Push the first part of our chain to stack.
						if (patchTop) {
							patchedStack.push(patchTop);
						} else {
							patchedStack.push(currentNode);
						}
						break;
					}
				}

				// Since we're working from right to left we need to flip the stack
				// for the correct order of operations
				patchedStack.reverse();

				// Walk the node stack and wrap all our expressions in cancel/assignment
				// wrappers.
				for (let i = 0; i < patchedStack.length; i++) {
					let node = patchedStack[i];

					// We don't wrap the last expression in an assignment wrapper because
					// it's going to be returned anyway. We just wrap it in a cancel check
					// wrapper.
					if (i !== patchedStack.length - 1) {
						node = buildCancelAssignWrapper(buildOptionalWrapper(node));
					}

					// Don't wrap the first part in a cancel wrapper because the cancel
					// token will always be undefined.
					if (i !== 0) {
						node = buildCancelCheckWrapper(node);
					}

					// Replace the node in the stack with our wrapped one
					patchedStack[i] = node;
				}

				// Put all our expressions in a sequence expression (also called a
				// group operator). These will all be executed in order and the value
				// of the final expression will be returned.
				const sequenceNode = types.builders.sequenceExpression(patchedStack);

				path.replace(sequenceNode);
			},
		});

		// Extended functions
		visit(ast, {
			visitCallExpression(path) {
				this.traverse(path);

				if (
					path.node.callee.type === 'MemberExpression' &&
					path.node.callee.property.type === 'Identifier' &&
					isExpressionExtension(path.node.callee.property.name)
				) {
					path.replace(
						types.builders.callExpression(types.builders.identifier(EXPRESSION_EXTENDER), [
							path.node.callee.object,
							types.builders.stringLiteral(path.node.callee.property.name),
							types.builders.arrayExpression(path.node.arguments),
						]),
					);
				} else if (
					path.node.callee.type === 'Identifier' &&
					path.node.callee.name === '$if' &&
					path.node.arguments.every((v) => v.type !== 'SpreadElement')
				) {
					if (path.node.arguments.length < 2) {
						throw new ExpressionExtensionError(
							'$if requires at least 2 parameters: test, value_if_true[, and value_if_false]',
						);
					}

					const test = path.node.arguments[0];
					const consequent = path.node.arguments[1];
					const alternative =
						path.node.arguments[2] === undefined
							? types.builders.booleanLiteral(false)
							: path.node.arguments[2];

					path.replace(
						types.builders.conditionalExpression(
							// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
							test as any,
							// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
							consequent as any,
							// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
							alternative as any,
						),
					);
				}
			},
		});

		return print(ast);
	} catch (e) {
		return;
	}
};

function isDate(input: unknown): boolean {
	if (typeof input !== 'string' || !input.length) {
		return false;
	}
	if (!/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(input)) {
		return false;
	}
	const d = new Date(input);
	return d instanceof Date && !isNaN(d.valueOf()) && d.toISOString() === input;
}

interface FoundFunction {
	type: 'native' | 'extended';
	// eslint-disable-next-line @typescript-eslint/no-restricted-types
	function: Function;
}

function findExtendedFunction(input: unknown, functionName: string): FoundFunction | undefined {
	// eslint-disable-next-line @typescript-eslint/no-restricted-types
	let foundFunction: Function | undefined;
	if (Array.isArray(input)) {
		foundFunction = arrayExtensions.functions[functionName];
	} else if (isDate(input) && functionName !== 'toDate' && functionName !== 'toDateTime') {
		// If it's a string date (from $json), convert it to a Date object,
		// unless that function is `toDate`, since `toDate` does something
		// very different on date objects
		input = new Date(input as string);
		foundFunction = dateExtensions.functions[functionName];
	} else if (typeof input === 'string') {
		foundFunction = stringExtensions.functions[functionName];
	} else if (typeof input === 'number') {
		foundFunction = numberExtensions.functions[functionName];
	} else if (input && (DateTime.isDateTime(input) || input instanceof Date)) {
		foundFunction = dateExtensions.functions[functionName];
	} else if (input !== null && typeof input === 'object') {
		foundFunction = objectExtensions.functions[functionName];
	} else if (typeof input === 'boolean') {
		foundFunction = booleanExtensions.functions[functionName];
	}

	// Look for generic or builtin
	if (!foundFunction) {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const inputAny: any = input;
		// This is likely a builtin we're implementing for another type
		// (e.g. toLocaleString). We'll return that instead
		if (inputAny && functionName && typeof inputAny[functionName] === 'function') {
			// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
			return { type: 'native', function: inputAny[functionName] };
		}

		// Use a generic version if available
		foundFunction = genericExtensions[functionName];
	}

	if (!foundFunction) {
		return undefined;
	}

	return { type: 'extended', function: foundFunction };
}

/**
 * Extender function injected by expression extension plugin to allow calls to extensions.
 *
 * ```ts
 * extend(input, "functionName", [...args]);
 * ```
 */
export function extend(input: unknown, functionName: string, args: unknown[]) {
	const foundFunction = findExtendedFunction(input, functionName);

	// No type specific or generic function found. Check to see if
	// any types have a function with that name. Then throw an error
	// letting the user know the available types.
	if (!foundFunction) {
		checkIfValueDefinedOrThrow(input, functionName);
		const haveFunction = EXTENSION_OBJECTS.filter((v) => functionName in v.functions);
		if (!haveFunction.length) {
			// This shouldn't really be possible but we should cover it anyway
			throw new ExpressionExtensionError(`Unknown expression function: ${functionName}`);
		}

		if (haveFunction.length > 1) {
			const lastType = `"${haveFunction.pop()!.typeName}"`;
			const typeNames = `${haveFunction.map((v) => `"${v.typeName}"`).join(', ')}, and ${lastType}`;
			throw new ExpressionExtensionError(
				`${functionName}() is only callable on types ${typeNames}`,
			);
		} else {
			throw new ExpressionExtensionError(
				`${functionName}() is only callable on type "${haveFunction[0].typeName}"`,
			);
		}
	}

	if (foundFunction.type === 'native') {
		// eslint-disable-next-line @typescript-eslint/no-unsafe-return
		return foundFunction.function.apply(input, args);
	}

	// eslint-disable-next-line @typescript-eslint/no-unsafe-return
	return foundFunction.function(input, args);
}

export function extendOptional(
	input: unknown,
	functionName: string,
	// eslint-disable-next-line @typescript-eslint/no-restricted-types
): Function | undefined {
	const foundFunction = findExtendedFunction(input, functionName);

	if (!foundFunction) {
		return undefined;
	}

	if (foundFunction.type === 'native') {
		// eslint-disable-next-line @typescript-eslint/no-unsafe-return
		return foundFunction.function.bind(input);
	}

	return (...args: unknown[]) => {
		// eslint-disable-next-line @typescript-eslint/no-unsafe-return
		return foundFunction.function(input, args);
	};
}

const EXTENDED_SYNTAX_CACHE: Record<string, string> = {};

export function extendSyntax(bracketedExpression: string, forceExtend = false): string {
	const chunks = splitExpression(bracketedExpression);

	const codeChunks = chunks
		.filter((c) => c.type === 'code')
		.map((c) => c.text.replace(/("|').*?("|')/, '').trim());

	if (
		(!codeChunks.some(hasExpressionExtension) || hasNativeMethod(bracketedExpression)) &&
		!forceExtend
	) {
		return bracketedExpression;
	}

	// If we've seen this expression before grab it from the cache
	if (bracketedExpression in EXTENDED_SYNTAX_CACHE) {
		return EXTENDED_SYNTAX_CACHE[bracketedExpression];
	}

	const extendedChunks = chunks.map((chunk): ExpressionChunk => {
		if (chunk.type === 'code') {
			let output = extendTransform(chunk.text);

			// esprima fails to parse bare objects (e.g. `{ data: something }`), we can
			// work around this by wrapping it in an parentheses
			if (!output?.code && chunk.text.trim()[0] === '{') {
				output = extendTransform(`(${chunk.text})`);
			}

			if (!output?.code) {
				throw new ExpressionExtensionError('invalid syntax');
			}

			let text = output.code;

			// We need to cut off any trailing semicolons. These cause issues
			// with certain types of expression and cause the whole expression
			// to fail.
			if (text.trim().endsWith(';')) {
				text = text.trim().slice(0, -1);
			}

			return {
				...chunk,
				text,
			} as ExpressionCode;
		}
		return chunk;
	});

	const expression = joinExpression(extendedChunks);
	// Cache the expression so we don't have to do this transform again
	EXTENDED_SYNTAX_CACHE[bracketedExpression] = expression;
	return expression;
}



================================================
FILE: packages/workflow/src/extensions/expression-parser.ts
================================================
export interface ExpressionText {
	type: 'text';
	text: string;
}

export interface ExpressionCode {
	type: 'code';
	text: string;

	// This is to match behavior in our original expression evaluator (tmpl),
	// which has different behaviours if the last expression doesn't close itself.
	hasClosingBrackets: boolean;
}

export type ExpressionChunk = ExpressionCode | ExpressionText;

const OPEN_BRACKET = /(?<escape>\\|)(?<brackets>\{\{)/;
const CLOSE_BRACKET = /(?<escape>\\|)(?<brackets>\}\})/;

export const escapeCode = (text: string): string => {
	return text.replace('\\}}', '}}');
};

export const splitExpression = (expression: string): ExpressionChunk[] => {
	const chunks: ExpressionChunk[] = [];
	let searchingFor: 'open' | 'close' = 'open';
	let activeRegex = OPEN_BRACKET;

	let buffer = '';

	let index = 0;

	while (index < expression.length) {
		const expr = expression.slice(index);
		const res = activeRegex.exec(expr);
		// No more brackets. If it's a closing bracket
		// this is sort of valid so we accept it but mark
		// that it has no closing bracket.
		if (!res?.groups) {
			buffer += expr;
			if (searchingFor === 'open') {
				chunks.push({
					type: 'text',
					text: buffer,
				});
			} else {
				chunks.push({
					type: 'code',
					text: escapeCode(buffer),
					hasClosingBrackets: false,
				});
			}
			break;
		}
		if (res.groups.escape) {
			buffer += expr.slice(0, res.index + 3);
			index += res.index + 3;
		} else {
			buffer += expr.slice(0, res.index);

			if (searchingFor === 'open') {
				chunks.push({
					type: 'text',
					text: buffer,
				});
				searchingFor = 'close';
				activeRegex = CLOSE_BRACKET;
			} else {
				chunks.push({
					type: 'code',
					text: escapeCode(buffer),
					hasClosingBrackets: true,
				});
				searchingFor = 'open';
				activeRegex = OPEN_BRACKET;
			}

			index += res.index + 2;
			buffer = '';
		}
	}

	return chunks;
};

// Expressions only have closing brackets escaped
const escapeTmplExpression = (part: string) => {
	return part.replace('}}', '\\}}');
};

export const joinExpression = (parts: ExpressionChunk[]): string => {
	return parts
		.map((chunk) => {
			if (chunk.type === 'code') {
				return `{{${escapeTmplExpression(chunk.text)}${chunk.hasClosingBrackets ? '}}' : ''}`;
			}
			return chunk.text;
		})
		.join('');
};



================================================
FILE: packages/workflow/src/extensions/extended-functions.ts
================================================
import { average as aAverage } from './array-extensions';
import { ExpressionExtensionError } from '../errors/expression-extension.error';
import { ExpressionError } from '../errors/expression.error';

const min = Math.min;
const max = Math.max;

const numberList = (start: number, end: number): number[] => {
	const size = Math.abs(start - end) + 1;
	const arr = new Array<number>(size);

	let curr = start;
	for (let i = 0; i < size; i++) {
		if (start < end) {
			arr[i] = curr++;
		} else {
			arr[i] = curr--;
		}
	}

	return arr;
};

const zip = (keys: unknown[], values: unknown[]): unknown => {
	if (keys.length !== values.length) {
		throw new ExpressionExtensionError('keys and values not of equal length');
	}
	return keys.reduce((p, c, i) => {
		// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
		(p as any)[c as any] = values[i];
		return p;
	}, {});
};

const average = (...args: number[]) => {
	return aAverage(args);
};

const not = (value: unknown): boolean => {
	return !value;
};

function ifEmpty<T, V>(value: V, defaultValue: T) {
	if (arguments.length !== 2) {
		throw new ExpressionError('expected two arguments (value, defaultValue) for this function');
	}
	if (value === undefined || value === null || value === '') {
		return defaultValue;
	}
	if (typeof value === 'object') {
		if (Array.isArray(value) && !value.length) {
			return defaultValue;
		}
		if (!Object.keys(value).length) {
			return defaultValue;
		}
	}
	return value;
}

ifEmpty.doc = {
	name: 'ifEmpty',
	description:
		'Returns the default value if the value is empty. Empty values are undefined, null, empty strings, arrays without elements and objects without keys.',
	returnType: 'any',
	args: [
		{ name: 'value', type: 'any' },
		{ name: 'defaultValue', type: 'any' },
	],
	docURL: 'https://docs.n8n.io/code/builtin/convenience',
};

export const extendedFunctions = {
	min,
	max,
	not,
	average,
	numberList,
	zip,
	$min: min,
	$max: max,
	$average: average,
	$not: not,
	$ifEmpty: ifEmpty,
};



================================================
FILE: packages/workflow/src/extensions/extensions.ts
================================================
export interface ExtensionMap {
	typeName: string;
	functions: Record<string, Extension>;
}

// eslint-disable-next-line @typescript-eslint/no-restricted-types
export type Extension = Function & { doc?: DocMetadata };

export type NativeDoc = {
	typeName: string;
	properties?: Record<string, { doc?: DocMetadata }>;
	functions: Record<string, { doc?: DocMetadata }>;
};

export type DocMetadataArgument = {
	name: string;
	type?: string;
	optional?: boolean;
	variadic?: boolean;
	description?: string;
	default?: string;
	// Function arguments have nested arguments
	args?: DocMetadataArgument[];
};
export type DocMetadataExample = {
	example: string;
	evaluated?: string;
	description?: string;
};

export type DocMetadata = {
	name: string;
	returnType: string;
	description?: string;
	section?: string;
	hidden?: boolean;
	aliases?: string[];
	args?: DocMetadataArgument[];
	examples?: DocMetadataExample[];
	docURL?: string;
};



================================================
FILE: packages/workflow/src/extensions/index.ts
================================================
export {
	extend,
	extendOptional,
	hasExpressionExtension,
	hasNativeMethod,
	extendTransform,
	EXTENSION_OBJECTS as ExpressionExtensions,
} from './expression-extension';

export type {
	DocMetadata,
	NativeDoc,
	Extension,
	DocMetadataArgument,
	DocMetadataExample,
} from './extensions';



================================================
FILE: packages/workflow/src/extensions/number-extensions.ts
================================================
// @vitest-environment jsdom
import { DateTime } from 'luxon';

import type { ExtensionMap } from './extensions';
import { ExpressionExtensionError } from '../errors/expression-extension.error';

function format(value: number, extraArgs: unknown[]): string {
	const [locales = 'en-US', config = {}] = extraArgs as [
		string | string[],
		Intl.NumberFormatOptions,
	];

	return new Intl.NumberFormat(locales, config).format(value);
}

function isEven(value: number) {
	if (!Number.isInteger(value)) {
		throw new ExpressionExtensionError('isEven() is only callable on integers');
	}
	return value % 2 === 0;
}

function isOdd(value: number) {
	if (!Number.isInteger(value)) {
		throw new ExpressionExtensionError('isOdd() is only callable on integers');
	}
	return Math.abs(value) % 2 === 1;
}

function floor(value: number) {
	return Math.floor(value);
}

function ceil(value: number) {
	return Math.ceil(value);
}

function abs(value: number) {
	return Math.abs(value);
}

function isInteger(value: number) {
	return Number.isInteger(value);
}

function round(value: number, extraArgs: number[]) {
	const [decimalPlaces = 0] = extraArgs;
	return +value.toFixed(decimalPlaces);
}

function toBoolean(value: number) {
	return value !== 0;
}

function toInt(value: number) {
	return round(value, []);
}

function toFloat(value: number) {
	return value;
}

type DateTimeFormat = 'ms' | 's' | 'us' | 'excel';
export function toDateTime(value: number, extraArgs: [DateTimeFormat]) {
	const [valueFormat = 'ms'] = extraArgs;

	if (!['ms', 's', 'us', 'excel'].includes(valueFormat)) {
		throw new ExpressionExtensionError(
			`Unsupported format '${String(valueFormat)}'. toDateTime() supports 'ms', 's', 'us' and 'excel'.`,
		);
	}

	switch (valueFormat) {
		// Excel format is days since 1900
		// There is a bug where 1900 is incorrectly treated as a leap year
		case 'excel': {
			const DAYS_BETWEEN_1900_1970 = 25567;
			const DAYS_LEAP_YEAR_BUG_ADJUST = 2;
			const SECONDS_IN_DAY = 86_400;
			return DateTime.fromSeconds(
				(value - (DAYS_BETWEEN_1900_1970 + DAYS_LEAP_YEAR_BUG_ADJUST)) * SECONDS_IN_DAY,
			);
		}
		case 's':
			return DateTime.fromSeconds(value);
		case 'us':
			return DateTime.fromMillis(value / 1000);
		case 'ms':
		default:
			return DateTime.fromMillis(value);
	}
}

ceil.doc = {
	name: 'ceil',
	description: 'Rounds the number up to the next whole number',
	examples: [{ example: '(1.234).ceil()', evaluated: '2' }],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-ceil',
};

floor.doc = {
	name: 'floor',
	description: 'Rounds the number down to the nearest whole number',
	examples: [{ example: '(1.234).floor()', evaluated: '1' }],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-floor',
};

isEven.doc = {
	name: 'isEven',
	description:
		"Returns <code>true</code> if the number is even or <code>false</code> if not. Throws an error if the number isn't a whole number.",
	examples: [
		{ example: '(33).isEven()', evaluated: 'false' },
		{ example: '(42).isEven()', evaluated: 'true' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-isEven',
};

isOdd.doc = {
	name: 'isOdd',
	description:
		"Returns <code>true</code> if the number is odd or <code>false</code> if not. Throws an error if the number isn't a whole number.",
	examples: [
		{ example: '(33).isOdd()', evaluated: 'true' },
		{ example: '(42).isOdd()', evaluated: 'false' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-isOdd',
};

format.doc = {
	name: 'format',
	description:
		'Returns a formatted string representing the number. Useful for formatting for a specific language or currency. The same as <a target="_blank" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat”><code>Intl.NumberFormat()</code></a>.',
	examples: [
		{ example: "(123456.789).format('de-DE')", evaluated: '123.456,789' },
		{
			example: "(123456.789).format('de-DE', {'style': 'currency', 'currency': 'EUR'})",
			evaluated: '123.456,79 €',
		},
	],
	returnType: 'string',
	args: [
		{
			name: 'locale',
			optional: true,
			description:
				'A <a target="_blank" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument”>locale tag</a> for formatting the number, e.g. <code>fr-FR</code>, <code>en-GB</code>, <code>pr-BR</code>',
			default: '"en-US"',
			type: 'string',
		},
		{
			name: 'options',
			optional: true,
			description:
				'Configuration options for number formatting. <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat" target="_blank">More info</a>',
			type: 'object',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-format',
};

round.doc = {
	name: 'round',
	description: 'Rounds the number to the nearest integer (or decimal place)',
	examples: [
		{ example: '(1.256).round()', evaluated: '1' },
		{ example: '(1.256).round(1)', evaluated: '1.3' },
		{ example: '(1.256).round(2)', evaluated: '1.26' },
	],
	returnType: 'number',
	args: [
		{
			name: 'decimalPlaces',
			optional: true,
			description: 'The number of decimal places to round to',
			default: '0',
			type: 'number',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-round',
};

toBoolean.doc = {
	name: 'toBoolean',
	description:
		'Returns <code>false</code> for <code>0</code> and <code>true</code> for any other number (including negative numbers).',
	examples: [
		{ example: '(12).toBoolean()', evaluated: 'true' },
		{ example: '(0).toBoolean()', evaluated: 'false' },
		{ example: '(-1.3).toBoolean()', evaluated: 'true' },
	],
	section: 'cast',
	returnType: 'boolean',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-toBoolean',
};

toDateTime.doc = {
	name: 'toDateTime',
	description:
		'Converts a numerical timestamp into a <a target="_blank" href="https://moment.github.io/luxon/api-docs/">Luxon</a> DateTime. The format of the timestamp must be specified if it\'s not in milliseconds. Uses the timezone specified in workflow settings if available; otherwise, it defaults to the timezone set for the instance.',
	examples: [
		{ example: "(1708695471).toDateTime('s')", evaluated: '2024-02-23T14:37:51.000+01:00' },
		{ example: "(1708695471000).toDateTime('ms')", evaluated: '2024-02-23T14:37:51.000+01:00' },
		{ example: "(1708695471000000).toDateTime('us')", evaluated: '2024-02-23T14:37:51.000+01:00' },
		{ example: "(45345).toDateTime('excel')", evaluated: '2024-02-23T01:00:00.000+01:00' },
	],
	section: 'cast',
	returnType: 'DateTime',
	args: [
		{
			name: 'format',
			optional: true,
			description:
				'The type of timestamp to convert. Options are <code>ms</code> (for Unix timestamp in milliseconds), <code>s</code> (for Unix timestamp in seconds), <code>us</code> (for Unix timestamp in microseconds) or <code>excel</code> (for days since 1900).',
			default: '"ms"',
			type: 'string',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-toDateTime',
};

abs.doc = {
	name: 'abs',
	description: "Returns the number's absolute value, i.e. removes any minus sign",
	examples: [
		{ example: '(-1.7).abs()', evaluated: '1.7' },
		{ example: '(1.7).abs()', evaluated: '1.7' },
	],
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-abs',
};

isInteger.doc = {
	name: 'isInteger',
	description: 'Returns <code>true</code> if the number is a whole number',
	examples: [
		{ example: '(4).isInteger()', evaluated: 'true' },
		{ example: '(4.12).isInteger()', evaluated: 'false' },
		{ example: '(-4).isInteger()', evaluated: 'true' },
	],
	returnType: 'boolean',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/numbers/#number-isInteger',
};

export const numberExtensions: ExtensionMap = {
	typeName: 'Number',
	functions: {
		ceil,
		floor,
		format,
		round,
		abs,
		isInteger,
		isEven,
		isOdd,
		toBoolean,
		toInt,
		toFloat,
		toDateTime,
	},
};



================================================
FILE: packages/workflow/src/extensions/object-extensions.ts
================================================
import type { ExtensionMap } from './extensions';
import { ExpressionExtensionError } from '../errors/expression-extension.error';

function isEmpty(value: object): boolean {
	return Object.keys(value).length === 0;
}

function isNotEmpty(value: object): boolean {
	return !isEmpty(value);
}

function keys(value: object): string[] {
	return Object.keys(value);
}

function values(value: object): unknown[] {
	return Object.values(value);
}

function hasField(value: object, extraArgs: string[]): boolean {
	const [name] = extraArgs;
	return name in value;
}

function removeField(value: object, extraArgs: string[]): object {
	const [name] = extraArgs;
	if (name in value) {
		const newObject = { ...value };
		// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
		delete (newObject as any)[name];
		return newObject;
	}
	return value;
}

function removeFieldsContaining(value: object, extraArgs: string[]): object {
	const [match] = extraArgs;
	if (typeof match !== 'string' || match === '') {
		throw new ExpressionExtensionError('removeFieldsContaining(): expected non-empty string arg');
	}
	const newObject = { ...value };
	for (const [key, val] of Object.entries(value)) {
		if (typeof val === 'string' && val.includes(match)) {
			// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
			delete (newObject as any)[key];
		}
	}
	return newObject;
}

function keepFieldsContaining(value: object, extraArgs: string[]): object {
	const [match] = extraArgs;
	if (typeof match !== 'string' || match === '') {
		throw new ExpressionExtensionError(
			'argument of keepFieldsContaining must be a non-empty string',
		);
	}
	const newObject = { ...value };
	for (const [key, val] of Object.entries(value)) {
		if (typeof val !== 'string' || (typeof val === 'string' && !val.includes(match))) {
			// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
			delete (newObject as any)[key];
		}
	}
	return newObject;
}

export function compact(value: object): object {
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const newObj: any = {};
	for (const [key, val] of Object.entries(value)) {
		if (val !== null && val !== undefined && val !== 'nil' && val !== '') {
			if (typeof val === 'object') {
				if (Object.keys(val as object).length === 0) continue;
				// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument
				newObj[key] = compact(val);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
				newObj[key] = val;
			}
		}
	}
	// eslint-disable-next-line @typescript-eslint/no-unsafe-return
	return newObj;
}

export function urlEncode(value: object) {
	return new URLSearchParams(value as Record<string, string>).toString();
}

export function toJsonString(value: object) {
	return JSON.stringify(value);
}

export function toInt() {
	return undefined;
}

export function toFloat() {
	return undefined;
}

export function toBoolean() {
	return undefined;
}

export function toDateTime() {
	return undefined;
}

isEmpty.doc = {
	name: 'isEmpty',
	description:
		'Returns <code>true</code> if the Object has no keys (fields) set or is <code>null</code>',
	examples: [
		{ example: "({'name': 'Nathan'}).isEmpty()", evaluated: 'false' },
		{ example: '({}).isEmpty()', evaluated: 'true' },
	],
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-isEmpty',
};

isNotEmpty.doc = {
	name: 'isNotEmpty',
	description: 'Returns <code>true</code> if the Object has at least one key (field) set',
	examples: [
		{ example: "({'name': 'Nathan'}).isNotEmpty()", evaluated: 'true' },
		{ example: '({}).isNotEmpty()', evaluated: 'false' },
	],
	returnType: 'boolean',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-isNotEmpty',
};

compact.doc = {
	name: 'compact',
	description:
		'Removes all fields that have empty values, i.e. are <code>null</code>, <code>undefined</code>, <code>"nil"</code> or <code>""</code>',
	examples: [{ example: "({ x: null, y: 2, z: '' }).compact()", evaluated: '{ y: 2 }' }],
	returnType: 'Object',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-compact',
};

urlEncode.doc = {
	name: 'urlEncode',
	description:
		"Generates a URL parameter string from the Object's keys and values. Only top-level keys are supported.",
	examples: [
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi' }).urlEncode()",
			evaluated: "'name=Mr+Nathan&city=hanoi'",
		},
	],
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-urlEncode',
};

hasField.doc = {
	name: 'hasField',
	description:
		'Returns <code>true</code> if there is a field called <code>name</code>. Only checks top-level keys. Comparison is case-sensitive.',
	examples: [
		{ example: "({ name: 'Nathan', age: 42 }).hasField('name')", evaluated: 'true' },
		{ example: "({ name: 'Nathan', age: 42 }).hasField('Name')", evaluated: 'false' },
		{ example: "({ name: 'Nathan', age: 42 }).hasField('inventedField')", evaluated: 'false' },
	],
	returnType: 'boolean',
	args: [
		{
			name: 'name',
			optional: false,
			description: 'The name of the key to search for',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-hasField',
};

removeField.doc = {
	name: 'removeField',
	description: "Removes a field from the Object. The same as JavaScript's <code>delete</code>.",
	examples: [
		{
			example: "({ name: 'Nathan', city: 'hanoi' }).removeField('name')",
			evaluated: "{ city: 'hanoi' }",
		},
	],
	returnType: 'Object',
	args: [
		{
			name: 'key',
			optional: false,
			description: 'The name of the field to remove',
			type: 'string',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-removeField',
};

removeFieldsContaining.doc = {
	name: 'removeFieldsContaining',
	description:
		"Removes keys (fields) whose values at least partly match the given <code>value</code>. Comparison is case-sensitive. Fields that aren't strings are always kept.",
	examples: [
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).removeFieldsContaining('Nathan')",
			evaluated: "{ city: 'hanoi', age: 42 }",
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).removeFieldsContaining('Han')",
			evaluated: '{ age: 42 }',
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).removeFieldsContaining('nathan')",
			evaluated: "{ name: 'Mr Nathan', city: 'hanoi', age: 42 }",
		},
	],
	returnType: 'Object',
	args: [
		{
			name: 'value',
			optional: false,
			description: 'The text that a value must contain in order to be removed',
			type: 'string',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-removeFieldsContaining',
};

keepFieldsContaining.doc = {
	name: 'keepFieldsContaining',
	description:
		"Removes any fields whose values don't at least partly match the given <code>value</code>. Comparison is case-sensitive. Fields that aren't strings will always be removed.",
	examples: [
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).keepFieldsContaining('Nathan')",
			evaluated: "{ name: 'Mr Nathan' }",
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).keepFieldsContaining('nathan')",
			evaluated: '{}',
		},
		{
			example: "({ name: 'Mr Nathan', city: 'hanoi', age: 42 }).keepFieldsContaining('han')",
			evaluated: "{ name: 'Mr Nathan', city: 'hanoi' }",
		},
	],
	returnType: 'Object',
	args: [
		{
			name: 'value',
			optional: false,
			description: 'The text that a value must contain in order to be kept',
			type: 'string',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-keepFieldsContaining',
};

keys.doc = {
	name: 'keys',
	description:
		"Returns an array with all the field names (keys) the Object contains. The same as JavaScript's <code>Object.keys(obj)</code>.",
	examples: [{ example: "({ name: 'Mr Nathan', age: 42 }).keys()", evaluated: "['name', 'age']" }],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-keys',
	returnType: 'Array',
};

values.doc = {
	name: 'values',
	description:
		"Returns an array with all the values of the fields the Object contains. The same as JavaScript's <code>Object.values(obj)</code>.",
	examples: [
		{ example: "({ name: 'Mr Nathan', age: 42 }).values()", evaluated: "['Mr Nathan', 42]" },
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-values',
	returnType: 'Array',
};

toJsonString.doc = {
	name: 'toJsonString',
	description:
		"Converts the Object to a JSON string. Similar to JavaScript's <code>JSON.stringify()</code>.",
	examples: [
		{
			example: "({ name: 'Mr Nathan', age: 42 }).toJsonString()",
			evaluated: '\'{"name":"Nathan","age":42}\'',
		},
	],
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/objects/#object-toJsonString',
	returnType: 'string',
};

export const objectExtensions: ExtensionMap = {
	typeName: 'Object',
	functions: {
		isEmpty,
		isNotEmpty,
		hasField,
		removeField,
		removeFieldsContaining,
		keepFieldsContaining,
		compact,
		urlEncode,
		keys,
		values,
		toJsonString,
		toInt,
		toFloat,
		toBoolean,
		toDateTime,
	},
};



================================================
FILE: packages/workflow/src/extensions/string-extensions.ts
================================================
import { toBase64, fromBase64 } from 'js-base64';
import SHA from 'jssha';
import { DateTime } from 'luxon';
import MD5 from 'md5';
import { titleCase } from 'title-case';
import { transliterate } from 'transliteration';

import type { Extension, ExtensionMap } from './extensions';
import { toDateTime as numberToDateTime } from './number-extensions';
import { ExpressionExtensionError } from '../errors/expression-extension.error';
import { tryToParseDateTime } from '../type-validation';

export const SupportedHashAlgorithms = [
	'md5',
	'sha1',
	'sha224',
	'sha256',
	'sha384',
	'sha512',
	'sha3',
] as const;

// All symbols from https://www.xe.com/symbols/ as for 2022/11/09
const CURRENCY_REGEXP =
	/(\u004c\u0065\u006b|\u060b|\u0024|\u0192|\u20bc|\u0042\u0072|\u0042\u005a\u0024|\u0024\u0062|\u004b\u004d|\u0050|\u043b\u0432|\u0052\u0024|\u17db|\u00a5|\u20a1|\u006b\u006e|\u20b1|\u004b\u010d|\u006b\u0072|\u0052\u0044\u0024|\u00a3|\u20ac|\u00a2|\u0051|\u004c|\u0046\u0074|\u20b9|\u0052\u0070|\ufdfc|\u20aa|\u004a\u0024|\u20a9|\u20ad|\u0434\u0435\u043d|\u0052\u004d|\u20a8|\u20ae|\u004d\u0054|\u0043\u0024|\u20a6|\u0042\u002f\u002e|\u0047\u0073|\u0053\u002f\u002e|\u007a\u0142|\u006c\u0065\u0069|\u20bd|\u0414\u0438\u043d\u002e|\u0053|\u0052|\u0043\u0048\u0046|\u004e\u0054\u0024|\u0e3f|\u0054\u0054\u0024|\u20ba|\u20b4|\u0024\u0055|\u0042\u0073|\u20ab|\u005a\u0024)/gu;

/*
	Extract the domain part from various inputs, including URLs, email addresses, and plain domains.

	/^(?:(?:https?|ftp):\/\/)? 								// Match optional http, https, or ftp protocols
  (?:mailto:)?               								// Match optional mailto:
  (?:\/\/)?                  								// Match optional double slashes
  (?:www\.)?                 								// Match optional www prefix
  (?:[-\w]*\.)?              								// Match any optional subdomain
  (                           							// Capture the domain part
    (?:(?:[-\w]+\.)+          							// Match one or more subdomains
      (?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+) 		// Match top-level domain or Punycode encoded IDN(xn--80aswg.xn--p1ai)
      |localhost              							// Match localhost
      |\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} 	// Match IPv4 addresses
    )
  )
  (?::\d+)?                   							// Match optional port number
  (?:\/[^\s?]*)?              							// Match optional path
  (?:\?[^\s#]*)?              							// Match optional query string
  (?:#[^\s]*)?$/i;            							// Match optional hash fragment
*/
const DOMAIN_EXTRACT_REGEXP =
	/^(?:(?:https?|ftp):\/\/)?(?:mailto:)?(?:\/\/)?((?:www\.)?(?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?]*)?(?:\?[^\s#]*)?(?:#[^\s]*)?$/i;

/*
	Matches domain names without the protocol or optional subdomains

	/^(?:www\.)? 															// Match optional www prefix
  (                         								// Capture the domain part
    (?:(?:[-\w]+\.)+        								// Match one or more subdomains
      (?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+) 		// Match top-level domain or Punycode encoded IDN
      |localhost            								// Match localhost
      |\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} 	// Match IPv4 addresses
    )
  )
  (?::\d+)?                 								// Match optional port number
  (?:\/[^\s?]*)?            								// Match optional path
  (?:\?[^\s#]*)?            								// Match optional query string
  (?:#[^\s]*)?$/i;          								// Match optional fragment at the end of the string
*/
const DOMAIN_REGEXP =
	/^(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?]*)?(?:\?[^\s#]*)?(?:#[^\s]*)?$/i;

/*
	Matches email addresses

	/(
    ( 																											// Capture local part of the email address
      ([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*) 	// One or more characters not in the set, followed by
																														a	period, followed by one or more characters not in the set
      |(".+") 																							// Or one or more characters inside quotes
    )
  )
  @                             														// Match @ symbol
  (?<domain>(                   														// Capture the domain part of the email address
    \[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\] 			// Match IPv4 address inside brackets
    |(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}) 											// Or match domain with at least two subdomains and TLD
  ))/;
*/
const EMAIL_REGEXP =
	/(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@(?<domain>(\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;

/*
	Matches URLs with strict beginning and end of the string checks

	/^(?:(?:https?|ftp):\/\/) 							// Match http, https, or ftp protocols at the start of the string
  (?:www\.)?               								// Match optional www prefix
  (                        								// Capture the domain part
    (?:(?:[-\w]+\.)+       								// Match one or more subdomains
      (?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+) 	// Match top-level domain or Punycode encoded IDN
      |localhost           								// Match localhost
      |\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} // Match IPv4 addresses
    )
  )
  (?::\d+)?                								// Match optional port number
  (?:\/[^\s?#]*)?          								// Match optional path
  (?:\?[^\s#]*)?           								// Match optional query string
  (?=([^\s]+#.*)?)         								// Positive lookahead for the fragment identifier
  #?[^\s]*$/i;              							// Match optional fragment at the end of the string
*/
const URL_REGEXP_EXACT =
	/^(?:(?:https?|ftp):\/\/)(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?#]*)?(?:\?[^\s#]*)?(?=([^\s]+#.*)?)#?[^\s]*$/i;

/*
	Same as URL_REGEXP_EXACT but without the strict beginning and end of the string checks to allow for
	matching URLs in the middle of a string
*/
const URL_REGEXP =
	/(?:(?:https?|ftp):\/\/)(?:www\.)?((?:(?:[-\w]+\.)+(?:[a-zA-Z]{2,}|xn--[a-zA-Z0-9]+)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))(?::\d+)?(?:\/[^\s?#]*)?(?:\?[^\s#]*)?(?=([^\s]+#.*)?)#?[^\s]*/i;

const CHAR_TEST_REGEXP = /\p{L}/u;
const PUNC_TEST_REGEXP = /[!?.]/;

function hash(value: string, extraArgs: string[]): string {
	const algorithm = extraArgs[0]?.toLowerCase() ?? 'md5';
	switch (algorithm) {
		case 'base64':
			return toBase64(value);
		case 'md5':
			return MD5(value);
		case 'sha1':
		case 'sha224':
		case 'sha256':
		case 'sha384':
		case 'sha512':
		case 'sha3':
			const variant = (
				{
					sha1: 'SHA-1',
					sha224: 'SHA-224',
					sha256: 'SHA-256',
					sha384: 'SHA-384',
					sha512: 'SHA-512',
					sha3: 'SHA3-512',
				} as const
			)[algorithm];
			return new SHA(variant, 'TEXT').update(value).getHash('HEX');
		default:
			throw new ExpressionExtensionError(
				`Unknown algorithm ${algorithm}. Available algorithms are: ${SupportedHashAlgorithms.join()}, and Base64.`,
			);
	}
}

function isEmpty(value: string): boolean {
	return value === '';
}

function isNotEmpty(value: string): boolean {
	return !isEmpty(value);
}

function length(value: string): number {
	return value.length;
}

export function toJsonString(value: string): string {
	return JSON.stringify(value);
}

function removeMarkdown(value: string): string {
	let output = value;
	try {
		output = output.replace(/^([\s\t]*)([*\-+]|\d\.)\s+/gm, '$1');

		output = output
			// Header
			.replace(/\n={2,}/g, '\n')
			// Strikethrough
			.replace(/~~/g, '')
			// Fenced codeblocks
			.replace(/`{3}.*\n/g, '');

		output = output
			// Remove HTML tags
			.replace(/<[\w|\s|=|'|"|:|(|)|,|;|/|0-9|.|-]+[>|\\>]/g, '')
			// Remove setext-style headers
			.replace(/^[=-]{2,}\s*$/g, '')
			// Remove footnotes?
			.replace(/\[\^.+?\](: .*?$)?/g, '')
			.replace(/\s{0,2}\[.*?\]: .*?$/g, '')
			// Remove images
			.replace(/!\[.*?\][[(].*?[\])]/g, '')
			// Remove inline links
			.replace(/\[(.*?)\][[(].*?[\])]/g, '$1')
			// Remove Blockquotes
			.replace(/>/g, '')
			// Remove reference-style links?
			.replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, '')
			// Remove atx-style headers
			.replace(/^#{1,6}\s*([^#]*)\s*(#{1,6})?/gm, '$1')
			.replace(/([*_]{1,3})(\S.*?\S)\1/g, '$2')
			.replace(/(`{3,})(.*?)\1/gm, '$2')
			.replace(/^-{3,}\s*$/g, '')
			.replace(/`(.+?)`/g, '$1')
			.replace(/\n{2,}/g, '\n\n');
	} catch (e) {
		return value;
	}
	return output;
}

function removeTags(value: string): string {
	return value.replace(/<[^>]*>?/gm, '');
}

function toDate(value: string): Date {
	const date = new Date(Date.parse(value));

	if (date.toString() === 'Invalid Date') {
		throw new ExpressionExtensionError('cannot convert to date');
	}
	// If time component is not specified, force 00:00h
	if (!/:/.test(value)) {
		date.setHours(0, 0, 0);
	}
	return date;
}

export function toDateTime(value: string, extraArgs: [string] = ['']): DateTime {
	try {
		const [valueFormat] = extraArgs;

		if (valueFormat) {
			if (
				valueFormat === 'ms' ||
				valueFormat === 's' ||
				valueFormat === 'us' ||
				valueFormat === 'excel'
			) {
				return numberToDateTime(Number(value), [valueFormat]);
			}
			return DateTime.fromFormat(value, valueFormat);
		}

		return tryToParseDateTime(value);
	} catch (error) {
		throw new ExpressionExtensionError('cannot convert to Luxon DateTime');
	}
}

function urlDecode(value: string, extraArgs: boolean[]): string {
	const [entireString = false] = extraArgs;
	if (entireString) {
		return decodeURI(value.toString());
	}
	return decodeURIComponent(value.toString());
}

function urlEncode(value: string, extraArgs: boolean[]): string {
	const [entireString = false] = extraArgs;
	if (entireString) {
		return encodeURI(value.toString());
	}
	return encodeURIComponent(value.toString());
}

function toInt(value: string, extraArgs: Array<number | undefined>) {
	const [radix] = extraArgs;
	const int = parseInt(value.replace(CURRENCY_REGEXP, ''), radix);

	if (isNaN(int)) {
		throw new ExpressionExtensionError('cannot convert to integer');
	}

	return int;
}

function toFloat(value: string) {
	if (value.includes(',')) {
		throw new ExpressionExtensionError('cannot convert to float, expected . as decimal separator');
	}

	const float = parseFloat(value.replace(CURRENCY_REGEXP, ''));

	if (isNaN(float)) {
		throw new ExpressionExtensionError('cannot convert to float');
	}

	return float;
}

function toNumber(value: string) {
	const num = Number(value.replace(CURRENCY_REGEXP, ''));

	if (isNaN(num)) {
		throw new ExpressionExtensionError('cannot convert to number');
	}

	return num;
}

function quote(value: string, extraArgs: string[]) {
	const [quoteChar = '"'] = extraArgs;
	return `${quoteChar}${value
		.replace(/\\/g, '\\\\')
		.replace(new RegExp(`\\${quoteChar}`, 'g'), `\\${quoteChar}`)}${quoteChar}`;
}

function isNumeric(value: string) {
	if (value.includes(' ')) return false;

	return !isNaN(value as unknown as number) && !isNaN(parseFloat(value));
}

function isUrl(value: string) {
	return URL_REGEXP_EXACT.test(value);
}

function isDomain(value: string) {
	return DOMAIN_REGEXP.test(value);
}

function isEmail(value: string) {
	const result = EMAIL_REGEXP.test(value);

	// email regex is loose so check manually for now
	if (result && value.includes(' ')) {
		return false;
	}

	return result;
}

function toTitleCase(value: string) {
	return titleCase(value);
}

function replaceSpecialChars(value: string) {
	return transliterate(value, { unknown: '?' });
}

function toSentenceCase(value: string) {
	let current = value.slice();
	let buffer = '';

	while (CHAR_TEST_REGEXP.test(current)) {
		const charIndex = current.search(CHAR_TEST_REGEXP);
		current =
			current.slice(0, charIndex) +
			current[charIndex].toLocaleUpperCase() +
			current.slice(charIndex + 1).toLocaleLowerCase();
		const puncIndex = current.search(PUNC_TEST_REGEXP);
		if (puncIndex === -1) {
			buffer += current;
			current = '';
			break;
		}
		buffer += current.slice(0, puncIndex + 1);
		current = current.slice(puncIndex + 1);
	}

	return buffer;
}

function toSnakeCase(value: string) {
	return value
		.toLocaleLowerCase()
		.replace(/[ \-]/g, '_')
		.replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,.\/:;<=>?@\[\]^`{|}~]/g, '');
}

function extractEmail(value: string) {
	const matched = EMAIL_REGEXP.exec(value);
	if (!matched) {
		return undefined;
	}
	return matched[0];
}

function extractDomain(value: string) {
	if (isEmail(value)) {
		const matched = EMAIL_REGEXP.exec(value);
		// This shouldn't happen
		if (!matched) {
			return undefined;
		}
		return matched.groups?.domain;
	}

	const domainMatch = value.match(DOMAIN_EXTRACT_REGEXP);
	if (domainMatch) {
		return domainMatch[1];
	}

	return undefined;
}

function extractUrl(value: string) {
	const matched = URL_REGEXP.exec(value);
	if (!matched) {
		return undefined;
	}
	return matched[0];
}

function extractUrlPath(value: string) {
	try {
		const url = new URL(value);
		return url.pathname;
	} catch (error) {
		return undefined;
	}
}

function parseJson(value: string): unknown {
	try {
		return JSON.parse(value);
	} catch (error) {
		if (value.includes("'")) {
			throw new ExpressionExtensionError("Parsing failed. Check you're using double quotes");
		}
		throw new ExpressionExtensionError('Parsing failed');
	}
}

function toBoolean(value: string): boolean {
	const normalized = value.toLowerCase();
	const FALSY = new Set(['false', 'no', '0']);
	return normalized.length > 0 && !FALSY.has(normalized);
}

function base64Encode(value: string): string {
	return toBase64(value);
}

function base64Decode(value: string): string {
	return fromBase64(value);
}

removeMarkdown.doc = {
	name: 'removeMarkdown',
	description: 'Removes any Markdown formatting from the string. Also removes HTML tags.',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-removeMarkdown',
	examples: [{ example: '"*bold*, [link]()".removeMarkdown()', evaluated: '"bold, link"' }],
};

removeTags.doc = {
	name: 'removeTags',
	description: 'Removes tags, such as HTML or XML, from the string.',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-removeTags',
	examples: [{ example: '"<b>bold</b>, <a>link</a>".removeTags()', evaluated: '"bold, link"' }],
};

toDate.doc = {
	name: 'toDate',
	description: 'Converts a string to a date.',
	section: 'cast',
	returnType: 'Date',
	hidden: true,
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDate',
};

toDateTime.doc = {
	name: 'toDateTime',
	description:
		'Converts the string to a <a target="_blank" href="https://moment.github.io/luxon/api-docs/">Luxon</a> DateTime. Useful for further transformation. Supported formats for the string are ISO 8601, HTTP, RFC2822, SQL and Unix timestamp in milliseconds. To parse other formats, use <a target="_blank" href=”https://moment.github.io/luxon/api-docs/index.html#datetimefromformat”> <code>DateTime.fromFormat()</code></a>.',
	section: 'cast',
	returnType: 'DateTime',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDateTime',
	examples: [
		{ example: '"2024-03-29T18:06:31.798+01:00".toDateTime()' },
		{ example: '"Fri, 29 Mar 2024 18:08:01 +0100".toDateTime()' },
		{ example: '"20240329".toDateTime()' },
		{ example: '"1711732132990".toDateTime("ms")' },
		{ example: '"31-01-2024".toDateTime("dd-MM-yyyy")' },
	],
	args: [
		{
			name: 'format',
			optional: true,
			description:
				'The format of the date string. Options are <code>ms</code> (for Unix timestamp in milliseconds), <code>s</code> (for Unix timestamp in seconds), <code>us</code> (for Unix timestamp in microseconds) or <code>excel</code> (for days since 1900). Custom formats can be specified using <a href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens">Luxon tokens</a>.',
			type: 'string',
		},
	],
};

toBoolean.doc = {
	name: 'toBoolean',
	description:
		'Converts the string to a boolean value. <code>0</code>, <code>false</code> and <code>no</code> resolve to <code>false</code>, everything else to <code>true</code>. Case-insensitive.',
	section: 'cast',
	returnType: 'boolean',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toBoolean',
	examples: [
		{ example: '"true".toBoolean()', evaluated: 'true' },
		{ example: '"false".toBoolean()', evaluated: 'false' },
		{ example: '"0".toBoolean()', evaluated: 'false' },
		{ example: '"hello".toBoolean()', evaluated: 'true' },
	],
};

toFloat.doc = {
	name: 'toFloat',
	description: 'Converts a string to a decimal number.',
	section: 'cast',
	returnType: 'number',
	aliases: ['toDecimalNumber'],
	hidden: true,
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toDecimalNumber',
};

toInt.doc = {
	name: 'toInt',
	description: 'Converts a string to an integer.',
	section: 'cast',
	returnType: 'number',
	args: [{ name: 'radix?', type: 'number' }],
	aliases: ['toWholeNumber'],
	hidden: true,
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toInt',
};

toSentenceCase.doc = {
	name: 'toSentenceCase',
	description:
		'Changes the capitalization of the string to sentence case. The first letter of each sentence is capitalized and all others are lowercased.',
	examples: [{ example: '"quick! brown FOX".toSentenceCase()', evaluated: '"Quick! Brown fox"' }],
	section: 'case',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toSentenceCase',
};

toSnakeCase.doc = {
	name: 'toSnakeCase',
	description:
		'Changes the format of the string to snake case. Spaces and dashes are replaced by <code>_</code>, symbols are removed and all letters are lowercased.',
	examples: [{ example: '"quick brown $FOX".toSnakeCase()', evaluated: '"quick_brown_fox"' }],
	section: 'case',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toSnakeCase',
};

toTitleCase.doc = {
	name: 'toTitleCase',
	description:
		"Changes the capitalization of the string to title case. The first letter of each word is capitalized and the others left unchanged. Short prepositions and conjunctions aren't capitalized (e.g. 'a', 'the').",
	examples: [{ example: '"quick a brown FOX".toTitleCase()', evaluated: '"Quick a Brown Fox"' }],
	section: 'case',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toTitleCase',
};

urlEncode.doc = {
	name: 'urlEncode',
	description:
		'Encodes the string so that it can be used in a URL. Spaces and special characters are replaced with codes of the form <code>%XX</code>.',
	section: 'edit',
	args: [
		{
			name: 'allChars',
			optional: true,
			description:
				'Whether to encode characters that are part of the URI syntax (e.g. <code>=</code>, <code>?</code>)',
			default: 'false',
			type: 'boolean',
		},
	],
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-urlEncode',
	examples: [
		{ example: '"name=Nathan Automat".urlEncode()', evaluated: '"name%3DNathan%20Automat"' },
		{ example: '"name=Nathan Automat".urlEncode(true)', evaluated: '"name=Nathan%20Automat"' },
	],
};

urlDecode.doc = {
	name: 'urlDecode',
	description:
		'Decodes a URL-encoded string. Replaces any character codes in the form of <code>%XX</code> with their corresponding characters.',
	args: [
		{
			name: 'allChars',
			optional: true,
			description:
				'Whether to decode characters that are part of the URI syntax (e.g. <code>=</code>, <code>?</code>)',
			default: 'false',
			type: 'boolean',
		},
	],
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-urlDecode',
	examples: [
		{ example: '"name%3DNathan%20Automat".urlDecode()', evaluated: '"name=Nathan Automat"' },
		{ example: '"name%3DNathan%20Automat".urlDecode(true)', evaluated: '"name%3DNathan Automat"' },
	],
};

replaceSpecialChars.doc = {
	name: 'replaceSpecialChars',
	description: 'Replaces special characters in the string with the closest ASCII character',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-replaceSpecialChars',
	examples: [{ example: '"déjà".replaceSpecialChars()', evaluated: '"deja"' }],
};

length.doc = {
	name: 'length',
	section: 'query',
	hidden: true,
	description: 'Returns the character count of a string.',
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings',
};

isDomain.doc = {
	name: 'isDomain',
	description: 'Returns <code>true</code> if a string is a domain.',
	section: 'validation',
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isDomain',
	examples: [
		{ example: '"n8n.io".isDomain()', evaluated: 'true' },
		{ example: '"http://n8n.io".isDomain()', evaluated: 'false' },
		{ example: '"hello".isDomain()', evaluated: 'false' },
	],
};

isEmail.doc = {
	name: 'isEmail',
	description: 'Returns <code>true</code> if the string is an email.',
	section: 'validation',
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isEmail',
	examples: [
		{ example: '"me@example.com".isEmail()', evaluated: 'true' },
		{ example: '"It\'s me@example.com".isEmail()', evaluated: 'false' },
		{ example: '"hello".isEmail()', evaluated: 'false' },
	],
};

isNumeric.doc = {
	name: 'isNumeric',
	description: 'Returns <code>true</code> if the string represents a number.',
	section: 'validation',
	returnType: 'boolean',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isNumeric',
	examples: [
		{ example: '"1.2234".isNumeric()', evaluated: 'true' },
		{ example: '"hello".isNumeric()', evaluated: 'false' },
		{ example: '"123E23".isNumeric()', evaluated: 'true' },
	],
};

isUrl.doc = {
	name: 'isUrl',
	description: 'Returns <code>true</code> if a string is a valid URL',
	section: 'validation',
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isUrl',
	examples: [
		{ example: '"https://n8n.io".isUrl()', evaluated: 'true' },
		{ example: '"n8n.io".isUrl()', evaluated: 'false' },
		{ example: '"hello".isUrl()', evaluated: 'false' },
	],
};

isEmpty.doc = {
	name: 'isEmpty',
	description: 'Returns <code>true</code> if the string has no characters or is <code>null</code>',
	section: 'validation',
	returnType: 'boolean',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isEmpty',
	examples: [
		{ example: '"".isEmpty()', evaluated: 'true' },
		{ example: '"hello".isEmpty()', evaluated: 'false' },
	],
};

isNotEmpty.doc = {
	name: 'isNotEmpty',
	description: 'Returns <code>true</code> if the string has at least one character.',
	section: 'validation',
	returnType: 'boolean',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-isNotEmpty',
	examples: [
		{ example: '"hello".isNotEmpty()', evaluated: 'true' },
		{ example: '"".isNotEmpty()', evaluated: 'false' },
	],
};

toJsonString.doc = {
	name: 'toJsonString',
	description:
		'Prepares the string to be inserted into a JSON object. Escapes any quotes and special characters (e.g. new lines), and wraps the string in quotes.The same as JavaScript’s JSON.stringify().',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toJsonString',
	examples: [
		{
			example: 'The "best" colours: red\nbrown.toJsonString()',
			evaluated: '"The \\"best\\" colours: red\\nbrown"',
		},
		{ example: 'foo.toJsonString()', evaluated: '"foo"' },
	],
};

extractEmail.doc = {
	name: 'extractEmail',
	description:
		'Extracts the first email found in the string. Returns <code>undefined</code> if none is found.',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractEmail',
	examples: [
		{ example: '"My email is me@example.com".extractEmail()', evaluated: "'me@example.com'" },
	],
};

extractDomain.doc = {
	name: 'extractDomain',
	description:
		'If the string is an email address or URL, returns its domain (or <code>undefined</code> if nothing found). If the string also contains other content, try using <code>extractEmail()</code> or <code>extractUrl()</code> first.',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractDomain',
	examples: [
		{ example: '"me@example.com".extractDomain()', evaluated: "'example.com'" },
		{ example: '"http://n8n.io/workflows".extractDomain()', evaluated: "'n8n.io'" },
		{
			example: '"It\'s me@example.com".extractEmail().extractDomain()',
			evaluated: "'example.com'",
		},
	],
};

extractUrl.doc = {
	name: 'extractUrl',
	description:
		'Extracts the first URL found in the string. Returns <code>undefined</code> if none is found. Only recognizes full URLs, e.g. those starting with <code>http</code>.',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractUrl',
	examples: [{ example: '"Check out http://n8n.io".extractUrl()', evaluated: "'http://n8n.io'" }],
};

extractUrlPath.doc = {
	name: 'extractUrlPath',
	description:
		'Returns the part of a URL after the domain, or <code>undefined</code> if no URL found. If the string also contains other content, try using <code>extractUrl()</code> first.',
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-extractUrlPath',
	examples: [
		{ example: '"http://n8n.io/workflows".extractUrlPath()', evaluated: "'/workflows'" },
		{
			example: '"Check out http://n8n.io/workflows".extractUrl().extractUrlPath()',
			evaluated: "'/workflows'",
		},
	],
};

hash.doc = {
	name: 'hash',
	description:
		'Returns the string hashed with the given algorithm. Defaults to md5 if not specified.',
	section: 'edit',
	returnType: 'string',
	args: [
		{
			name: 'algo',
			optional: true,
			description:
				'The hashing algorithm to use. One of <code>md5</code>, <code>base64</code>, <code>sha1</code>, <code>sha224</code>, <code>sha256</code>, <code>sha384</code>, <code>sha512</code>, <code>sha3</code>, <code>ripemd160</code>\n        ',
			default: '"md5"',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-hash',
	examples: [{ example: '"hello".hash()', evaluated: "'5d41402abc4b2a76b9719d911017c592'" }],
};

quote.doc = {
	name: 'quote',
	description:
		'Wraps a string in quotation marks, and escapes any quotation marks already in the string. Useful when constructing JSON, SQL, etc.',
	section: 'edit',
	returnType: 'string',
	args: [
		{
			name: 'mark',
			optional: true,
			description: 'The type of quotation mark to use',
			default: '"',
			type: 'string',
		},
	],
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-quote',
	examples: [{ example: '\'Nathan says "hi"\'.quote()', evaluated: '\'"Nathan says \\"hi\\""\'' }],
};

parseJson.doc = {
	name: 'parseJson',
	description:
		"Returns the JavaScript value or object represented by the string, or <code>undefined</code> if the string isn't valid JSON. Single-quoted JSON is not supported.",
	section: 'cast',
	returnType: 'any',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-parseJson',
	examples: [
		{ example: '\'{"name":"Nathan"}\'.parseJson()', evaluated: '\'{"name":"Nathan"}\'' },
		{ example: "\"{'name':'Nathan'}\".parseJson()", evaluated: 'undefined' },
		{ example: "'hello'.parseJson()", evaluated: 'undefined' },
	],
};

base64Encode.doc = {
	name: 'base64Encode',
	description: 'Converts plain text to a base64-encoded string',
	examples: [{ example: '"hello".base64Encode()', evaluated: '"aGVsbG8="' }],
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-base64Encode',
};

base64Decode.doc = {
	name: 'base64Decode',
	description: 'Converts a base64-encoded string to plain text',
	examples: [{ example: '"aGVsbG8=".base64Decode()', evaluated: '"hello"' }],
	section: 'edit',
	returnType: 'string',
	docURL:
		'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-base64Decode',
};

toNumber.doc = {
	name: 'toNumber',
	description:
		"Converts a string representing a number to a number. Errors if the string doesn't start with a valid number.",
	section: 'cast',
	returnType: 'number',
	docURL: 'https://docs.n8n.io/code/builtin/data-transformation-functions/strings/#string-toNumber',
	examples: [
		{ example: '"123".toNumber()', evaluated: '123' },
		{ example: '"1.23E10".toNumber()', evaluated: '12300000000' },
	],
};

const toDecimalNumber: Extension = toFloat.bind({});
const toWholeNumber: Extension = toInt.bind({});

export const stringExtensions: ExtensionMap = {
	typeName: 'String',
	functions: {
		hash,
		removeMarkdown,
		removeTags,
		toDate,
		toDateTime,
		toBoolean,
		toDecimalNumber,
		toNumber,
		toFloat,
		toInt,
		toWholeNumber,
		toSentenceCase,
		toSnakeCase,
		toTitleCase,
		urlDecode,
		urlEncode,
		quote,
		replaceSpecialChars,
		length,
		isDomain,
		isEmail,
		isNumeric,
		isUrl,
		isEmpty,
		isNotEmpty,
		toJsonString,
		extractEmail,
		extractDomain,
		extractUrl,
		extractUrlPath,
		parseJson,
		base64Encode,
		base64Decode,
	},
};



================================================
FILE: packages/workflow/src/extensions/utils.ts
================================================
import { DateTime } from 'luxon';

import { ExpressionExtensionError } from '../errors/expression-extension.error';

// Utility functions and type guards for expression extensions

export const convertToDateTime = (value: string | Date | DateTime): DateTime | undefined => {
	let converted: DateTime | undefined;

	if (typeof value === 'string') {
		converted = DateTime.fromJSDate(new Date(value));
		if (converted.invalidReason !== null) {
			return;
		}
	} else if (value instanceof Date) {
		converted = DateTime.fromJSDate(value);
	} else if (DateTime.isDateTime(value)) {
		converted = value;
	}
	return converted;
};

export function checkIfValueDefinedOrThrow<T>(value: T, functionName: string): void {
	if (value === undefined || value === null) {
		throw new ExpressionExtensionError(`${functionName} can't be used on ${String(value)} value`, {
			description: `To ignore this error, add a ? to the variable before this function, e.g. my_var?.${functionName}`,
		});
	}
}



================================================
FILE: packages/workflow/src/graph/graph-utils.ts
================================================
import type { IConnection, IConnections } from '../interfaces';

type MultipleInputNodesError = {
	errorCode: 'Multiple Input Nodes';
	nodes: Set<string>;
};

type MultipleOutputNodesError = {
	errorCode: 'Multiple Output Nodes';
	nodes: Set<string>;
};

type InputEdgeToNonRootNode = {
	errorCode: 'Input Edge To Non-Root Node';
	node: string;
};

type OutputEdgeFromNonLeafNode = {
	errorCode: 'Output Edge From Non-Leaf Node';
	node: string;
};

type NoContinuousPathFromRootToLeaf = {
	errorCode: 'No Continuous Path From Root To Leaf In Selection';
	start: string;
	end: string;
};

export type ExtractableErrorResult =
	| MultipleInputNodesError
	| MultipleOutputNodesError
	| InputEdgeToNonRootNode
	| OutputEdgeFromNonLeafNode
	| NoContinuousPathFromRootToLeaf;

export type IConnectionAdjacencyList = Map<string, Set<IConnection>>;

/**
 * Find all edges leading into the graph described in `graphIds`.
 */
export function getInputEdges(
	graphIds: Set<string>,
	adjacencyList: IConnectionAdjacencyList,
): Array<[string, IConnection]> {
	const result: Array<[string, IConnection]> = [];
	for (const [from, tos] of adjacencyList.entries()) {
		if (graphIds.has(from)) continue;

		for (const to of tos) {
			if (graphIds.has(to.node)) {
				result.push([from, to]);
			}
		}
	}

	return result;
}

/**
 * Find all edges leading out of the graph described in `graphIds`.
 */
export function getOutputEdges(
	graphIds: Set<string>,
	adjacencyList: IConnectionAdjacencyList,
): Array<[string, IConnection]> {
	const result: Array<[string, IConnection]> = [];
	for (const [from, tos] of adjacencyList.entries()) {
		if (!graphIds.has(from)) continue;

		for (const to of tos) {
			if (!graphIds.has(to.node)) {
				result.push([from, to]);
			}
		}
	}

	return result;
}

function intersection<T>(a: Set<T>, b: Set<T>): Set<T> {
	const result = new Set<T>();
	for (const x of a) {
		if (b.has(x)) result.add(x);
	}
	return result;
}

function union<T>(a: Set<T>, b: Set<T>): Set<T> {
	const result = new Set<T>();
	for (const x of a) result.add(x);
	for (const x of b) result.add(x);
	return result;
}

function difference<T>(minuend: Set<T>, subtrahend: Set<T>): Set<T> {
	const result = new Set<T>(minuend.values());
	for (const x of subtrahend) {
		result.delete(x);
	}
	return result;
}

export function getRootNodes(
	graphIds: Set<string>,
	adjacencyList: IConnectionAdjacencyList,
): Set<string> {
	// Inner nodes are all nodes with an incoming edge from another node in the graph
	let innerNodes = new Set<string>();
	for (const nodeId of graphIds) {
		innerNodes = union(
			innerNodes,
			new Set(
				[...(adjacencyList.get(nodeId) ?? [])]
					.filter((x) => x.type === 'main' && x.node !== nodeId)
					.map((x) => x.node),
			),
		);
	}

	return difference(graphIds, innerNodes);
}

export function getLeafNodes(
	graphIds: Set<string>,
	adjacencyList: IConnectionAdjacencyList,
): Set<string> {
	const result = new Set<string>();
	for (const nodeId of graphIds) {
		if (
			intersection(
				new Set(
					[...(adjacencyList.get(nodeId) ?? [])]
						.filter((x) => x.type === 'main' && x.node !== nodeId)
						.map((x) => x.node),
				),
				graphIds,
			).size === 0
		) {
			result.add(nodeId);
		}
	}
	return result;
}

export function hasPath(start: string, end: string, adjacencyList: IConnectionAdjacencyList) {
	const seen = new Set<string>();
	const paths: string[] = [start];
	while (true) {
		const next = paths.pop();
		if (next === end) return true;
		if (next === undefined) return false;
		seen.add(next);

		paths.push(
			...difference(
				new Set(
					[...(adjacencyList.get(next) ?? [])].filter((x) => x.type === 'main').map((x) => x.node),
				),
				seen,
			),
		);
	}
}

export type ExtractableSubgraphData = {
	start?: string;
	end?: string;
};

export function buildAdjacencyList(
	connectionsBySourceNode: IConnections,
): IConnectionAdjacencyList {
	const result = new Map<string, Set<IConnection>>();
	const addOrCreate = (k: string, v: IConnection) =>
		result.set(k, union(result.get(k) ?? new Set(), new Set([v])));

	for (const sourceNode of Object.keys(connectionsBySourceNode)) {
		for (const type of Object.keys(connectionsBySourceNode[sourceNode])) {
			for (const sourceIndex of Object.keys(connectionsBySourceNode[sourceNode][type])) {
				for (const connectionIndex of Object.keys(
					connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)] ?? [],
				)) {
					const connection =
						connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)]?.[
							parseInt(connectionIndex, 10)
						];
					if (connection) addOrCreate(sourceNode, connection);
				}
			}
		}
	}
	return result;
}

/**
 * A subgraph is considered extractable if the following properties hold:
 * - 0-1 input nodes from outside the subgraph, to a root node
 * - 0-1 output nodes to outside the subgraph, from a leaf node
 * - continuous path between input and output nodes if they exist
 *
 * This also covers the requirement that all "inner" nodes between the root node
 * and the output node are selected, since this would otherwise create extra
 * input or output nodes.
 *
 * @returns An object containing optional start and end nodeIds
 *            indicating which nodes have outside connections, OR
 *          An array of errors if the selection is not valid.
 */
export function parseExtractableSubgraphSelection(
	graphIds: Set<string>,
	adjacencyList: IConnectionAdjacencyList,
): ExtractableSubgraphData | ExtractableErrorResult[] {
	const errors: ExtractableErrorResult[] = [];

	// 0-1 Input nodes
	const inputEdges = getInputEdges(graphIds, adjacencyList);
	// This filters out e.g. sub-nodes, which are technically parents
	const inputNodes = new Set(inputEdges.filter((x) => x[1].type === 'main').map((x) => x[1].node));
	let rootNodes = getRootNodes(graphIds, adjacencyList);

	// this enables supporting cases where we have one input and a loop back to it from within the selection
	if (rootNodes.size === 0 && inputNodes.size === 1) rootNodes = inputNodes;
	for (const inputNode of difference(inputNodes, rootNodes).values()) {
		errors.push({
			errorCode: 'Input Edge To Non-Root Node',
			node: inputNode,
		});
	}
	const rootInputNodes = intersection(rootNodes, inputNodes);
	if (rootInputNodes.size > 1) {
		errors.push({
			errorCode: 'Multiple Input Nodes',
			nodes: rootInputNodes,
		});
	}

	// 0-1 Output nodes
	const outputEdges = getOutputEdges(graphIds, adjacencyList);
	const outputNodes = new Set(outputEdges.filter((x) => x[1].type === 'main').map((x) => x[0]));
	let leafNodes = getLeafNodes(graphIds, adjacencyList);
	// If we have no leaf nodes, and only one output node, we can tolerate this output node
	// and connect to it.
	// Note that this is fairly theoretical, as return semantics in this case are not well-defined.
	if (leafNodes.size === 0 && outputNodes.size === 1) leafNodes = outputNodes;

	for (const outputNode of difference(outputNodes, leafNodes).values()) {
		errors.push({
			errorCode: 'Output Edge From Non-Leaf Node',
			node: outputNode,
		});
	}

	const leafOutputNodes = intersection(leafNodes, outputNodes);
	if (leafOutputNodes.size > 1) {
		errors.push({
			errorCode: 'Multiple Output Nodes',
			nodes: leafOutputNodes,
		});
	}

	const start = rootInputNodes.values().next().value;
	const end = leafOutputNodes.values().next().value;

	if (start && end && !hasPath(start, end, adjacencyList)) {
		errors.push({
			errorCode: 'No Continuous Path From Root To Leaf In Selection',
			start,
			end,
		});
	}

	return errors.length > 0 ? errors : { start, end };
}



================================================
FILE: packages/workflow/src/native-methods/array.methods.ts
================================================
import type { NativeDoc } from '../extensions/extensions';

export const arrayMethods: NativeDoc = {
	typeName: 'Array',
	properties: {
		length: {
			doc: {
				name: 'length',
				description: 'The number of elements in the array',
				examples: [{ example: "['Bob', 'Bill', 'Nat'].length", evaluated: '3' }],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length',
				returnType: 'number',
			},
		},
	},
	functions: {
		concat: {
			doc: {
				name: 'concat',
				description: 'Joins one or more arrays onto the end of the base array',
				examples: [
					{
						example: "['Nathan', 'Jan'].concat(['Steve', 'Bill'])",
						evaluated: "['Nathan', 'Jan', 'Steve', 'Bill']",
					},
					{
						example: "[5, 4].concat([100, 101], ['a', 'b'])",
						evaluated: "[5, 4, 100, 101, 'a', 'b']",
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat',
				returnType: 'Array',
				args: [
					{
						name: 'arrays',
						variadic: true,
						description: 'The arrays to be joined on the end of the base array, in order',
						type: 'Array',
					},
				],
			},
		},
		filter: {
			doc: {
				name: 'filter',
				description:
					'Returns an array with only the elements satisfying a condition. The condition is a function that returns <code>true</code> or <code>false</code>.',
				examples: [
					{
						example: '[12, 33, 16, 40].filter(age => age > 18)',
						evaluated: '[33, 40]',
						description: 'Keep ages over 18 (using arrow function notation)',
					},
					{
						example: "['Nathan', 'Bob', 'Sebastian'].filter(name => name.length < 5)",
						evaluated: "['Bob']",
						description: 'Keep names under 5 letters long (using arrow function notation)',
					},
					{
						example:
							"['Nathan', 'Bob', 'Sebastian'].filter(function(name) { return name.length < 5 })",
						evaluated: "['Bob']",
						description: 'Or using traditional function notation',
					},
					{
						example: '[1, 7, 3, 10, 5].filter((num, index) =>  index % 2 !== 0)',
						evaluated: '[7, 10]',
						description: 'Keep numbers at odd indexes',
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter',
				returnType: 'Array',
				args: [
					{
						name: 'function',
						description:
							'A function to run for each array element. If it returns <code>true</code>, the element will be kept. Consider using <a target="_blank" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.',
						type: 'Function',
						default: 'item => true',
						args: [
							{
								name: 'element',
								description: 'The value of the current element',
								type: 'any',
							},
							{
								name: 'index',
								optional: true,
								description: 'The position of the current element in the array (starting at 0)',
								type: 'number',
							},
							{
								name: 'array',
								optional: true,
								description: 'The array being processed. Rarely needed.',
								type: 'Array',
							},
							{
								name: 'thisValue',
								optional: true,
								description:
									'A value passed to the function as its <code>this</code> value. Rarely needed.',
								type: 'any',
							},
						],
					},
				],
			},
		},
		find: {
			doc: {
				name: 'find',
				description:
					'Returns the first element from the array that satisfies the provided condition. The condition is a function that returns <code>true</code> or <code>false</code>. Returns <code>undefined</code> if no matches are found.\n\nIf you need all matching elements, use <code>filter()</code>.',
				examples: [
					{
						example: '[12, 33, 16, 40].find(age => age > 18)',
						evaluated: '33',
						description: 'Find first age over 18 (using arrow function notation)',
					},
					{
						example: "['Nathan', 'Bob', 'Sebastian'].find(name => name.length < 5)",
						evaluated: "'Bob'",
						description: 'Find first name under 5 letters long (using arrow function notation)',
					},
					{
						example:
							"['Nathan', 'Bob', 'Sebastian'].find(function(name) { return name.length < 5 })",
						evaluated: "'Bob'",
						description: 'Or using traditional function notation',
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find',
				returnType: 'Array | undefined',
				args: [
					{
						name: 'function',
						description:
							'A function to run for each array element. As soon as it returns <code>true</code>, that element will be returned. Consider using <a target="_blank" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.',
						type: 'Function',
						default: 'item => true',
						args: [
							{
								name: 'element',
								description: 'The value of the current element',
								type: 'any',
							},
							{
								name: 'index',
								optional: true,
								description: 'The position of the current element in the array (starting at 0)',
								type: 'number',
							},
							{
								name: 'array',
								optional: true,
								description: 'The array being processed. Rarely needed.',
								type: 'Array',
							},
							{
								name: 'thisValue',
								optional: true,
								description:
									'A value passed to the function as its <code>this</code> value. Rarely needed.',
								type: 'any',
							},
						],
					},
				],
			},
		},
		findIndex: {
			doc: {
				name: 'findIndex',
				hidden: true,
				description:
					'Returns the index of the first element in an array that passes the test `fn`. If none are found, -1 is returned.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex',
				returnType: 'number',
				args: [{ name: 'fn', type: 'Function' }],
			},
		},
		findLast: {
			doc: {
				name: 'findLast',
				hidden: true,
				description: 'Returns the value of the last element that passes the test `fn`.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast',
				returnType: 'any | undefined',
				args: [{ name: 'fn', type: 'Function' }],
			},
		},
		findLastIndex: {
			doc: {
				name: 'findLastIndex',
				hidden: true,
				description:
					'Returns the index of the last element that satisfies the provided testing function. If none are found, -1 is returned.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex',
				returnType: 'number',
				args: [{ name: 'fn', type: 'Function' }],
			},
		},
		indexOf: {
			doc: {
				name: 'indexOf',
				description:
					"Returns the position of the first matching element in the array, or -1 if the element isn't found. Positions start at 0.",
				examples: [
					{ example: "['Bob', 'Bill', 'Nat'].indexOf('Nat')", evaluated: '2' },
					{ example: "['Bob', 'Bill', 'Nat'].indexOf('Nathan')", evaluated: '-1' },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf',
				returnType: 'number',
				args: [
					{
						name: 'element',
						description: 'The value to look for',
						type: 'any',
					},
					{
						name: 'start',
						optional: true,
						description: 'The index to start looking from',
						default: '0',
						type: 'number',
					},
				],
			},
		},
		includes: {
			doc: {
				name: 'includes',
				description: 'Returns <code>true</code> if the array contains the specified element',
				examples: [
					{ example: "['Bob', 'Bill', 'Nat'].includes('Nat')", evaluated: 'true' },
					{ example: "['Bob', 'Bill', 'Nat'].includes('Nathan')", evaluated: 'false' },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes',
				returnType: 'boolean',
				args: [
					{
						name: 'element',
						description: 'The value to search the array for',
						type: 'any',
					},
					{
						name: 'start',
						optional: true,
						description: 'The index to start looking from',
						default: '0',
						type: 'number',
					},
				],
			},
		},
		join: {
			doc: {
				name: 'join',
				description:
					'Merges all elements of the array into a single string, with an optional separator between each element.\n\nThe opposite of <code>String.split()</code>.',
				examples: [
					{ example: "['Wind', 'Water', 'Fire'].join(' + ')", evaluated: "'Wind + Water + Fire'" },
					{ example: "['Wind', 'Water', 'Fire'].join()", evaluated: "'Wind,Water,Fire'" },
					{ example: "['Wind', 'Water', 'Fire'].join('')", evaluated: "'WindWaterFire'" },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join',
				returnType: 'string',
				args: [
					{
						name: 'separator',
						optional: true,
						description: 'The character(s) to insert between each element',
						default: "','",
						type: 'string',
					},
				],
			},
		},
		map: {
			doc: {
				name: 'map',
				description:
					'Creates a new array by applying a function to each element of the original array',
				examples: [
					{
						example: '[12, 33, 16].map(num => num * 2)',
						evaluated: '[24, 66, 32]',
						description: 'Double all numbers (using arrow function notation)',
					},
					{
						example: "['hello', 'old', 'chap'].map(word => word.toUpperCase())",
						evaluated: "['HELLO', 'OLD', 'CHAP']]",
						description: 'Convert elements to uppercase (using arrow function notation)',
					},
					{
						example: "['hello', 'old', 'chap'].map(function(word) { return word.toUpperCase() })",
						evaluated: "['HELLO', 'OLD', 'CHAP']]",
						description: 'Or using traditional function notation',
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map',
				returnType: 'Array',
				args: [
					{
						name: 'function',
						description:
							'A function to run for each array element. In the new array, the output of this function takes the place of the element. Consider using <a target="_blank" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.',
						type: 'Function',
						default: 'item => item',
						args: [
							{
								name: 'element',
								description: 'The value of the current element',
								type: 'any',
							},
							{
								name: 'index',
								optional: true,
								description: 'The position of the current element in the array (starting at 0)',
								type: 'number',
							},
							{
								name: 'array',
								optional: true,
								description: 'The array being processed. Rarely needed.',
								type: 'Array',
							},
							{
								name: 'thisValue',
								optional: true,
								description:
									'A value passed to the function as its <code>this</code> value. Rarely needed.',
								type: 'any',
							},
						],
					},
				],
			},
		},
		reverse: {
			doc: {
				name: 'reverse',
				description: 'Reverses the order of the elements in the array',
				examples: [
					{ example: "['dog', 'bites', 'man'].reverse()", evaluated: "['man', 'bites', 'dog']" },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse',
				returnType: 'Array',
			},
		},
		reduce: {
			doc: {
				name: 'reduce',
				description:
					'Executes a "reducer" function `fn` on each element of the array. Passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce',
				returnType: 'any',
				args: [
					{
						name: 'function',
						description:
							'A function to run for each array element. Takes the accumulated result and the current element, and returns a new accumulated result. Consider using <a target="_blank" href=”https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions”>arrow function notation</a> to save space.',
						type: 'Function',
						default: 'item => item',
						args: [
							{
								name: 'prevResult',
								description:
									'The accumulated result from applying the function to previous elements. When processing the first element, it’s set to <code>initResult</code> (or the first array element if not specified).',
								type: 'any',
							},
							{
								name: 'currentElem',
								description: 'The value in the array currently being processed',
								type: 'any',
							},
							{
								name: 'index',
								optional: true,
								description: 'The position of the current element in the array (starting at 0)',
								type: 'number',
							},
							{
								name: 'array',
								optional: true,
								description: 'The array being processed. Rarely needed.',
								type: 'Array',
							},
						],
					},
					{
						name: 'initResult',
						optional: true,
						description:
							"The initial value of the prevResult, used when calling the function on the first array element. When not specified it's set to the first array element, and the first function call is on the second array element instead of the first.",
						type: 'any',
					},
				],
			},
		},
		slice: {
			doc: {
				name: 'slice',
				description:
					'Returns a portion of the array, from the <code>start</code> index up to (but not including) the <code>end</code> index. Indexes start at 0.',
				examples: [
					{ example: '[1, 2, 3, 4, 5].slice(2, 4)', evaluated: '[3, 4]' },
					{ example: '[1, 2, 3, 4, 5].slice(2)', evaluated: '[3, 4, 5]' },
					{ example: '[1, 2, 3, 4, 5].slice(-2)', evaluated: '[4, 5]' },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice',
				returnType: 'Array',
				args: [
					{
						name: 'start',
						optional: true,
						description:
							'The position to start from. Positions start at 0. Negative numbers count back from the end of the array.',
						default: '0',
						type: 'number',
					},
					{
						name: 'end',
						optional: true,
						description:
							'The position to select up to. The element at the end position is not included. Negative numbers select from the end of the array. If omitted, will extract to the end of the array.',
						type: 'number',
					},
				],
			},
		},
		sort: {
			doc: {
				name: 'sort',
				description:
					'Reorders the elements of the array. For sorting strings alphabetically, no parameter is required. For sorting numbers or Objects, see examples.',
				examples: [
					{
						example: "['d', 'a', 'c', 'b'].sort()",
						evaluated: "['a', 'b', 'c', 'd']",
						description: 'No need for a param when sorting strings',
					},
					{
						example: '[4, 2, 1, 3].sort((a, b) => (a - b))',
						evaluated: '[1, 2, 3, 4]',
						description: 'To sort numbers, you must use a function',
					},
					{
						example: '[4, 2, 1, 3].sort(function(a, b) { return a - b })',
						evaluated: '[1, 2, 3, 4]',
						description: 'Or using traditional function notation',
					},
					{ example: 'Sort in reverse alphabetical order' },
					{ example: "arr = ['d', 'a', 'c', 'b']" },
					{
						example: 'arr.sort((a, b) => b.localeCompare(a))',
						evaluated: "['d', 'c', 'b', 'a']",
						description: 'Sort in reverse alphabetical order',
					},
					{
						example:
							"[{name:'Zak'}, {name:'Abe'}, {name:'Bob'}].sort((a, b) => a.name.localeCompare(b.name))",
						evaluated: "[{name:'Abe'}, {name:'Bob'}, {name:'Zak'}]",
						description: 'Sort array of objects by a property',
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort',
				returnType: 'Array',
				args: [
					{
						name: 'compare',
						optional: true,
						description:
							'A function to compare two array elements and return a number indicating which one comes first:\n<b>Return < 0</b>: <code>a</code> comes before <code>b</code>\n<b>Return 0</b>: <code>a</code> and <code>b</code> are equal (leave order unchanged)\n<b>Return > 0</b>: <code>b</code> comes before <code>a</code>\n\nIf no function is specified, converts all values to strings and compares their character codes.',
						default: '""',
						type: '(a, b) => number',
						args: [
							{
								name: 'a',
								description: 'The first element to compare in the function',
								type: 'any',
							},
							{
								name: 'b',
								description: 'The second element to compare in the function',
								type: 'any',
							},
						],
					},
				],
			},
		},
		splice: {
			doc: {
				name: 'splice',
				description: 'Changes the contents of an array by removing or replacing existing elements.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice',
				returnType: 'Array',
				hidden: true,
				args: [
					{ name: 'start', type: 'number' },
					{ name: 'deleteCount?', type: 'number' },
					{ name: 'item1?', type: 'Element' },
					{ name: '...' },
					{ name: 'itemN?', type: 'Element' },
				],
			},
		},
		toString: {
			doc: {
				name: 'toString',
				hidden: true,
				description: 'Returns a string representing the specified array and its elements.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString',
				returnType: 'string',
			},
		},
		toSpliced: {
			doc: {
				name: 'toSpliced',
				description:
					'Adds and/or removes array elements at a given position. \n\nSee also <code>slice()</code> and <code>append()</code>.',
				examples: [
					{
						example: "['Jan', 'Mar'.toSpliced(1, 0, 'Feb')",
						evaluated: "['Jan', 'Feb', 'Mar']",
						description: 'Insert element at index 1',
					},
					{
						example: '["don\'t", "make", "me", "do", "this"].toSpliced(1, 2)',
						evaluated: '["don\'t", "do", "this"]',
						description: 'Delete 2 elements starting at index 1',
					},
					{
						example: '["don\'t", "be", "evil"].toSpliced(1, 2, "eat", "slugs")',
						evaluated: '["don\'t", "eat", "slugs"]',
						description: 'Replace 2 elements starting at index 1',
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced',
				returnType: 'Array',
				args: [
					{
						name: 'start',
						description:
							'The index (position) to add or remove elements at.  New elements are inserted before the element at this index. A negative index counts back from the end of the array. ',
						type: 'number',
					},
					{
						name: 'deleteCount',
						optional: true,
						description:
							'The number of elements to remove. If omitted, removes all elements from the <code>start</code> index onwards.',
						type: 'number',
					},
					{
						name: 'elements',
						optional: true,
						variadic: true,
						description: 'The elements to be added, in order',
						type: 'any',
					},
				],
			},
		},
	},
};



================================================
FILE: packages/workflow/src/native-methods/boolean.methods.ts
================================================
import type { NativeDoc } from '../extensions/extensions';

export const booleanMethods: NativeDoc = {
	typeName: 'Boolean',
	functions: {
		toString: {
			doc: {
				name: 'toString',
				description:
					"Converts <code>true</code> to the string <code>'true'</code> and <code>false</code> to the string <code>'false'</code>.",
				examples: [
					{ example: 'true.toString()', evaluated: "'true'" },
					{ example: 'false.toString()', evaluated: "'false'" },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean/toString',
				returnType: 'string',
			},
		},
	},
};



================================================
FILE: packages/workflow/src/native-methods/index.ts
================================================
import { arrayMethods } from './array.methods';
import { booleanMethods } from './boolean.methods';
import { numberMethods } from './number.methods';
import { objectMethods } from './object.methods';
import { stringMethods } from './string.methods';
import type { NativeDoc } from '../extensions/extensions';

const NATIVE_METHODS: NativeDoc[] = [
	stringMethods,
	arrayMethods,
	numberMethods,
	objectMethods,
	booleanMethods,
];

export { NATIVE_METHODS as NativeMethods };



================================================
FILE: packages/workflow/src/native-methods/number.methods.ts
================================================
import type { NativeDoc } from '../extensions/extensions';

export const numberMethods: NativeDoc = {
	typeName: 'Number',
	functions: {
		toFixed: {
			doc: {
				name: 'toFixed',
				hidden: true,
				description:
					'Formats a number using fixed-point notation. `digits` defaults to null if not given.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed',
				returnType: 'string',
				args: [{ name: 'digits?', type: 'number' }],
			},
		},
		toPrecision: {
			doc: {
				name: 'toPrecision',
				hidden: true,
				description: 'Returns a string representing the number to the specified precision.',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision',
				returnType: 'string',
				args: [{ name: 'precision?', type: 'number' }],
			},
		},
		toString: {
			doc: {
				name: 'toString',
				description:
					'Converts the number to a string. For more formatting options, see <code>toLocaleString()</code>.',
				examples: [
					{ example: '(2).toString()', evaluated: "'2'" },
					{ example: '(50.125).toString()', evaluated: "'50.125'" },
					{ example: '(5).toString(2)', evaluated: "'101'" },
					{ example: '(412).toString(16)', evaluated: "'19c'" },
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString',
				args: [
					{
						name: 'base',
						optional: true,
						description:
							'The base to use. Must be an integer between 2 and 36. E.g. base <code>2</code> is binary and base <code>16</code> is hexadecimal.',
						default: '10',
						type: 'number',
					},
				],
				returnType: 'string',
			},
		},
		toLocaleString: {
			doc: {
				name: 'toLocaleString',
				description:
					"Returns a localized string representing the number, i.e. in the language and format corresponding to its locale. Defaults to the system's locale if none specified.",
				examples: [
					{
						example: '(500000.125).toLocaleString()',
						evaluated: "'500,000.125' (if in US English locale)",
					},
					{ example: "(500000.125).toLocaleString('fr-FR')", evaluated: "'500 000,125'" },
					{
						example: "(500000.125).toLocaleString('fr-FR', {style:'currency', currency:'EUR'})",
						evaluated: "'500 000,13 €'",
					},
				],
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString',
				args: [
					{
						name: 'locale(s)',
						optional: true,
						description:
							'The locale to use, e.g. \'en-GB\' for British English or \'pt-BR\' for Brazilian Portuguese. See <a target="_blank" href="https://www.localeplanet.com/icu/">full list</a> (unofficial). Also accepts an <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument">array of locales</a>. Defaults to the system locale if not specified.',
						type: 'string | string[]',
					},
					{
						name: 'options',
						optional: true,
						description:
							'An object with <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#parameters">formatting options</a>',
						type: 'object',
					},
				],
				returnType: 'string',
			},
		},
	},
};



================================================
FILE: packages/workflow/src/native-methods/object.methods.ts
================================================
import type { NativeDoc } from '../extensions/extensions';

export const objectMethods: NativeDoc = {
	typeName: 'Object',
	functions: {},
};



================================================
FILE: packages/workflow/src/native-methods/string.methods.ts
================================================
import type { NativeDoc } from '../extensions/extensions';

export const stringMethods: NativeDoc = {
	typeName: 'String',
	properties: {
		length: {
			doc: {
				name: 'length',
				description: 'The number of characters in the string',
				examples: [{ example: '"hello".length', evaluated: '5' }],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length',
				returnType: 'number',
			},
		},
	},
	functions: {
		concat: {
			doc: {
				name: 'concat',
				description:
					'Joins one or more strings onto the end of the base string. Alternatively, use the <code>+</code> operator (see examples).',
				examples: [
					{ example: "'sea'.concat('food')", evaluated: "'seafood'" },
					{ example: "'sea' + 'food'", evaluated: "'seafood'" },
					{ example: "'work'.concat('a', 'holic')", evaluated: "'workaholic'" },
				],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat',
				args: [
					{
						name: 'strings',
						optional: false,
						variadic: true,
						description: 'The strings to append, in order',
						type: 'string[]',
					},
				],
				returnType: 'string',
			},
		},
		endsWith: {
			doc: {
				name: 'endsWith',
				description:
					'Returns <code>true</code> if the string ends with <code>searchString</code>. Case-sensitive.',
				examples: [
					{ example: "'team'.endsWith('eam')", evaluated: 'true' },
					{ example: "'team'.endsWith('Eam')", evaluated: 'false' },
					{
						example: "'teaM'.toLowerCase().endsWith('eam')",
						evaluated: 'true',
						description:
							"Returns false if the case doesn't match, so consider using .toLowerCase() first",
					},
				],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith',
				returnType: 'boolean',
				args: [
					{
						name: 'searchString',
						optional: false,
						description: 'The text to check against the end of the base string',
						type: 'string',
					},
					{
						name: 'end',
						optional: true,
						description: 'The end position (index) to start searching from',
						type: 'number',
					},
				],
			},
		},
		indexOf: {
			doc: {
				name: 'indexOf',
				description:
					'Returns the index (position) of the first occurrence of <code>searchString</code> within the base string, or -1 if not found. Case-sensitive.',
				examples: [
					{ example: "'steam'.indexOf('tea')", evaluated: '1' },
					{ example: "'steam'.indexOf('i')", evaluated: '-1' },
					{
						example: "'STEAM'.indexOf('tea')",
						evaluated: '-1',
						description:
							"Returns -1 if the case doesn't match, so consider using .toLowerCase() first",
					},
					{ example: "'STEAM'.toLowerCase().indexOf('tea')", evaluated: '1' },
				],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf',
				returnType: 'number',
				args: [
					{
						name: 'searchString',
						optional: false,
						description: 'The text to search for',
						type: 'string',
					},
					{
						name: 'start',
						optional: true,
						description: 'The position (index) to start searching from',
						default: '0',
						type: 'number',
					},
				],
			},
		},
		lastIndexOf: {
			doc: {
				name: 'lastIndexOf',
				description:
					'Returns the index (position) of the last occurrence of <code>searchString</code> within the base string, or -1 if not found. Case-sensitive.',
				examples: [
					{ example: "'canal'.lastIndexOf('a')", evaluated: '3' },
					{ example: "'canal'.lastIndexOf('i')", evaluated: '-1' },
					{
						example: "'CANAL'.lastIndexOf('a')",
						evaluated: '-1',
						description:
							"Returns -1 if the case doesn't match, so consider using .toLowerCase() first",
					},
					{ example: "'CANAL'.toLowerCase().lastIndexOf('a')", evaluated: '3' },
				],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf',
				returnType: 'number',
				args: [
					{
						name: 'searchString',
						optional: false,
						description: 'The text to search for',
						type: 'string',
					},
					{
						name: 'end',
						optional: true,
						description: 'The position (index) to stop searching at',
						default: '0',
						type: 'number',
					},
				],
			},
		},
		match: {
			doc: {
				name: 'match',
				description:
					'Matches the string against a <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular expression</a>. Returns an array containing the first match, or all matches if the <code>g</code> flag is set in the regular expression. Returns <code>null</code> if no matches are found. \n\nFor checking whether text is present, consider <code>includes()</code> instead.',
				examples: [
					{
						example: '"rock and roll".match(/r[^ ]*/g)',
						evaluated: "['rock', 'roll']",
						description: "Match all words starting with 'r'",
					},
					{
						example: '"rock and roll".match(/r[^ ]*/)',
						evaluated: "['rock']",
						description: "Match first word starting with 'r' (no 'g' flag)",
					},
					{
						example: '"ROCK and roll".match(/r[^ ]*/ig)',
						evaluated: "['ROCK', 'roll']",
						description: "For case-insensitive, add 'i' flag",
					},
				],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match',
				returnType: 'string[]',
				args: [
					{
						name: 'regexp',
						optional: false,
						description:
							'A <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular expression</a> with the pattern to look for. Will look for multiple matches if the <code>g</code> flag is present (see examples).',
						type: 'RegExp',
					},
				],
			},
		},
		includes: {
			doc: {
				name: 'includes',
				description:
					'Returns <code>true</code> if the string contains the <code>searchString</code>. Case-sensitive.',
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes',
				returnType: 'boolean',
				args: [
					{
						name: 'searchString',
						optional: false,
						description: 'The text to search for',
						type: 'string',
					},
					{
						name: 'start',
						optional: true,
						description: 'The position (index) to start searching from',
						default: '0',
						type: 'number',
					},
				],
				examples: [
					{ example: "'team'.includes('tea')", evaluated: 'true' },
					{ example: "'team'.includes('i')", evaluated: 'false' },
					{
						example: "'team'.includes('Tea')",
						evaluated: 'false',
						description:
							"Returns false if the case doesn't match, so consider using .toLowerCase() first",
					},
					{ example: "'Team'.toLowerCase().includes('tea')", evaluated: 'true' },
				],
			},
		},
		replace: {
			doc: {
				name: 'replace',
				description:
					'Returns a string with the first occurrence of <code>pattern</code> replaced by <code>replacement</code>. \n\nTo replace all occurrences, use <code>replaceAll()</code> instead.',
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace',
				returnType: 'string',
				args: [
					{
						name: 'pattern',
						optional: false,
						description:
							'The pattern in the string to replace. Can be a string to match or a <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular expression</a>.',
						type: 'string|RegExp',
					},
					{
						name: 'replacement',
						optional: false,
						description: 'The new text to replace with',
						type: 'string',
					},
				],
				examples: [
					{
						example: "'Red or blue or green'.replace('or', 'and')",
						evaluated: "'Red and blue or green'",
					},
					{
						example:
							'let text = "Mr Blue has a blue house and a blue car";\ntext.replace(/blue/gi, "red");',
						evaluated: "'Mr red has a red house and a red car'",
						description: 'A global, case-insensitive replacement:',
					},
					{
						example:
							'let text = "Mr Blue has a blue house and a blue car";\ntext.replace(/blue|house|car/gi, (t) => t.toUpperCase());',
						evaluated: "'Mr BLUE has a BLUE HOUSE and a BLUE CAR'",
						description: 'A function to return the replacement text:',
					},
				],
			},
		},
		replaceAll: {
			doc: {
				name: 'replaceAll',
				description:
					'Returns a string with all occurrences of <code>pattern</code> replaced by <code>replacement</code>',
				examples: [
					{
						example: "'Red or blue or green'.replaceAll('or', 'and')",
						evaluated: "'Red and blue and green'",
					},
					{
						example:
							"text = 'Mr Blue has a blue car';\ntext.replaceAll(/blue|car/gi, t => t.toUpperCase())",
						description:
							"Uppercase any occurrences of 'blue' or 'car' (You must include the 'g' flag when using a regex)",
						evaluated: "'Mr BLUE has a BLUE CAR'",
					},
					{
						example: 'text.replaceAll(/blue|car/gi, function(x){return x.toUpperCase()})',
						evaluated: "'Mr BLUE has a BLUE CAR'",
						description: 'Or with traditional function notation:',
					},
				],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll',
				returnType: 'string',
				args: [
					{
						name: 'pattern',
						optional: false,
						description:
							'The pattern in the string to replace. Can be a string to match or a <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular expression</a>.',
						type: 'string|RegExp',
					},
					{
						name: 'replacement',
						optional: false,
						description:
							'The new text to replace with. Can be a string or a function that returns a string (see examples).',
						type: 'string|Function',
					},
				],
			},
		},
		search: {
			doc: {
				name: 'search',
				description:
					'Returns the index (position) of the first occurrence of a pattern within the string, or -1 if not found. The pattern is specified using a <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular expression</a>. To use text instead, see <code>indexOf()</code>.',
				examples: [
					{
						example: '"Neat n8n node".search(/n[^ ]*/)',
						evaluated: '5',
						description: "Pos of first word starting with 'n'",
					},
					{
						example: '"Neat n8n node".search(/n[^ ]*/i)',
						evaluated: '0',
						description:
							"Case-insensitive match with 'i'\nPos of first word starting with 'n' or 'N'",
					},
				],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search',
				returnType: 'string',
				args: [
					{
						name: 'regexp',
						optional: false,
						description:
							'A <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular expression</a> with the pattern to look for',
						type: 'RegExp',
					},
				],
			},
		},
		slice: {
			doc: {
				name: 'slice',
				description:
					'Extracts a fragment of the string at the given position. For more advanced extraction, see <code>match()</code>.',
				examples: [
					{ example: "'Hello from n8n'.slice(0, 5)", evaluated: "'Hello'" },
					{ example: "'Hello from n8n'.slice(6)", evaluated: "'from n8n'" },
					{ example: "'Hello from n8n'.slice(-3)", evaluated: "'n8n'" },
				],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice',
				returnType: 'string',
				args: [
					{
						name: 'start',
						optional: false,
						description:
							'The position to start from. Positions start at 0. Negative numbers count back from the end of the string.',
						type: 'number',
					},
					{
						name: 'end',
						optional: true,
						description:
							'The position to select up to. The character at the end position is not included. Negative numbers select from the end of the string. If omitted, will extract to the end of the string.',
						type: 'string',
					},
				],
			},
		},
		split: {
			doc: {
				name: 'split',
				description:
					"Splits the string into an array of substrings. Each split is made at the <code>separator</code>, and the separator isn't included in the output. \n\nThe opposite of using <code>join()</code> on an array.",
				examples: [
					{ example: '"wind,fire,water".split(",")', evaluated: "['wind', 'fire', 'water']" },
					{ example: '"me and you and her".split("and")', evaluated: "['me ', ' you ', ' her']" },
					{
						example: '"me? you, and her".split(/[ ,?]+/)',
						evaluated: "['me', 'you', 'and', 'her']",
						description: "Split one or more of space, comma and '?' using a regular expression",
					},
				],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split',
				returnType: 'string[]',
				args: [
					{
						name: 'separator',
						optional: true,
						description:
							'The string (or regular expression) to use for splitting. If omitted, an array with the original string is returned.',
						type: 'string',
					},
					{
						name: 'limit',
						optional: true,
						description:
							'The max number of array elements to return. Returns all elements if omitted.',
						type: 'number',
					},
				],
			},
		},
		startsWith: {
			doc: {
				name: 'startsWith',
				description:
					'Returns <code>true</code> if the string starts with <code>searchString</code>. Case-sensitive.',
				examples: [
					{ example: "'team'.startsWith('tea')", evaluated: 'true' },
					{ example: "'team'.startsWith('Tea')", evaluated: 'false' },
					{
						example: "'Team'.toLowerCase().startsWith('tea')",
						evaluated: 'true',
						description:
							"Returns false if the case doesn't match, so consider using .toLowerCase() first",
					},
				],
				section: 'query',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith',
				returnType: 'boolean',
				args: [
					{
						name: 'searchString',
						optional: false,
						description: 'The text to check against the start of the base string',
						type: 'string',
					},
					{
						name: 'start',
						optional: true,
						description: 'The position (index) to start searching from',
						default: '0',
						type: 'number',
					},
				],
			},
		},
		substring: {
			doc: {
				name: 'substring',
				description:
					'Extracts a fragment of the string at the given position. For more advanced extraction, see <code>match()</code>.',
				examples: [
					{ example: "'Hello from n8n'.substring(0, 5)", evaluated: "'Hello'" },
					{ example: "'Hello from n8n'.substring(6)", evaluated: "'from n8n'" },
				],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring',
				returnType: 'string',
				args: [
					{
						name: 'start',
						optional: false,
						description: 'The position to start from. Positions start at 0.',
						type: 'number',
					},
					{
						name: 'end',
						optional: true,
						description:
							'The position to select up to. The character at the end position is not included. If omitted, will extract to the end of the string.',
						type: 'string',
					},
				],
			},
		},
		toLowerCase: {
			doc: {
				name: 'toLowerCase',
				description: 'Converts all letters in the string to lower case',
				section: 'case',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase',
				returnType: 'string',
				examples: [{ example: '"I\'m SHOUTing".toLowerCase()', evaluated: '"i\'m shouting"' }],
			},
		},
		toUpperCase: {
			doc: {
				name: 'toUpperCase',
				description: 'Converts all letters in the string to upper case (capitals)',
				examples: [{ example: '"I\'m not angry".toUpperCase()', evaluated: '"I\'M NOT ANGRY"' }],
				section: 'case',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase',
				returnType: 'string',
			},
		},
		trim: {
			doc: {
				name: 'trim',
				description:
					'Removes whitespace from both ends of the string. Whitespace includes new lines, tabs, spaces, etc.',
				examples: [{ example: "'   lonely   '.trim()", evaluated: "'lonely'" }],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim',
				returnType: 'string',
			},
		},
		trimEnd: {
			doc: {
				name: 'trimEnd',
				description:
					'Removes whitespace from the end of a string and returns a new string. Whitespace includes new lines, tabs, spaces, etc.',
				examples: [{ example: "'   lonely   '.trimEnd()", evaluated: "'   lonely'" }],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd',
				returnType: 'string',
			},
		},
		trimStart: {
			doc: {
				name: 'trimStart',
				description:
					'Removes whitespace from the beginning of a string and returns a new string. Whitespace includes new lines, tabs, spaces, etc.',
				examples: [{ example: "'   lonely   '.trimStart()", evaluated: "'lonely   '" }],
				section: 'edit',
				docURL:
					'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart',
				returnType: 'string',
			},
		},
	},
};



================================================
FILE: packages/workflow/src/node-parameters/filter-parameter.ts
================================================
import type { DateTime } from 'luxon';

import { ApplicationError } from '@n8n/errors';
import type {
	FilterConditionValue,
	FilterOperatorType,
	FilterOptionsValue,
	FilterValue,
	INodeProperties,
	ValidationResult,
} from '../interfaces';
import * as LoggerProxy from '../logger-proxy';
import type { Result } from '../result';
import { validateFieldType } from '../type-validation';

type FilterConditionMetadata = {
	index: number;
	unresolvedExpressions: boolean;
	itemIndex: number;
	errorFormat: 'full' | 'inline';
};

export class FilterError extends ApplicationError {
	constructor(
		message: string,
		readonly description: string,
	) {
		super(message, { level: 'warning' });
	}
}

function parseSingleFilterValue(
	value: unknown,
	type: FilterOperatorType,
	strict = false,
	version: FilterOptionsValue['version'] = 1,
): ValidationResult {
	if (type === 'any' || value === null || value === undefined) {
		return { valid: true, newValue: value } as ValidationResult;
	}

	if (type === 'boolean' && !strict) {
		if (version >= 2) {
			const result = validateFieldType('filter', value, type);
			if (result.valid) return result;
		}

		return { valid: true, newValue: Boolean(value) };
	}

	if (type === 'number' && Number.isNaN(value)) {
		return { valid: true, newValue: value };
	}

	return validateFieldType('filter', value, type, { strict, parseStrings: true });
}

const withIndefiniteArticle = (noun: string): string => {
	const article = 'aeiou'.includes(noun.charAt(0)) ? 'an' : 'a';
	return `${article} ${noun}`;
};

function parseFilterConditionValues(
	condition: FilterConditionValue,
	options: FilterOptionsValue,
	metadata: Partial<FilterConditionMetadata>,
): Result<{ left: unknown; right: unknown }, FilterError> {
	const index = metadata.index ?? 0;
	const itemIndex = metadata.itemIndex ?? 0;
	const errorFormat = metadata.errorFormat ?? 'full';
	const strict = options.typeValidation === 'strict';
	const version = options.version ?? 1;
	const { operator } = condition;
	const rightType = operator.rightType ?? operator.type;
	const parsedLeftValue = parseSingleFilterValue(
		condition.leftValue,
		operator.type,
		strict,
		version,
	);
	const parsedRightValue = parseSingleFilterValue(condition.rightValue, rightType, strict, version);
	const leftValid =
		parsedLeftValue.valid ||
		(metadata.unresolvedExpressions &&
			typeof condition.leftValue === 'string' &&
			condition.leftValue.startsWith('='));
	const rightValid =
		parsedRightValue.valid ||
		!!operator.singleValue ||
		(metadata.unresolvedExpressions &&
			typeof condition.rightValue === 'string' &&
			condition.rightValue.startsWith('='));
	const leftValueString = String(condition.leftValue);
	const rightValueString = String(condition.rightValue);
	const suffix =
		errorFormat === 'full' ? `[condition ${index}, item ${itemIndex}]` : `[item ${itemIndex}]`;

	const composeInvalidTypeMessage = (type: string, fromType: string, value: string) => {
		fromType = fromType.toLocaleLowerCase();
		if (strict) {
			return `Wrong type: '${value}' is ${withIndefiniteArticle(
				fromType,
			)} but was expecting ${withIndefiniteArticle(type)} ${suffix}`;
		}
		return `Conversion error: the ${fromType} '${value}' can't be converted to ${withIndefiniteArticle(
			type,
		)} ${suffix}`;
	};

	const getTypeDescription = (isStrict: boolean) => {
		if (isStrict)
			return "Try changing the type of comparison. Alternatively you can enable 'Convert types where required'.";
		return 'Try changing the type of the comparison.';
	};

	const composeInvalidTypeDescription = (
		type: string,
		fromType: string,
		valuePosition: 'first' | 'second',
	) => {
		fromType = fromType.toLocaleLowerCase();
		const expectedType = withIndefiniteArticle(type);

		let convertionFunction = '';
		if (type === 'string') {
			convertionFunction = '.toString()';
		} else if (type === 'number') {
			convertionFunction = '.toNumber()';
		} else if (type === 'boolean') {
			convertionFunction = '.toBoolean()';
		}

		if (strict && convertionFunction) {
			const suggestFunction = ` by adding <code>${convertionFunction}</code>`;
			return `
<p>Try either:</p>
<ol>
  <li>Enabling 'Convert types where required'</li>
  <li>Converting the ${valuePosition} field to ${expectedType}${suggestFunction}</li>
</ol>
			`;
		}

		return getTypeDescription(strict);
	};

	if (!leftValid && !rightValid && typeof condition.leftValue === typeof condition.rightValue) {
		return {
			ok: false,
			error: new FilterError(
				`Comparison type expects ${withIndefiniteArticle(operator.type)} but both fields are ${withIndefiniteArticle(
					typeof condition.leftValue,
				)}`,
				getTypeDescription(strict),
			),
		};
	}

	if (!leftValid) {
		return {
			ok: false,
			error: new FilterError(
				composeInvalidTypeMessage(operator.type, typeof condition.leftValue, leftValueString),
				composeInvalidTypeDescription(operator.type, typeof condition.leftValue, 'first'),
			),
		};
	}

	if (!rightValid) {
		return {
			ok: false,
			error: new FilterError(
				composeInvalidTypeMessage(rightType, typeof condition.rightValue, rightValueString),
				composeInvalidTypeDescription(rightType, typeof condition.rightValue, 'second'),
			),
		};
	}

	return {
		ok: true,
		result: {
			left: parsedLeftValue.valid ? parsedLeftValue.newValue : undefined,
			right: parsedRightValue.valid ? parsedRightValue.newValue : undefined,
		},
	};
}

function parseRegexPattern(pattern: string): RegExp {
	const regexMatch = (pattern || '').match(new RegExp('^/(.*?)/([gimusy]*)$'));
	let regex: RegExp;

	if (!regexMatch) {
		regex = new RegExp((pattern || '').toString());
	} else {
		regex = new RegExp(regexMatch[1], regexMatch[2]);
	}

	return regex;
}

export function arrayContainsValue(array: unknown[], value: unknown, ignoreCase: boolean): boolean {
	if (ignoreCase && typeof value === 'string') {
		return array.some((item) => {
			if (typeof item !== 'string') {
				return false;
			}
			return item.toString().toLocaleLowerCase() === value.toLocaleLowerCase();
		});
	}
	return array.includes(value);
}

// eslint-disable-next-line complexity
export function executeFilterCondition(
	condition: FilterConditionValue,
	filterOptions: FilterOptionsValue,
	metadata: Partial<FilterConditionMetadata> = {},
): boolean {
	const ignoreCase = !filterOptions.caseSensitive;
	const { operator } = condition;
	const parsedValues = parseFilterConditionValues(condition, filterOptions, metadata);

	if (!parsedValues.ok) {
		throw parsedValues.error;
	}

	let { left: leftValue, right: rightValue } = parsedValues.result;

	const exists = leftValue !== undefined && leftValue !== null && !Number.isNaN(leftValue);
	if (condition.operator.operation === 'exists') {
		return exists;
	} else if (condition.operator.operation === 'notExists') {
		return !exists;
	}

	switch (operator.type) {
		case 'string': {
			if (ignoreCase) {
				if (typeof leftValue === 'string') {
					leftValue = leftValue.toLocaleLowerCase();
				}

				if (
					typeof rightValue === 'string' &&
					!(condition.operator.operation === 'regex' || condition.operator.operation === 'notRegex')
				) {
					rightValue = rightValue.toLocaleLowerCase();
				}
			}

			const left = (leftValue ?? '') as string;
			const right = (rightValue ?? '') as string;

			switch (condition.operator.operation) {
				case 'empty':
					return left.length === 0;
				case 'notEmpty':
					return left.length !== 0;
				case 'equals':
					return left === right;
				case 'notEquals':
					return left !== right;
				case 'contains':
					return left.includes(right);
				case 'notContains':
					return !left.includes(right);
				case 'startsWith':
					return left.startsWith(right);
				case 'notStartsWith':
					return !left.startsWith(right);
				case 'endsWith':
					return left.endsWith(right);
				case 'notEndsWith':
					return !left.endsWith(right);
				case 'regex':
					return parseRegexPattern(right).test(left);
				case 'notRegex':
					return !parseRegexPattern(right).test(left);
			}

			break;
		}
		case 'number': {
			const left = leftValue as number;
			const right = rightValue as number;

			switch (condition.operator.operation) {
				case 'empty':
					return !exists;
				case 'notEmpty':
					return exists;
				case 'equals':
					return left === right;
				case 'notEquals':
					return left !== right;
				case 'gt':
					return left > right;
				case 'lt':
					return left < right;
				case 'gte':
					return left >= right;
				case 'lte':
					return left <= right;
			}
		}
		case 'dateTime': {
			const left = leftValue as DateTime;
			const right = rightValue as DateTime;

			if (condition.operator.operation === 'empty') {
				return !exists;
			} else if (condition.operator.operation === 'notEmpty') {
				return exists;
			}

			if (!left || !right) {
				return false;
			}

			switch (condition.operator.operation) {
				case 'equals':
					return left.toMillis() === right.toMillis();
				case 'notEquals':
					return left.toMillis() !== right.toMillis();
				case 'after':
					return left.toMillis() > right.toMillis();
				case 'before':
					return left.toMillis() < right.toMillis();
				case 'afterOrEquals':
					return left.toMillis() >= right.toMillis();
				case 'beforeOrEquals':
					return left.toMillis() <= right.toMillis();
			}
		}
		case 'boolean': {
			const left = leftValue as boolean;
			const right = rightValue as boolean;

			switch (condition.operator.operation) {
				case 'empty':
					return !exists;
				case 'notEmpty':
					return exists;
				case 'true':
					return left;
				case 'false':
					return !left;
				case 'equals':
					return left === right;
				case 'notEquals':
					return left !== right;
			}
		}
		case 'array': {
			const left = (leftValue ?? []) as unknown[];
			const rightNumber = rightValue as number;

			switch (condition.operator.operation) {
				case 'contains':
					return arrayContainsValue(left, rightValue, ignoreCase);
				case 'notContains':
					return !arrayContainsValue(left, rightValue, ignoreCase);
				case 'lengthEquals':
					return left.length === rightNumber;
				case 'lengthNotEquals':
					return left.length !== rightNumber;
				case 'lengthGt':
					return left.length > rightNumber;
				case 'lengthLt':
					return left.length < rightNumber;
				case 'lengthGte':
					return left.length >= rightNumber;
				case 'lengthLte':
					return left.length <= rightNumber;
				case 'empty':
					return left.length === 0;
				case 'notEmpty':
					return left.length !== 0;
			}
		}
		case 'object': {
			const left = leftValue;

			switch (condition.operator.operation) {
				case 'empty':
					return !left || Object.keys(left).length === 0;
				case 'notEmpty':
					return !!left && Object.keys(left).length !== 0;
			}
		}
	}

	LoggerProxy.warn(`Unknown filter parameter operator "${operator.type}:${operator.operation}"`);

	return false;
}

type ExecuteFilterOptions = {
	itemIndex?: number;
};
export function executeFilter(
	value: FilterValue,
	{ itemIndex }: ExecuteFilterOptions = {},
): boolean {
	const conditionPass = (condition: FilterConditionValue, index: number) =>
		executeFilterCondition(condition, value.options, { index, itemIndex });

	if (value.combinator === 'and') {
		return value.conditions.every(conditionPass);
	} else if (value.combinator === 'or') {
		return value.conditions.some(conditionPass);
	}

	LoggerProxy.warn(`Unknown filter combinator "${value.combinator as string}"`);

	return false;
}

export const validateFilterParameter = (
	nodeProperties: INodeProperties,
	value: FilterValue,
): Record<string, string[]> => {
	return value.conditions.reduce(
		(issues, condition, index) => {
			const key = `${nodeProperties.name}.${index}`;

			try {
				parseFilterConditionValues(condition, value.options, {
					index,
					unresolvedExpressions: true,
					errorFormat: 'inline',
				});
			} catch (error) {
				if (error instanceof FilterError) {
					issues[key].push(error.message);
				}
			}

			return issues;
		},
		{} as Record<string, string[]>,
	);
};



================================================
FILE: packages/workflow/src/node-parameters/parameter-type-validation.ts
================================================
import { NodeOperationError } from '../errors';
import type { INode } from '../interfaces';
import { assert } from '../utils';

type ParameterType =
	| 'string'
	| 'boolean'
	| 'number'
	| 'resource-locator'
	| 'string[]'
	| 'number[]'
	| 'boolean[]'
	| 'object';

function assertUserInput<T>(condition: T, message: string, node: INode): asserts condition {
	try {
		assert(condition, message);
	} catch (e: unknown) {
		if (e instanceof Error) {
			// Use level 'info' to prevent reporting to Sentry (only 'error' and 'fatal' levels are reported)
			const nodeError = new NodeOperationError(node, e.message, { level: 'info' });
			nodeError.stack = e.stack;
			throw nodeError;
		}

		throw e;
	}
}

function assertParamIsType<T>(
	parameterName: string,
	value: unknown,
	type: 'string' | 'number' | 'boolean',
	node: INode,
): asserts value is T {
	assertUserInput(typeof value === type, `Parameter "${parameterName}" is not ${type}`, node);
}

export function assertParamIsNumber(
	parameterName: string,
	value: unknown,
	node: INode,
): asserts value is number {
	assertParamIsType<number>(parameterName, value, 'number', node);
}

export function assertParamIsString(
	parameterName: string,
	value: unknown,
	node: INode,
): asserts value is string {
	assertParamIsType<string>(parameterName, value, 'string', node);
}

export function assertParamIsBoolean(
	parameterName: string,
	value: unknown,
	node: INode,
): asserts value is boolean {
	assertParamIsType<boolean>(parameterName, value, 'boolean', node);
}

type TypeofMap = {
	string: string;
	number: number;
	boolean: boolean;
};

export function assertParamIsOfAnyTypes<T extends ReadonlyArray<keyof TypeofMap>>(
	parameterName: string,
	value: unknown,
	types: T,
	node: INode,
): asserts value is TypeofMap[T[number]] {
	const isValid = types.some((type) => typeof value === type);
	if (!isValid) {
		const typeList = types.join(' or ');
		assertUserInput(false, `Parameter "${parameterName}" must be ${typeList}`, node);
	}
}

export function assertParamIsArray<T>(
	parameterName: string,
	value: unknown,
	validator: (val: unknown) => val is T,
	node: INode,
): asserts value is T[] {
	assertUserInput(Array.isArray(value), `Parameter "${parameterName}" is not an array`, node);

	// Use for loop instead of .every() to properly handle sparse arrays
	// .every() skips empty/sparse indices, which could allow invalid arrays to pass
	for (let i = 0; i < value.length; i++) {
		if (!validator(value[i])) {
			assertUserInput(
				false,
				`Parameter "${parameterName}" has elements that don't match expected types`,
				node,
			);
		}
	}
}

function assertIsValidObject(
	value: unknown,
	node: INode,
): asserts value is Record<string, unknown> {
	assertUserInput(typeof value === 'object' && value !== null, 'Value is not a valid object', node);
}

function assertIsRequiredParameter(
	parameterName: string,
	value: unknown,
	isRequired: boolean,
	node: INode,
): void {
	if (isRequired && value === undefined) {
		assertUserInput(false, `Required parameter "${parameterName}" is missing`, node);
	}
}

function assertIsResourceLocator(parameterName: string, value: unknown, node: INode): void {
	assertUserInput(
		typeof value === 'object' &&
			value !== null &&
			'__rl' in value &&
			'mode' in value &&
			'value' in value,
		`Parameter "${parameterName}" is not a valid resource locator object`,
		node,
	);
}

function assertParamIsObject(parameterName: string, value: unknown, node: INode): void {
	assertUserInput(
		typeof value === 'object' && value !== null,
		`Parameter "${parameterName}" is not a valid object`,
		node,
	);
}

function createElementValidator<T extends 'string' | 'number' | 'boolean'>(elementType: T) {
	return (
		val: unknown,
	): val is T extends 'string' ? string : T extends 'number' ? number : boolean =>
		typeof val === elementType;
}

function assertParamIsArrayOfType(
	parameterName: string,
	value: unknown,
	arrayType: string,
	node: INode,
): void {
	const baseType = arrayType.slice(0, -2);
	const elementType =
		baseType === 'string' || baseType === 'number' || baseType === 'boolean' ? baseType : 'string';

	const validator = createElementValidator(elementType);
	assertParamIsArray(parameterName, value, validator, node);
}

function assertParamIsPrimitive(
	parameterName: string,
	value: unknown,
	type: string,
	node: INode,
): void {
	assertUserInput(
		typeof value === type,
		`Parameter "${parameterName}" is not a valid ${type}`,
		node,
	);
}

function validateParameterType(
	parameterName: string,
	value: unknown,
	type: ParameterType,
	node: INode,
): boolean {
	try {
		if (type === 'resource-locator') {
			assertIsResourceLocator(parameterName, value, node);
		} else if (type === 'object') {
			assertParamIsObject(parameterName, value, node);
		} else if (type.endsWith('[]')) {
			assertParamIsArrayOfType(parameterName, value, type, node);
		} else {
			assertParamIsPrimitive(parameterName, value, type, node);
		}
		return true;
	} catch {
		return false;
	}
}

function validateParameterAgainstTypes(
	parameterName: string,
	value: unknown,
	types: ParameterType[],
	node: INode,
): void {
	let isValid = false;

	for (const type of types) {
		if (validateParameterType(parameterName, value, type, node)) {
			isValid = true;
			break;
		}
	}

	if (!isValid) {
		const typeList = types.join(' or ');
		assertUserInput(
			false,
			`Parameter "${parameterName}" does not match any of the expected types: ${typeList}`,
			node,
		);
	}
}

type InferParameterType<T extends ParameterType | ParameterType[]> = T extends ParameterType[]
	? InferSingleParameterType<T[number]>
	: T extends ParameterType
		? InferSingleParameterType<T>
		: never;

type InferSingleParameterType<T extends ParameterType> = T extends 'string'
	? string
	: T extends 'boolean'
		? boolean
		: T extends 'number'
			? number
			: T extends 'resource-locator'
				? Record<string, unknown>
				: T extends 'string[]'
					? string[]
					: T extends 'number[]'
						? number[]
						: T extends 'boolean[]'
							? boolean[]
							: T extends 'object'
								? Record<string, unknown>
								: unknown;

export function validateNodeParameters<
	T extends Record<string, { type: ParameterType | ParameterType[]; required?: boolean }>,
>(
	value: unknown,
	parameters: T,
	node: INode,
): asserts value is {
	[K in keyof T]: T[K]['required'] extends true
		? InferParameterType<T[K]['type']>
		: InferParameterType<T[K]['type']> | undefined;
} {
	assertIsValidObject(value, node);

	Object.keys(parameters).forEach((key) => {
		const param = parameters[key];
		const paramValue = value[key];

		assertIsRequiredParameter(key, paramValue, param.required ?? false, node);

		// If required, value cannot be undefined and must be validated
		// If not required, value can be undefined but should be validated when present
		if (param.required || paramValue !== undefined) {
			const types = Array.isArray(param.type) ? param.type : [param.type];
			validateParameterAgainstTypes(key, paramValue, types, node);
		}
	});
}



================================================
FILE: packages/workflow/src/node-parameters/path-utils.ts
================================================
/**
 * Resolve relative paths starting in & in the context of a given full path including parameters,
 * which will be dropped in the process.
 * If `candidateRelativePath` is not relative, it is returned unchanged.
 *
 * `parameters.a.b.c`, `&d` -> `a.b.d`
 * `parameters.a.b[0].c`, `&d` -> `a.b[0].d`
 * `parameters.a.b.c`, `d` -> `d`
 */
export function resolveRelativePath(
	fullPathWithParameters: string,
	candidateRelativePath: string,
): string {
	if (candidateRelativePath.startsWith('&')) {
		const resolvedLeaf = candidateRelativePath.slice(1);
		const pathToLeaf = fullPathWithParameters.split('.').slice(1, -1).join('.');

		if (!pathToLeaf) return resolvedLeaf;

		return `${pathToLeaf}.${resolvedLeaf}`;
	}

	return candidateRelativePath;
}



================================================
FILE: packages/workflow/src/node-parameters/rename-node-utils.ts
================================================
import type { INode, NodeParameterValueType } from '../interfaces';

export function renameFormFields(
	node: INode,
	renameField: (v: NodeParameterValueType) => NodeParameterValueType,
): void {
	const formFields = node.parameters?.formFields;

	const values =
		formFields &&
		typeof formFields === 'object' &&
		'values' in formFields &&
		typeof formFields.values === 'object' &&
		// TypeScript thinks this is `Array.values` and gets very confused here
		// eslint-disable-next-line @typescript-eslint/unbound-method
		Array.isArray(formFields.values)
			? // eslint-disable-next-line @typescript-eslint/unbound-method
				(formFields.values ?? [])
			: [];

	for (const formFieldValue of values) {
		if (!formFieldValue || typeof formFieldValue !== 'object') continue;
		if ('fieldType' in formFieldValue && formFieldValue.fieldType === 'html') {
			if ('html' in formFieldValue) {
				formFieldValue.html = renameField(formFieldValue.html);
			}
		}
	}
}



================================================
FILE: packages/workflow/test/augment-object.test.ts
================================================
import { augmentArray, augmentObject } from '../src/augment-object';
import type { IDataObject } from '../src/interfaces';
import { deepCopy } from '../src/utils';

describe('AugmentObject', () => {
	describe('augmentArray', () => {
		test('should work with arrays', () => {
			const originalObject = [1, 2, 3, 4, null];
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentArray(originalObject);

			expect(augmentedObject.constructor.name).toEqual('Array');

			expect(augmentedObject.push(5)).toEqual(6);
			expect(augmentedObject).toEqual([1, 2, 3, 4, null, 5]);
			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.pop()).toEqual(5);
			expect(augmentedObject).toEqual([1, 2, 3, 4, null]);
			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.shift()).toEqual(1);
			expect(augmentedObject).toEqual([2, 3, 4, null]);
			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.unshift(1)).toEqual(5);
			expect(augmentedObject).toEqual([1, 2, 3, 4, null]);
			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.splice(1, 1)).toEqual([2]);
			expect(augmentedObject).toEqual([1, 3, 4, null]);
			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.slice(1)).toEqual([3, 4, null]);
			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.reverse()).toEqual([null, 4, 3, 1]);
			expect(originalObject).toEqual(copyOriginal);
		});

		test('should work with arrays on any level', () => {
			const originalObject = {
				a: {
					b: {
						c: [
							{
								a3: {
									b3: {
										c3: '03' as string | null,
									},
								},
								aa3: '01',
							},
							{
								a3: {
									b3: {
										c3: '13',
									},
								},
								aa3: '11',
							},
						],
					},
				},
				aa: [
					{
						a3: {
							b3: '2',
						},
						aa3: '1',
					},
				],
			};
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentObject(originalObject);

			// On first level
			augmentedObject.aa[0].a3.b3 = '22';
			expect(augmentedObject.aa[0].a3.b3).toEqual('22');
			expect(originalObject.aa[0].a3.b3).toEqual('2');

			// Make sure that also array operations as push and length work as expected
			// On lower levels
			augmentedObject.a.b.c[0].a3.b3.c3 = '033';
			expect(augmentedObject.a.b.c[0].a3.b3.c3).toEqual('033');
			expect(originalObject.a.b.c[0].a3.b3.c3).toEqual('03');

			augmentedObject.a.b.c[1].a3.b3.c3 = '133';
			expect(augmentedObject.a.b.c[1].a3.b3.c3).toEqual('133');
			expect(originalObject.a.b.c[1].a3.b3.c3).toEqual('13');

			augmentedObject.a.b.c.push({
				a3: {
					b3: {
						c3: '23',
					},
				},
				aa3: '21',
			});
			augmentedObject.a.b.c[2].a3.b3.c3 = '233';
			expect(augmentedObject.a.b.c[2].a3.b3.c3).toEqual('233');

			augmentedObject.a.b.c[2].a3.b3.c3 = '2333';
			expect(augmentedObject.a.b.c[2].a3.b3.c3).toEqual('2333');

			augmentedObject.a.b.c[2].a3.b3.c3 = null;
			expect(augmentedObject.a.b.c[2].a3.b3.c3).toEqual(null);

			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject.a.b.c.length).toEqual(3);

			expect(augmentedObject.aa).toEqual([
				{
					a3: {
						b3: '22',
					},
					aa3: '1',
				},
			]);

			expect(augmentedObject.a.b.c).toEqual([
				{
					a3: {
						b3: {
							c3: '033',
						},
					},
					aa3: '01',
				},
				{
					a3: {
						b3: {
							c3: '133',
						},
					},
					aa3: '11',
				},
				{
					a3: {
						b3: {
							c3: null,
						},
					},
					aa3: '21',
				},
			]);

			expect(augmentedObject).toEqual({
				a: {
					b: {
						c: [
							{
								a3: {
									b3: {
										c3: '033',
									},
								},
								aa3: '01',
							},
							{
								a3: {
									b3: {
										c3: '133',
									},
								},
								aa3: '11',
							},
							{
								a3: {
									b3: {
										c3: null,
									},
								},
								aa3: '21',
							},
						],
					},
				},
				aa: [
					{
						a3: {
							b3: '22',
						},
						aa3: '1',
					},
				],
			});

			expect(originalObject).toEqual(copyOriginal);
		});
	});

	describe('augmentObject', () => {
		test('should work with simple values on first level', () => {
			const date = new Date(1680089084200);
			const regexp = new RegExp('^test$', 'ig');
			const originalObject: IDataObject = {
				1: 11,
				2: '22',
				a: 111,
				b: '222',
				d: date,
				r: regexp,
			};
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentObject(originalObject);

			expect(augmentedObject.constructor.name).toEqual('Object');

			augmentedObject[1] = 911;
			expect(originalObject[1]).toEqual(11);
			expect(augmentedObject[1]).toEqual(911);

			augmentedObject[2] = '922';
			expect(originalObject[2]).toEqual('22');
			expect(augmentedObject[2]).toEqual('922');

			augmentedObject.a = 9111;
			expect(originalObject.a).toEqual(111);
			expect(augmentedObject.a).toEqual(9111);

			augmentedObject.b = '9222';
			expect(originalObject.b).toEqual('222');
			expect(augmentedObject.b).toEqual('9222');

			augmentedObject.c = 3;

			expect({ ...originalObject, d: date.toJSON(), r: {} }).toEqual(copyOriginal);

			expect(augmentedObject).toEqual({
				1: 911,
				2: '922',
				a: 9111,
				b: '9222',
				c: 3,
				d: date.toJSON(),
				r: regexp.toString(),
			});
		});

		test('should work with simple values on sub-level', () => {
			const originalObject = {
				a: {
					b: {
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			};
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentObject(originalObject);

			augmentedObject.a.bb = '92';
			expect(originalObject.a.bb).toEqual('2');
			expect(augmentedObject.a.bb).toEqual('92');

			augmentedObject.a.b.cc = '93';
			expect(originalObject.a.b.cc).toEqual('3');
			expect(augmentedObject.a.b.cc).toEqual('93');

			// @ts-ignore
			augmentedObject.a.b.ccc = {
				d: '4',
			};

			// @ts-ignore
			expect(augmentedObject.a.b.ccc).toEqual({ d: '4' });

			// @ts-ignore
			augmentedObject.a.b.ccc.d = '94';
			// @ts-ignore
			expect(augmentedObject.a.b.ccc.d).toEqual('94');

			expect(originalObject).toEqual(copyOriginal);

			expect(augmentedObject).toEqual({
				a: {
					b: {
						cc: '93',
						ccc: {
							d: '94',
						},
					},
					bb: '92',
				},
				aa: '1',
			});
		});

		test('should work with complex values on first level', () => {
			const originalObject: any = {
				a: {
					b: {
						cc: '3',
						c2: null,
					},
					bb: '2',
				},
				aa: '1',
			};
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentObject(originalObject);

			augmentedObject.a = { new: 'NEW' };
			expect(originalObject.a).toEqual({
				b: {
					c2: null,
					cc: '3',
				},
				bb: '2',
			});
			expect(augmentedObject.a).toEqual({ new: 'NEW' });

			augmentedObject.aa = '11';
			expect(originalObject.aa).toEqual('1');
			expect(augmentedObject.aa).toEqual('11');

			augmentedObject.aaa = {
				bbb: {
					ccc: '333',
				},
			};

			expect(originalObject).toEqual(copyOriginal);
			expect(augmentedObject).toEqual({
				a: {
					new: 'NEW',
				},
				aa: '11',
				aaa: {
					bbb: {
						ccc: '333',
					},
				},
			});
		});

		test('should work with delete and reset', () => {
			const originalObject = {
				a: {
					b: {
						c: {
							d: '4' as string | undefined,
						} as { d?: string; dd?: string } | undefined,
						cc: '3' as string | undefined,
					},
					bb: '2' as string | undefined,
				},
				aa: '1' as string | undefined,
			};
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentObject(originalObject);

			// Remove multiple values
			delete augmentedObject.a.b.c!.d;
			expect(augmentedObject.a.b.c!.d).toEqual(undefined);
			expect(originalObject.a.b.c!.d).toEqual('4');

			expect(augmentedObject).toEqual({
				a: {
					b: {
						c: {},
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			});
			expect(originalObject).toEqual(copyOriginal);

			delete augmentedObject.a.b.c;
			expect(augmentedObject.a.b.c).toEqual(undefined);
			expect(originalObject.a.b.c).toEqual({ d: '4' });

			expect(augmentedObject).toEqual({
				a: {
					b: {
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			});
			expect(originalObject).toEqual(copyOriginal);

			// Set deleted values again
			augmentedObject.a.b.c = { dd: '444' };
			expect(augmentedObject.a.b.c).toEqual({ dd: '444' });
			expect(originalObject).toEqual(copyOriginal);

			augmentedObject.a.b.c.d = '44';
			expect(augmentedObject).toEqual({
				a: {
					b: {
						c: {
							d: '44',
							dd: '444',
						},
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			});
			expect(originalObject).toEqual(copyOriginal);
		});

		// Is almost identical to above test
		test('should work with setting to undefined and reset', () => {
			const originalObject = {
				a: {
					b: {
						c: {
							d: '4' as string | undefined,
						} as { d?: string; dd?: string } | undefined,
						cc: '3' as string | undefined,
					},
					bb: '2' as string | undefined,
				},
				aa: '1' as string | undefined,
			};
			const copyOriginal = deepCopy(originalObject);

			const augmentedObject = augmentObject(originalObject);

			// Remove multiple values
			augmentedObject.a.b.c!.d = undefined;
			expect(augmentedObject.a.b.c!.d).toEqual(undefined);
			expect(originalObject.a.b.c!.d).toEqual('4');

			expect(augmentedObject).toEqual({
				a: {
					b: {
						c: {},
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			});
			expect(originalObject).toEqual(copyOriginal);

			augmentedObject.a.b.c = undefined;
			expect(augmentedObject.a.b.c).toEqual(undefined);
			expect(originalObject.a.b.c).toEqual({ d: '4' });

			expect(augmentedObject).toEqual({
				a: {
					b: {
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			});
			expect(originalObject).toEqual(copyOriginal);

			// Set deleted values again
			augmentedObject.a.b.c = { dd: '444' };
			expect(augmentedObject.a.b.c).toEqual({ dd: '444' });
			expect(originalObject).toEqual(copyOriginal);

			augmentedObject.a.b.c.d = '44';
			expect(augmentedObject).toEqual({
				a: {
					b: {
						c: {
							d: '44',
							dd: '444',
						},
						cc: '3',
					},
					bb: '2',
				},
				aa: '1',
			});
			expect(originalObject).toEqual(copyOriginal);
		});

		// Skipping this test since it is no longer true in vitest, to be investigated
		// eslint-disable-next-line n8n-local-rules/no-skipped-tests
		test.skip('should be faster than doing a deepCopy', () => {
			const iterations = 100;
			const originalObject: any = {
				a: {
					b: {
						c: {
							d: {
								e: {
									f: 12345,
								},
							},
						},
					},
				},
			};
			for (let i = 0; i < 10; i++) {
				originalObject[i.toString()] = deepCopy(originalObject);
			}

			let startTime = new Date().getTime();
			for (let i = 0; i < iterations; i++) {
				const augmentedObject = augmentObject(originalObject);
				for (let i = 0; i < 5000; i++) {
					augmentedObject.a!.b.c.d.e.f++;
				}
			}
			const timeAugmented = new Date().getTime() - startTime;

			startTime = new Date().getTime();
			for (let i = 0; i < iterations; i++) {
				const copiedObject = deepCopy(originalObject);
				for (let i = 0; i < 5000; i++) {
					copiedObject.a!.b.c.d.e.f++;
				}
			}
			const timeCopied = new Date().getTime() - startTime;

			expect(timeAugmented).toBeLessThan(timeCopied);
		});

		test('should ignore non-enumerable keys', () => {
			const originalObject = { a: 1, b: 2 };
			Object.defineProperty(originalObject, '__hiddenProp', { enumerable: false });

			const augmentedObject = augmentObject(originalObject);
			expect(Object.keys(augmentedObject)).toEqual(['a', 'b']);
		});

		test('should return property descriptors', () => {
			const originalObject: any = {
				x: {
					y: {},
					z: {},
				},
			};
			const augmentedObject = augmentObject(originalObject);

			expect(Object.getOwnPropertyDescriptor(augmentedObject.x, 'y')).toEqual({
				configurable: true,
				enumerable: true,
				value: {},
				writable: true,
			});

			delete augmentedObject.x.y;
			expect(augmentedObject.x.hasOwnProperty('y')).toEqual(false);

			augmentedObject.x.y = 42;
			expect(augmentedObject.x.hasOwnProperty('y')).toEqual(true);
			expect(Object.getOwnPropertyDescriptor(augmentedObject.x, 'y')).toEqual({
				configurable: true,
				enumerable: true,
				value: 42,
				writable: true,
			});
		});

		test('should return valid values on `has` calls', () => {
			const originalObject: any = {
				x: {
					y: {},
				},
			};
			const augmentedObject = augmentObject(originalObject);
			expect('y' in augmentedObject.x).toBe(true);
			expect('z' in augmentedObject.x).toBe(false);

			augmentedObject.x.z = 5;
			expect('z' in augmentedObject.x).toBe(true);
			expect('y' in augmentedObject.x).toBe(true);
		});

		test('should ignore non-enumerable keys', () => {
			const originalObject: { toString?: string } = { toString: '123' };
			const augmentedObject = augmentObject(originalObject);
			expect('toString' in augmentedObject).toBe(true);
			expect(Object.keys(augmentedObject)).toEqual(['toString']);
			expect(Object.getOwnPropertyDescriptor(augmentedObject, 'toString')?.value).toEqual(
				originalObject.toString,
			);
			expect(augmentedObject.toString).toEqual(originalObject.toString);

			augmentedObject.toString = '456';
			expect(augmentedObject.toString).toBe('456');

			delete augmentedObject.toString;
			expect(augmentedObject.toString).toBeUndefined();
		});

		test('should handle constructor property correctly', () => {
			const originalObject: any = {
				a: {
					b: {
						c: {
							d: '4',
						},
					},
				},
			};
			const augmentedObject = augmentObject(originalObject);

			expect(augmentedObject.constructor.name).toEqual('Object');
			expect(augmentedObject.a.constructor.name).toEqual('Object');
			expect(augmentedObject.a.b.constructor.name).toEqual('Object');
			expect(augmentedObject.a.b.c.constructor.name).toEqual('Object');

			augmentedObject.constructor = {};
			expect(augmentedObject.constructor.name).toEqual('Object');

			delete augmentedObject.constructor;
			expect(augmentedObject.constructor.name).toEqual('Object');
		});
	});
});



================================================
FILE: packages/workflow/test/common.test.ts
================================================
import type { IConnections, IConnection } from '../src/interfaces';
import { NodeConnectionTypes } from '../src/interfaces';
import { mapConnectionsByDestination } from '../src/common';

describe('getConnectionsByDestination', () => {
	it('should return empty object when there are no connections', () => {
		const result = mapConnectionsByDestination({});

		expect(result).toEqual({});
	});

	it('should return connections by destination node', () => {
		const connections: IConnections = {
			Node1: {
				[NodeConnectionTypes.Main]: [
					[
						{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 },
						{ node: 'Node3', type: NodeConnectionTypes.Main, index: 1 },
					],
				],
			},
		};
		const result = mapConnectionsByDestination(connections);
		expect(result).toEqual({
			Node2: {
				[NodeConnectionTypes.Main]: [[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 }]],
			},
			Node3: {
				[NodeConnectionTypes.Main]: [
					[],
					[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 }],
				],
			},
		});
	});

	it('should handle multiple connection types', () => {
		const connections: IConnections = {
			Node1: {
				[NodeConnectionTypes.Main]: [[{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 }]],
				[NodeConnectionTypes.AiAgent]: [
					[{ node: 'Node3', type: NodeConnectionTypes.AiAgent, index: 0 }],
				],
			},
		};

		const result = mapConnectionsByDestination(connections);
		expect(result).toEqual({
			Node2: {
				[NodeConnectionTypes.Main]: [[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 }]],
			},
			Node3: {
				[NodeConnectionTypes.AiAgent]: [
					[{ node: 'Node1', type: NodeConnectionTypes.AiAgent, index: 0 }],
				],
			},
		});
	});

	it('should handle nodes with no connections', () => {
		const connections: IConnections = {
			Node1: {
				[NodeConnectionTypes.Main]: [[]],
			},
		};

		const result = mapConnectionsByDestination(connections);
		expect(result).toEqual({});
	});

	// @issue https://linear.app/n8n/issue/N8N-7880/cannot-load-some-templates
	it('should handle nodes with null connections', () => {
		const connections: IConnections = {
			Node1: {
				[NodeConnectionTypes.Main]: [
					null as unknown as IConnection[],
					[{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 }],
				],
			},
		};

		const result = mapConnectionsByDestination(connections);
		expect(result).toEqual({
			Node2: {
				[NodeConnectionTypes.Main]: [[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 1 }]],
			},
		});
	});

	it('should handle nodes with multiple input connections', () => {
		const connections: IConnections = {
			Node1: {
				[NodeConnectionTypes.Main]: [[{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 }]],
			},
			Node3: {
				[NodeConnectionTypes.Main]: [[{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 }]],
			},
		};

		const result = mapConnectionsByDestination(connections);
		expect(result).toEqual({
			Node2: {
				[NodeConnectionTypes.Main]: [
					[
						{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 },
						{ node: 'Node3', type: NodeConnectionTypes.Main, index: 0 },
					],
				],
			},
		});
	});
});



================================================
FILE: packages/workflow/test/cron.test.ts
================================================
import { toCronExpression } from '../src/cron';
import type { CronExpression } from '../src/interfaces';

describe('Cron', () => {
	describe('toCronExpression', () => {
		test('should generate a valid cron for `everyMinute` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyMinute',
			});
			expect(expression).toMatch(/^[1-5]?[0-9] \* \* \* \* \*$/);
		});

		test('should generate a valid cron for `everyHour` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyHour',
				minute: 11,
			});
			expect(expression).toMatch(/^[1-5]?[0-9] 11 \* \* \* \*$/);
		});

		test('should generate a valid cron for `everyX[minutes]` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyX',
				unit: 'minutes',
				value: 42,
			});
			expect(expression).toMatch(/^[1-5]?[0-9] \*\/42 \* \* \* \*$/);
		});

		test('should generate a valid cron for `everyX[hours]` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyX',
				unit: 'hours',
				value: 3,
			});
			expect(expression).toMatch(/^[1-5]?[0-9] [1-5]?[0-9] \*\/3 \* \* \*$/);
		});

		test('should generate a valid cron for `everyDay` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyDay',
				hour: 13,
				minute: 17,
			});
			expect(expression).toMatch(/^[1-5]?[0-9] 17 13 \* \* \*$/);
		});

		test('should generate a valid cron for `everyWeek` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyWeek',
				hour: 13,
				minute: 17,
				weekday: 4,
			});
			expect(expression).toMatch(/^[1-5]?[0-9] 17 13 \* \* 4$/);
		});

		test('should generate a valid cron for `everyMonth` triggers', () => {
			const expression = toCronExpression({
				mode: 'everyMonth',
				hour: 13,
				minute: 17,
				dayOfMonth: 12,
			});
			expect(expression).toMatch(/^[1-5]?[0-9] 17 13 12 \* \*$/);
		});

		test('should trim custom cron expressions', () => {
			const expression = toCronExpression({
				mode: 'custom',
				cronExpression: ' 0 9-17 * * * ' as CronExpression,
			});
			expect(expression).toEqual('0 9-17 * * *');
		});
	});
});



================================================
FILE: packages/workflow/test/deferred-promise.test.ts
================================================
import { createDeferredPromise } from '../src/deferred-promise';

describe('DeferredPromise', () => {
	it('should resolve the promise with the correct value', async () => {
		let done = false;
		const deferred = createDeferredPromise<string>();
		void deferred.promise.finally(() => {
			done = true;
		});
		expect(done).toBe(false);
		deferred.resolve('test');
		await expect(deferred.promise).resolves.toBe('test');
		expect(done).toBe(true);
	});

	it('should reject the promise with the correct error', async () => {
		const deferred = createDeferredPromise();
		const error = new Error('test error');
		deferred.reject(error);
		await expect(deferred.promise).rejects.toThrow(error);
	});
});



================================================
FILE: packages/workflow/test/expression-sandboxing.test.ts
================================================
import { Tournament } from '@n8n/tournament';

import { PrototypeSanitizer, sanitizer } from '../src/expression-sandboxing';

const tournament = new Tournament(
	(e) => {
		throw e;
	},
	undefined,
	undefined,
	{
		before: [],
		after: [PrototypeSanitizer],
	},
);

const errorRegex = /^Cannot access ".*" due to security concerns$/;

describe('PrototypeSanitizer', () => {
	describe('Static analysis', () => {
		it('should not allow access to __proto__', () => {
			expect(() => {
				tournament.execute('{{ ({}).__proto__.__proto__ }}', {});
			}).toThrowError(errorRegex);

			expect(() => {
				tournament.execute('{{ ({})["__proto__"]["__proto__"] }}', {});
			}).toThrowError(errorRegex);
		});

		it('should not allow access to prototype', () => {
			expect(() => {
				tournament.execute('{{ Number.prototype }}', { Number });
			}).toThrowError(errorRegex);

			expect(() => {
				tournament.execute('{{ Number["prototype"] }}', { Number });
			}).toThrowError(errorRegex);
		});

		it('should not allow access to constructor', () => {
			expect(() => {
				tournament.execute('{{ Number.constructor }}', {
					__sanitize: sanitizer,
					Number,
				});
			}).toThrowError(errorRegex);

			expect(() => {
				tournament.execute('{{ Number["constructor"] }}', {
					__sanitize: sanitizer,
					Number,
				});
			}).toThrowError(errorRegex);
		});
	});

	describe('Runtime', () => {
		it('should not allow access to __proto__', () => {
			expect(() => {
				tournament.execute('{{ ({})["__" + (() => "proto")() + "__"] }}', {
					__sanitize: sanitizer,
				});
			}).toThrowError(errorRegex);
		});

		it('should not allow access to prototype', () => {
			expect(() => {
				tournament.execute('{{ Number["pro" + (() => "toty")() + "pe"] }}', {
					__sanitize: sanitizer,
					Number,
				});
			}).toThrowError(errorRegex);
		});

		it('should not allow access to constructor', () => {
			expect(() => {
				tournament.execute('{{ Number["cons" + (() => "truc")() + "tor"] }}', {
					__sanitize: sanitizer,
					Number,
				});
			}).toThrowError(errorRegex);
		});
	});
});



================================================
FILE: packages/workflow/test/expression.test.ts
================================================
// @vitest-environment jsdom

import { DateTime, Duration, Interval } from 'luxon';

import { workflow } from './ExpressionExtensions/helpers';
import { baseFixtures } from './ExpressionFixtures/base';
import type { ExpressionTestEvaluation, ExpressionTestTransform } from './ExpressionFixtures/base';
import * as Helpers from './helpers';
import { ExpressionError } from '../src/errors/expression.error';
import { extendSyntax } from '../src/extensions/expression-extension';
import type { INodeExecutionData } from '../src/interfaces';
import { Workflow } from '../src/workflow';

describe('Expression', () => {
	describe('getParameterValue()', () => {
		const nodeTypes = Helpers.NodeTypes();
		const workflow = new Workflow({
			id: '1',
			nodes: [
				{
					name: 'node',
					typeVersion: 1,
					type: 'test.set',
					id: 'uuid-1234',
					position: [0, 0],
					parameters: {},
				},
			],
			connections: {},
			active: false,
			nodeTypes,
		});
		const expression = workflow.expression;

		const evaluate = (value: string) =>
			expression.getParameterValue(value, null, 0, 0, 'node', [], 'manual', {});

		it('should not be able to use global built-ins from denylist', () => {
			expect(evaluate('={{document}}')).toEqual({});
			expect(evaluate('={{window}}')).toEqual({});

			expect(evaluate('={{Window}}')).toEqual({});
			expect(evaluate('={{globalThis}}')).toEqual({});
			expect(evaluate('={{self}}')).toEqual({});

			expect(evaluate('={{alert}}')).toEqual({});
			expect(evaluate('={{prompt}}')).toEqual({});
			expect(evaluate('={{confirm}}')).toEqual({});

			expect(evaluate('={{eval}}')).toEqual({});
			expect(evaluate('={{uneval}}')).toEqual({});
			expect(evaluate('={{setTimeout}}')).toEqual({});
			expect(evaluate('={{setInterval}}')).toEqual({});
			expect(evaluate('={{Function}}')).toEqual({});

			expect(evaluate('={{fetch}}')).toEqual({});
			expect(evaluate('={{XMLHttpRequest}}')).toEqual({});

			expect(evaluate('={{Promise}}')).toEqual({});
			expect(evaluate('={{Generator}}')).toEqual({});
			expect(evaluate('={{GeneratorFunction}}')).toEqual({});
			expect(evaluate('={{AsyncFunction}}')).toEqual({});
			expect(evaluate('={{AsyncGenerator}}')).toEqual({});
			expect(evaluate('={{AsyncGeneratorFunction}}')).toEqual({});

			expect(evaluate('={{WebAssembly}}')).toEqual({});

			expect(evaluate('={{Reflect}}')).toEqual({});
			expect(evaluate('={{Proxy}}')).toEqual({});

			vi.useFakeTimers({ now: new Date() });
			expect(() => evaluate('={{constructor}}')).toThrowError(
				new ExpressionError('Cannot access "constructor" due to security concerns'),
			);
			vi.useRealTimers();

			expect(evaluate('={{escape}}')).toEqual({});
			expect(evaluate('={{unescape}}')).toEqual({});
		});

		it('should be able to use global built-ins from allowlist', () => {
			expect(evaluate('={{new Date()}}')).toBeInstanceOf(Date);
			expect(evaluate('={{DateTime.now().toLocaleString()}}')).toEqual(
				DateTime.now().toLocaleString(),
			);

			vi.useFakeTimers({ now: new Date() });
			expect(evaluate('={{Interval.after(new Date(), 100)}}')).toEqual(
				Interval.after(new Date(), 100),
			);
			vi.useRealTimers();

			expect(evaluate('={{Duration.fromMillis(100)}}')).toEqual(Duration.fromMillis(100));

			expect(evaluate('={{new Object()}}')).toEqual(new Object());

			expect(evaluate('={{new Array()}}')).toEqual([]);
			expect(evaluate('={{new Int8Array()}}')).toEqual(new Int8Array());
			expect(evaluate('={{new Uint8Array()}}')).toEqual(new Uint8Array());
			expect(evaluate('={{new Uint8ClampedArray()}}')).toEqual(new Uint8ClampedArray());
			expect(evaluate('={{new Int16Array()}}')).toEqual(new Int16Array());
			expect(evaluate('={{new Uint16Array()}}')).toEqual(new Uint16Array());
			expect(evaluate('={{new Int32Array()}}')).toEqual(new Int32Array());
			expect(evaluate('={{new Uint32Array()}}')).toEqual(new Uint32Array());
			expect(evaluate('={{new Float32Array()}}')).toEqual(new Float32Array());
			expect(evaluate('={{new Float64Array()}}')).toEqual(new Float64Array());
			expect(evaluate('={{new BigInt64Array()}}')).toEqual(new BigInt64Array());
			expect(evaluate('={{new BigUint64Array()}}')).toEqual(new BigUint64Array());

			expect(evaluate('={{new Map()}}')).toEqual(new Map());
			expect(evaluate('={{new WeakMap()}}')).toEqual(new WeakMap());
			expect(evaluate('={{new Set()}}')).toEqual(new Set());
			expect(evaluate('={{new WeakSet()}}')).toEqual(new WeakSet());

			expect(evaluate('={{new Error()}}')).toEqual(new Error());
			expect(evaluate('={{new TypeError()}}')).toEqual(new TypeError());
			expect(evaluate('={{new SyntaxError()}}')).toEqual(new SyntaxError());
			expect(evaluate('={{new EvalError()}}')).toEqual(new EvalError());
			expect(evaluate('={{new RangeError()}}')).toEqual(new RangeError());
			expect(evaluate('={{new ReferenceError()}}')).toEqual(new ReferenceError());
			expect(evaluate('={{new URIError()}}')).toEqual(new URIError());

			expect(evaluate('={{Intl}}')).toEqual(Intl);

			expect(evaluate('={{new String()}}')).toEqual(new String());
			expect(evaluate("={{new RegExp('')}}")).toEqual(new RegExp(''));

			expect(evaluate('={{Math}}')).toEqual(Math);
			expect(evaluate('={{new Number()}}')).toEqual(new Number());
			expect(evaluate("={{BigInt('1')}}")).toEqual(BigInt('1'));
			expect(evaluate('={{Infinity}}')).toEqual(Infinity);
			expect(evaluate('={{NaN}}')).toEqual(NaN);
			expect(evaluate('={{isFinite(1)}}')).toEqual(isFinite(1));
			expect(evaluate('={{isNaN(1)}}')).toEqual(isNaN(1));
			expect(evaluate("={{parseFloat('1')}}")).toEqual(parseFloat('1'));
			expect(evaluate("={{parseInt('1', 10)}}")).toEqual(parseInt('1', 10));

			expect(evaluate('={{JSON.stringify({})}}')).toEqual(JSON.stringify({}));
			expect(evaluate('={{new ArrayBuffer(10)}}')).toEqual(new ArrayBuffer(10));
			expect(evaluate('={{new SharedArrayBuffer(10)}}')).toEqual(new SharedArrayBuffer(10));
			expect(evaluate('={{Atomics}}')).toEqual(Atomics);
			expect(evaluate('={{new DataView(new ArrayBuffer(1))}}')).toEqual(
				new DataView(new ArrayBuffer(1)),
			);

			expect(evaluate("={{encodeURI('https://google.com')}}")).toEqual(
				encodeURI('https://google.com'),
			);
			expect(evaluate("={{encodeURIComponent('https://google.com')}}")).toEqual(
				encodeURIComponent('https://google.com'),
			);
			expect(evaluate("={{decodeURI('https://google.com')}}")).toEqual(
				decodeURI('https://google.com'),
			);
			expect(evaluate("={{decodeURIComponent('https://google.com')}}")).toEqual(
				decodeURIComponent('https://google.com'),
			);

			expect(evaluate('={{Boolean(1)}}')).toEqual(Boolean(1));
			expect(evaluate('={{Symbol(1).toString()}}')).toEqual(Symbol(1).toString());
		});

		it('should not able to do arbitrary code execution', () => {
			const testFn = vi.fn();
			Object.assign(global, { testFn });

			vi.useFakeTimers({ now: new Date() });
			expect(() => evaluate("={{ Date['constructor']('testFn()')()}}")).toThrowError(
				new ExpressionError('Cannot access "constructor" due to security concerns'),
			);
			vi.useRealTimers();

			expect(testFn).not.toHaveBeenCalled();
		});
	});

	describe('Test all expression value fixtures', () => {
		const expression = workflow.expression;

		const evaluate = (value: string, data: INodeExecutionData[]) => {
			const itemIndex = data.length === 0 ? -1 : 0;
			return expression.getParameterValue(value, null, 0, itemIndex, 'node', data, 'manual', {});
		};

		for (const t of baseFixtures) {
			if (!t.tests.some((test) => test.type === 'evaluation')) {
				continue;
			}
			test(t.expression, () => {
				vi.spyOn(workflow, 'getParentNodes').mockReturnValue(['Parent']);

				const evaluationTests = t.tests.filter(
					(test): test is ExpressionTestEvaluation => test.type === 'evaluation',
				);

				for (const test of evaluationTests) {
					const input = test.input.map((d) => ({ json: d })) as any;

					if ('error' in test) {
						vi.useFakeTimers({ now: test.error.timestamp });

						expect(() => evaluate(t.expression, input)).toThrowError(test.error);

						vi.useRealTimers();
					} else {
						expect(evaluate(t.expression, input)).toStrictEqual(test.output);
					}
				}
			});
		}
	});

	describe('Test all expression transform fixtures', () => {
		for (const t of baseFixtures) {
			if (!t.tests.some((test) => test.type === 'transform')) {
				continue;
			}
			test(t.expression, () => {
				vi.useFakeTimers({ now: new Date() });

				for (const test of t.tests.filter(
					(test): test is ExpressionTestTransform => test.type === 'transform',
				)) {
					const expr = t.expression;
					expect(extendSyntax(expr, test.forceTransform)).toEqual(test.result ?? expr);
				}

				vi.useRealTimers();
			});
		}
	});
});



================================================
FILE: packages/workflow/test/filter-parameter.test.ts
================================================
import merge from 'lodash/merge';
import { DateTime } from 'luxon';

import type { FilterConditionValue, FilterValue } from '../src/interfaces';
import { arrayContainsValue, executeFilter } from '../src/node-parameters/filter-parameter';

type DeepPartial<T> = {
	[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type Tests = Array<{
	left: FilterConditionValue['leftValue'];
	right: FilterConditionValue['rightValue'];
	expected: boolean;
}>;

const filterFactory = (data: DeepPartial<FilterValue> = {}): FilterValue =>
	merge(
		{
			combinator: 'and',
			conditions: [],
			options: {
				version: 1,
				leftValue: '',
				caseSensitive: false,
				typeValidation: 'strict',
			},
		} as FilterValue,
		data,
	);

describe('FilterParameter', () => {
	describe('executeFilter', () => {
		it('should support and/or combinators', () => {
			const falseCondition: FilterConditionValue = {
				id: '1',
				leftValue: 'foo',
				rightValue: 'bar',
				operator: { operation: 'equals', type: 'string' },
			};
			const trueCondition: FilterConditionValue = {
				id: '2',
				leftValue: 'foo',
				rightValue: 'foo',
				operator: { operation: 'equals', type: 'string' },
			};

			const andResult = executeFilter(
				filterFactory({ combinator: 'and', conditions: [falseCondition, trueCondition] }),
			);
			expect(andResult).toBe(false);

			const orResult = executeFilter(
				filterFactory({ combinator: 'or', conditions: [falseCondition, trueCondition] }),
			);
			expect(orResult).toBe(true);
		});

		describe('options.caseSensitive', () => {
			it('should evaluate strings case insensitive (=default)', () => {
				const result = executeFilter(
					filterFactory({
						combinator: 'and',
						conditions: [
							{
								id: '1',
								leftValue: 'FOO',
								rightValue: 'foo',
								operator: { operation: 'equals', type: 'string' },
							},
							{
								id: '2',
								leftValue: 'foobarbaz',
								rightValue: 'BAR',
								operator: { operation: 'contains', type: 'string' },
							},
						],
						options: { caseSensitive: false },
					}),
				);
				expect(result).toBe(true);
			});

			it('should evaluate strings case sensitive', () => {
				const result = executeFilter(
					filterFactory({
						combinator: 'or',
						conditions: [
							{
								id: '1',
								leftValue: 'Foo',
								rightValue: 'FOO',
								operator: { operation: 'equals', type: 'string' },
							},
							{
								id: '2',
								leftValue: 'foobarbaz',
								rightValue: 'BAR',
								operator: { operation: 'contains', type: 'string' },
							},
						],
						options: { caseSensitive: true },
					}),
				);
				expect(result).toBe(false);
			});
		});

		describe('options.typeValidation', () => {
			describe('strict (=default)', () => {
				it('should throw an error when types are not as expected (primitives)', () => {
					expect(() =>
						executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: '15',
										rightValue: true,
										operator: { operation: 'equals', type: 'number' },
									},
								],
								options: { typeValidation: 'strict' },
							}),
						),
					).toThrowError(
						"Wrong type: '15' is a string but was expecting a number [condition 0, item 0]",
					);
				});

				it('should throw an error when types are not as expected (arrays)', () => {
					expect(() =>
						executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: '[]',
										rightValue: 0,
										operator: { operation: 'lengthEquals', type: 'array', rightType: 'number' },
									},
								],
								options: { typeValidation: 'strict' },
							}),
						),
					).toThrowError(
						"Wrong type: '[]' is a string but was expecting an array [condition 0, item 0]",
					);
				});

				it('should throw an error when types are not as expected (objects)', () => {
					expect(() =>
						executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: '{}',
										operator: { operation: 'empty', type: 'object', singleValue: true },
									},
								],
								options: { typeValidation: 'strict' },
							}),
						),
					).toThrowError(
						"Wrong type: '{}' is a string but was expecting an object [condition 0, item 0]",
					);
				});
			});

			describe('loose', () => {
				it('should evaluate conditions when type can be converted', () => {
					const result = executeFilter(
						filterFactory({
							combinator: 'and',
							conditions: [
								{
									id: '1',
									leftValue: '15',
									rightValue: 15,
									operator: { operation: 'equals', type: 'number' },
								},
								{
									id: '2',
									leftValue: 'true',
									operator: { operation: 'true', type: 'boolean' },
								},
								{
									id: '3',
									leftValue: '',
									operator: { operation: 'false', type: 'boolean' },
								},

								{
									id: '4',
									leftValue: 0,
									operator: { operation: 'false', type: 'boolean' },
								},
								{
									id: '5',
									leftValue: 1,
									operator: { operation: 'true', type: 'boolean' },
								},
								{
									id: '6',
									leftValue: 'a string',
									operator: { operation: 'true', type: 'boolean' },
								},
							],
							options: { typeValidation: 'loose' },
						}),
					);
					expect(result).toBe(true);
				});

				it('should throw an error when types cannot be converted', () => {
					expect(() =>
						executeFilter(
							filterFactory({
								combinator: 'and',
								conditions: [
									{
										id: '1',
										leftValue: 'a string',
										rightValue: 15,
										operator: { operation: 'equals', type: 'number' },
									},
								],
								options: { typeValidation: 'loose' },
							}),
						),
					).toThrowError(
						"Conversion error: the string 'a string' can't be converted to a number [condition 0, item 0]",
					);
				});
			});
		});

		describe('options.version', () => {
			describe('version 1', () => {
				it('should parse "false" as true', () => {
					expect(
						executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: 'false',
										rightValue: false,
										operator: { operation: 'equals', type: 'boolean' },
									},
								],
								options: { typeValidation: 'loose', version: 1 },
							}),
						),
					).toEqual(false);
				});
			});

			describe('version 2', () => {
				it('should parse "false" as false', () => {
					expect(
						executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: 'false',
										rightValue: false,
										operator: { operation: 'equals', type: 'boolean' },
									},
								],
								options: { typeValidation: 'loose', version: 2 },
							}),
						),
					).toEqual(true);
				});
			});
		});

		describe('operators', () => {
			describe('exists', () => {
				it.each([
					{ left: '', expected: true },
					{ left: null, expected: false },
					{ left: undefined, expected: false },
					{ left: 'foo', expected: true },
				])('string:exists($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left as string,
									operator: { operation: 'exists', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: '', expected: false },
					{ left: null, expected: true },
					{ left: undefined, expected: true },
					{ left: 'foo', expected: false },
				])('string:notExists($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left as string,
									operator: { operation: 'notExists', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});
			});

			describe('string', () => {
				it.each([
					{ left: null, expected: true },
					{ left: undefined, expected: true },
					{ left: '', expected: true },
					{ left: '🐛', expected: false },
				])('string:empty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{ id: '1', leftValue: left, operator: { operation: 'empty', type: 'string' } },
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: null, expected: false },
					{ left: undefined, expected: false },
					{ left: '', expected: false },
					{ left: '🐛', expected: true },
				])('string:notEmpty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{ id: '1', leftValue: left, operator: { operation: 'notEmpty', type: 'string' } },
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: true },
					{ left: 'first string', right: 'second string', expected: false },
					{ left: '', right: '🐛', expected: false },
					{ left: '🐛', right: '🐛', expected: true },
				])('string:equals("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'equals', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: false },
					{ left: 'first string', right: 'second string', expected: true },
					{ left: '', right: '🐛', expected: true },
					{ left: '🐛', right: '🐛', expected: false },
				])('string:notEquals("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notEquals', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: true },
					{ left: 'first string', right: 'first', expected: true },
					{ left: 'first string', right: 'irs', expected: true },
					{ left: 'first string', right: '', expected: true },
					{ left: 'first string', right: '?', expected: false },
				])('string:contains("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'contains', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: false },
					{ left: 'first string', right: 'first', expected: false },
					{ left: 'first string', right: 'irs', expected: false },
					{ left: 'first string', right: '', expected: false },
					{ left: 'first string', right: '?', expected: true },
				])('string:notContains("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notContains', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: true },
					{ left: 'first string', right: 'first', expected: true },
					{ left: 'first string', right: 'irs', expected: false },
					{ left: 'first string', right: '', expected: true },
					{ left: 'first string', right: '?', expected: false },
				])('string:startsWith("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'startsWith', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: false },
					{ left: 'first string', right: 'first', expected: false },
					{ left: 'first string', right: 'irs', expected: true },
					{ left: 'first string', right: '', expected: false },
					{ left: 'first string', right: '?', expected: true },
				])('string:notStartsWith("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notStartsWith', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: true },
					{ left: 'first string', right: 'string', expected: true },
					{ left: 'first string', right: 'g', expected: true },
					{ left: 'first string', right: '', expected: true },
					{ left: 'first string', right: '?', expected: false },
				])('string:endsWith("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'endsWith', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first string', expected: false },
					{ left: 'first string', right: 'string', expected: false },
					{ left: 'first string', right: 'g', expected: false },
					{ left: 'first string', right: '', expected: false },
					{ left: 'first string', right: '?', expected: true },
				])('string:notEndsWith("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notEndsWith', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first', expected: true },
					{ left: 'first string', right: 'second', expected: false },
					{ left: 'first string', right: '.*', expected: true },
					{ left: 'any string', right: '[0-9]', expected: false },
					{ left: 'any string', right: '[a-z]', expected: true },
					{ left: 'lowercase', right: '[A-Z]', expected: false },
					{ left: 'foo', right: '/^fo{2}$/g', expected: true },
				])('string:regex("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'regex', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 'first string', right: 'first', expected: false },
					{ left: 'first string', right: 'second', expected: true },
					{ left: 'first string', right: '.*', expected: false },
					{ left: 'any string', right: '[0-9]', expected: true },
					{ left: 'any string', right: '[a-z]', expected: false },
					{ left: 'lowercase', right: '[A-Z]', expected: true },
					{ left: 'foo', right: '/^fo{2}$/g', expected: false },
				])('string:notRegex("$left","$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notRegex', type: 'string' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});
			});

			describe('number', () => {
				it.each([
					{ left: 0, expected: true },
					{ left: 15, expected: true },
					{ left: -15.4, expected: true },
					{ left: NaN, expected: false },
					{ left: null, expected: false },
				])('number:exists($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'exists', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, expected: false },
					{ left: 15, expected: false },
					{ left: -15.4, expected: false },
					{ left: NaN, expected: true },
					{ left: null, expected: true },
				])('number:notExists($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'notExists', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, expected: false },
					{ left: 15, expected: false },
					{ left: -15.4, expected: false },
					{ left: NaN, expected: true },
					{ left: null, expected: true },
				])('number:empty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'empty', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, expected: true },
					{ left: 15, expected: true },
					{ left: -15.4, expected: true },
					{ left: NaN, expected: false },
					{ left: null, expected: false },
				])('number:notEmpty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'notEmpty', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, right: 0, expected: true },
					{ left: 15, right: 15, expected: true },
					{ left: 15.34, right: 15.34, expected: true },
					{ left: 15, right: 15.3249038, expected: false },
					{ left: 15, right: NaN, expected: false },
					{ left: NaN, right: NaN, expected: false },
				])('number:equals($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'equals', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, right: 0, expected: false },
					{ left: 15, right: 15, expected: false },
					{ left: 15.34, right: 15.34, expected: false },
					{ left: 15, right: 15.3249038, expected: true },
					{ left: 15, right: NaN, expected: true },
					{ left: NaN, right: NaN, expected: true },
				])('number:notEquals($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notEquals', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, right: 0, expected: false },
					{ left: 15, right: 16, expected: false },
					{ left: 16, right: 15, expected: true },
					{ left: 15.34001, right: 15.34, expected: true },
					{ left: 15, right: NaN, expected: false },
				])('number:gt($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'gt', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, right: 0, expected: false },
					{ left: 15, right: 16, expected: true },
					{ left: 16, right: 15, expected: false },
					{ left: 15.34001, right: 15.34, expected: false },
					{ left: 15, right: NaN, expected: false },
				])('number:lt($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'lt', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, right: 0, expected: true },
					{ left: 15, right: 16, expected: false },
					{ left: 16, right: 15, expected: true },
					{ left: 15.34001, right: 15.34, expected: true },
					{ left: 15, right: NaN, expected: false },
				])('number:gte($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'gte', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: 0, right: 0, expected: true },
					{ left: 15, right: 16, expected: true },
					{ left: 16, right: 15, expected: false },
					{ left: 15.34001, right: 15.34, expected: false },
					{ left: 15, right: NaN, expected: false },
				])('number:lte($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'lte', type: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});
			});

			describe('dateTime', () => {
				it.each([
					{ left: '2023-11-15T17:10:49.113Z', expected: false },
					{ left: null, expected: true },
				])('dateTime:empty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'empty', type: 'dateTime' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', expected: true },
					{ left: null, expected: false },
				])('dateTime:notEmpty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'notEmpty', type: 'dateTime' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:10:49.113Z', expected: true },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:12:49.113Z', expected: false },
				])('dateTime:equals("$left", "$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'equals', type: 'dateTime' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:10:49.113Z', expected: false },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:12:49.113Z', expected: true },
				])('dateTime:notEquals("$left", "$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notEquals', type: 'dateTime' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:10:49.113Z', expected: false },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:12:49.113Z', expected: false },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-01-01T00:00:00.000Z', expected: true },
					{ left: '2024-01-01', right: new Date('2023-01-01T00:00:00.000Z'), expected: true },
					{
						left: DateTime.fromFormat('2024-01-01', 'yyyy-MM-dd'),
						right: '1-Feb-2024',
						expected: false,
					},
				] as Tests)(
					'dateTime:after("$left", "$right") === $expected',
					({ left, right, expected }) => {
						const result = executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: left,
										rightValue: right,
										operator: { operation: 'after', type: 'dateTime' },
									},
								],
							}),
						);
						expect(result).toBe(expected);
					},
				);

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:10:49.113Z', expected: false },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:12:49.113Z', expected: true },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-01-01T00:00:00.000Z', expected: false },
				])('dateTime:before("$left", "$right") === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'before', type: 'dateTime' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:10:49.113Z', expected: true },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:12:49.113Z', expected: false },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-01-01T00:00:00.000Z', expected: true },
				])(
					'dateTime:afterOrEquals("$left", "$right") === $expected',
					({ left, right, expected }) => {
						const result = executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: left,
										rightValue: right,
										operator: { operation: 'afterOrEquals', type: 'dateTime' },
									},
								],
							}),
						);
						expect(result).toBe(expected);
					},
				);

				it.each([
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:10:49.113Z', expected: true },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-11-15T17:12:49.113Z', expected: true },
					{ left: '2023-11-15T17:10:49.113Z', right: '2023-01-01T00:00:00.000Z', expected: false },
				])(
					'dateTime:beforeOrEquals("$left", "$right") === $expected',
					({ left, right, expected }) => {
						const result = executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: left,
										rightValue: right,
										operator: { operation: 'beforeOrEquals', type: 'dateTime' },
									},
								],
							}),
						);
						expect(result).toBe(expected);
					},
				);
			});

			describe('boolean', () => {
				it.each([
					{ left: true, expected: false },
					{ left: false, expected: false },
					{ left: null, expected: true },
				])('boolean:empty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'empty', type: 'boolean' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: true, expected: true },
					{ left: false, expected: true },
					{ left: null, expected: false },
				])('boolean:notEmpty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'notEmpty', type: 'boolean' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: true, expected: true },
					{ left: false, expected: false },
				])('boolean:true($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'true', type: 'boolean' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: true, expected: false },
					{ left: false, expected: true },
				])('boolean:false($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									operator: { operation: 'false', type: 'boolean' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: true, right: true, expected: true },
					{ left: false, right: false, expected: true },
					{ left: true, right: false, expected: false },
				])('boolean:equals($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'equals', type: 'boolean' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: true, right: true, expected: false },
					{ left: false, right: false, expected: false },
					{ left: true, right: false, expected: true },
				])('boolean:notEquals($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'notEquals', type: 'boolean' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});
			});

			describe('array', () => {
				it.each([
					{ left: ['foo', 'bar'], right: 'foo', expected: true },
					{ left: ['foo', 'bar'], right: 'ba', expected: false },
				] as Tests)('array:contains($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'contains', type: 'array', rightType: 'any' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: ['foo', 'bar'], right: 'foo', expected: false },
					{ left: ['foo', 'bar'], right: 'ba', expected: true },
				] as Tests)(
					'array:notContains($left,$right) === $expected',
					({ left, right, expected }) => {
						const result = executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: left,
										rightValue: right,
										operator: { operation: 'notContains', type: 'array', rightType: 'any' },
									},
								],
							}),
						);
						expect(result).toBe(expected);
					},
				);

				it.each([
					{ left: ['foo', 'bar'], right: 2, expected: true },
					{ left: [], right: 0, expected: true },
					{ left: ['foo', 'bar'], right: 1, expected: false },
				] as Tests)(
					'array:lengthEquals($left,$right) === $expected',
					({ left, right, expected }) => {
						const result = executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: left,
										rightValue: right,
										operator: { operation: 'lengthEquals', type: 'array', rightType: 'number' },
									},
								],
							}),
						);
						expect(result).toBe(expected);
					},
				);

				it.each([
					{ left: ['foo', 'bar'], right: 2, expected: false },
					{ left: [], right: 0, expected: false },
					{ left: ['foo', 'bar'], right: 1, expected: true },
				] as Tests)(
					'array:lengthNotEquals($left,$right) === $expected',
					({ left, right, expected }) => {
						const result = executeFilter(
							filterFactory({
								conditions: [
									{
										id: '1',
										leftValue: left,
										rightValue: right,
										operator: { operation: 'lengthNotEquals', type: 'array', rightType: 'number' },
									},
								],
							}),
						);
						expect(result).toBe(expected);
					},
				);

				it.each([
					{ left: ['foo', 'bar'], right: 2, expected: false },
					{ left: [], right: 0, expected: false },
					{ left: ['foo', 'bar'], right: 1, expected: true },
				] as Tests)('array:lengthGt($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'lengthGt', type: 'array', rightType: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: ['foo', 'bar'], right: 2, expected: false },
					{ left: [], right: 0, expected: false },
					{ left: ['foo', 'bar'], right: 1, expected: false },
					{ left: ['foo', 'bar'], right: 3, expected: true },
				] as Tests)('array:lengthLt($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'lengthLt', type: 'array', rightType: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: ['foo', 'bar'], right: 2, expected: true },
					{ left: [], right: 0, expected: true },
					{ left: ['foo', 'bar'], right: 1, expected: true },
					{ left: ['foo', 'bar'], right: 3, expected: false },
				] as Tests)('array:lengthGte($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'lengthGte', type: 'array', rightType: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: ['foo', 'bar'], right: 2, expected: true },
					{ left: [], right: 0, expected: true },
					{ left: ['foo', 'bar'], right: 1, expected: false },
					{ left: ['foo', 'bar'], right: 3, expected: true },
				] as Tests)('array:lengthLte($left,$right) === $expected', ({ left, right, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left,
									rightValue: right,
									operator: { operation: 'lengthLte', type: 'array', rightType: 'number' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});
			});

			describe('object', () => {
				it.each([
					{ left: {}, expected: true },
					{ left: { foo: 'bar' }, expected: false },
					{ left: undefined, expected: true },
					{ left: null, expected: true },
				])('object:empty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left as string,
									operator: { operation: 'empty', type: 'object' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});

				it.each([
					{ left: {}, expected: false },
					{ left: { foo: 'bar' }, expected: true },
					{ left: undefined, expected: false },
					{ left: null, expected: false },
				])('object:notEmpty($left) === $expected', ({ left, expected }) => {
					const result = executeFilter(
						filterFactory({
							conditions: [
								{
									id: '1',
									leftValue: left as string,
									operator: { operation: 'notEmpty', type: 'object' },
								},
							],
						}),
					);
					expect(result).toBe(expected);
				});
			});

			describe('arrayContainsValue', () => {
				test('should return true if the array contains the value', () => {
					expect(arrayContainsValue([1, 2, 3], 2, false)).toBe(true);
				});

				test('should return false if the array does not contain the value', () => {
					expect(arrayContainsValue([1, 2, 3], 4, false)).toBe(false);
				});

				test('should return true if the array contains the string value and ignoreCase is true', () => {
					expect(arrayContainsValue(['a', 'b', 'c'], 'A', true)).toBe(true);
				});

				test('should return false if the array contains the string value but ignoreCase is false', () => {
					expect(arrayContainsValue(['a', 'b', 'c'], 'A', false)).toBe(false);
				});

				test('should return false if the array does not contain the string value and ignoreCase is true', () => {
					expect(arrayContainsValue(['a', 'b', 'c'], 'd', true)).toBe(false);
				});

				test('should handle non-string values correctly when ignoreCase is true', () => {
					expect(arrayContainsValue([1, 2, 3], 2, true)).toBe(true);
					expect(arrayContainsValue([1, 2, 3], '2', true)).toBe(false);
				});

				test('should handle mixed types in the array correctly', () => {
					expect(arrayContainsValue(['a', 2, 'c'], 'A', true)).toBe(true);
					expect(arrayContainsValue(['a', 2, 'c'], 2, false)).toBe(true);
					expect(arrayContainsValue(['a', 2, 'c'], '2', false)).toBe(false);
				});
			});
		});
	});
});



================================================
FILE: packages/workflow/test/from-ai-parse-utils.test.ts
================================================
import {
	extractFromAICalls,
	traverseNodeParameters,
	type FromAIArgument,
	generateZodSchema,
} from '../src/from-ai-parse-utils';

// Note that for historic reasons a lot of testing of this file happens indirectly in `packages/core/test/CreateNodeAsTool.test.ts`

describe('extractFromAICalls', () => {
	test.each<[string, [unknown, unknown, unknown, unknown]]>([
		['$fromAI("a", "b", "string")', ['a', 'b', 'string', undefined]],
		['$fromAI("a", "b", "number", 5)', ['a', 'b', 'number', 5]],
		['$fromAI("a", "`", "number", 5)', ['a', '`', 'number', 5]],
		['$fromAI("a", "\\`", "number", 5)', ['a', '`', 'number', 5]], // this is a bit surprising, but intended
		['$fromAI("a", "\\n", "number", 5)', ['a', 'n', 'number', 5]], // this is a bit surprising, but intended
		['{{ $fromAI("a", "b", "boolean") }}', ['a', 'b', 'boolean', undefined]],
	])('should parse args as expected for %s', (formula, [key, description, type, defaultValue]) => {
		expect(extractFromAICalls(formula)).toEqual([
			{
				key,
				description,
				type,
				defaultValue,
			},
		]);
	});

	test.each([
		['$fromAI("a", "b", "c")'],
		['$fromAI("a", "b", "string"'],
		['$fromAI("a", "b", "string, "d")'],
	])('should throw as expected for %s', (formula) => {
		expect(() => extractFromAICalls(formula)).toThrowError();
	});

	it('supports multiple calls', () => {
		const code = '$fromAI("a", "b", "number"); $fromAI("c", "d", "string")';

		expect(extractFromAICalls(code)).toEqual([
			{
				key: 'a',
				description: 'b',
				type: 'number',
				defaultValue: undefined,
			},
			{
				key: 'c',
				description: 'd',
				type: 'string',
				defaultValue: undefined,
			},
		]);
	});

	it('supports no calls', () => {
		const code = 'fromAI("a", "b", "number")';

		expect(extractFromAICalls(code)).toEqual([]);
	});
});

describe('traverseNodeParameters', () => {
	test.each<[string | string[] | Record<string, string>, [unknown, unknown, unknown, unknown]]>([
		['$fromAI("a", "b", "string")', ['a', 'b', 'string', undefined]],
		['$fromAI("a", "b", "number", 5)', ['a', 'b', 'number', 5]],
		['{{ $fromAI("a", "b", "boolean") }}', ['a', 'b', 'boolean', undefined]],
		[{ a: '{{ $fromAI("a", "b", "boolean") }}', b: 'five' }, ['a', 'b', 'boolean', undefined]],
		[
			['red', '{{ $fromAI("a", "b", "boolean") }}'],
			['a', 'b', 'boolean', undefined],
		],
	])(
		'should parse args as expected for %s',
		(parameters, [key, description, type, defaultValue]) => {
			const out: FromAIArgument[] = [];
			traverseNodeParameters(parameters, out);
			expect(out).toEqual([
				{
					key,
					description,
					type,
					defaultValue,
				},
			]);
		},
	);
});

describe('JSON Type Parsing via generateZodSchema', () => {
	it('should correctly parse a JSON parameter without default', () => {
		// Use an actual $fromAI call string via extractFromAICalls:
		const [arg] = extractFromAICalls(
			'$fromAI("jsonWithoutDefault", "JSON parameter without default", "json")',
		);
		const schema = generateZodSchema(arg);

		// Valid non-empty JSON objects should pass.
		expect(() => schema.parse({ key: 'value' })).not.toThrow();
		expect(schema.parse({ key: 'value' })).toEqual({ key: 'value' });

		// Parsing an empty object should throw a validation error.
		expect(() => schema.parse({})).toThrowError(
			/Value must be a non-empty object or a non-empty array/,
		);
	});

	it('should correctly parse a JSON parameter with a valid default', () => {
		const [arg] = extractFromAICalls(
			'$fromAI("jsonWithValidDefault", "JSON parameter with valid default", "json", "{"key": "defaultValue"}")',
		);
		const schema = generateZodSchema(arg);

		// The default value is now stored as a parsed object.
		expect(schema._def.defaultValue()).toEqual({ key: 'defaultValue' });
	});

	it('should parse a JSON parameter with an empty default', () => {
		const [arg] = extractFromAICalls(
			'$fromAI("jsonEmptyDefault", "JSON parameter with empty default", "json", "{}")',
		);
		const schema = generateZodSchema(arg);

		// The default value is stored as an empty object.
		expect(schema._def.defaultValue()).toEqual({});

		// Parsing an empty object should throw a validation error.
		expect(() => schema.parse({})).toThrowError(
			/Value must be a non-empty object or a non-empty array/,
		);
	});

	it('should use provided JSON value over the default value', () => {
		const [arg] = extractFromAICalls(
			'$fromAI("jsonParamCustom", "JSON parameter with custom default", "json", "{"initial": "value"}")',
		);
		const schema = generateZodSchema(arg);

		// Check that the stored default value parses to the expected object.
		expect(schema._def.defaultValue()).toEqual({ initial: 'value' });

		// When a new valid value is provided, the schema should use it.
		const newValue = { newKey: 'newValue' };
		expect(schema.parse(newValue)).toEqual(newValue);
	});
});



================================================
FILE: packages/workflow/test/helpers.ts
================================================
import { readFileSync } from 'fs';
import path from 'path';

import { NodeTypes as NodeTypesClass } from './node-types';
import type { INodeTypes } from '../src/interfaces';

let nodeTypesInstance: NodeTypesClass | undefined;

export function NodeTypes(): INodeTypes {
	if (nodeTypesInstance === undefined) {
		nodeTypesInstance = new NodeTypesClass();
	}
	return nodeTypesInstance;
}

const BASE_DIR = path.resolve(__dirname, '..');
export const readJsonFileSync = <T>(filePath: string) =>
	JSON.parse(readFileSync(path.join(BASE_DIR, filePath), 'utf-8')) as T;



================================================
FILE: packages/workflow/test/metadata-utils.test.ts
================================================
import { parseErrorMetadata } from '../src/metadata-utils';

describe('MetadataUtils', () => {
	describe('parseMetadataFromError', () => {
		const expectedMetadata = {
			subExecution: {
				executionId: '123',
				workflowId: '456',
			},
			subExecutionsCount: 1,
		};

		it('should return undefined if error does not have response or both keys on the object', () => {
			const error = { message: 'An error occurred' };
			const result = parseErrorMetadata(error);
			expect(result).toBeUndefined();
		});

		it('should return undefined if errorResponse only has workflowId key', () => {
			const error = { errorResponse: { executionId: '123' } };
			const result = parseErrorMetadata(error);
			expect(result).toBeUndefined();
		});

		it('should return undefined if error only has executionId key', () => {
			const error = { executionId: '123' };
			const result = parseErrorMetadata(error);
			expect(result).toBeUndefined();
		});

		it('should support executionId and workflowId key directly on the error object', () => {
			const error = { executionId: '123', workflowId: '456' };
			const result = parseErrorMetadata(error);
			expect(result).toEqual(expectedMetadata);
		});

		it('should return undefined if error response does not have subworkflow data', () => {
			const error = { errorResponse: { someKey: 'someValue' } };
			const result = parseErrorMetadata(error);
			expect(result).toBeUndefined();
		});

		it('should return metadata if error response has subworkflow data', () => {
			const error = { errorResponse: { executionId: '123', workflowId: '456' } };
			const result = parseErrorMetadata(error);
			expect(result).toEqual(expectedMetadata);
		});
	});
});



================================================
FILE: packages/workflow/test/node-errors.test.ts
================================================
import { UNKNOWN_ERROR_DESCRIPTION, UNKNOWN_ERROR_MESSAGE } from '../src/constants';
import { NodeOperationError } from '../src/errors';
import { NodeApiError } from '../src/errors/node-api.error';
import type { INode, JsonObject } from '../src/interfaces';

const node: INode = {
	id: '1',
	name: 'Postgres node',
	typeVersion: 2,
	type: 'n8n-nodes-base.postgres',
	position: [60, 760],
	parameters: {
		operation: 'executeQuery',
	},
};

describe('NodeErrors tests', () => {
	it('should return unknown error message', () => {
		const nodeApiError = new NodeApiError(node, {});

		expect(nodeApiError.message).toEqual(UNKNOWN_ERROR_MESSAGE);
	});

	it('should return the error message', () => {
		const nodeApiError = new NodeApiError(node, { message: 'test error message' });

		expect(nodeApiError.message).toEqual('test error message');
	});

	it('should return the error message defined in reason', () => {
		const nodeApiError = new NodeApiError(node, { reason: { message: 'test error message' } });

		expect(nodeApiError.message).toEqual('test error message');
	});

	it('should return the error message defined in options', () => {
		const nodeApiError = new NodeApiError(node, {}, { message: 'test error message' });

		expect(nodeApiError.message).toEqual('test error message');
	});

	it('should return description error message', () => {
		const nodeApiError = new NodeApiError(node, { description: 'test error description' });

		expect(nodeApiError.message).toEqual('test error description');
	});

	it('should return description as error message defined in reason', () => {
		const nodeApiError = new NodeApiError(node, {
			reason: { description: 'test error description' },
		});

		expect(nodeApiError.message).toEqual('test error description');
	});

	it('should return description as error message defined in options', () => {
		const nodeApiError = new NodeApiError(node, {}, { description: 'test error description' });

		expect(nodeApiError.message).toEqual('test error description');
	});

	it('should return default message for ECONNREFUSED', () => {
		const nodeApiError = new NodeApiError(node, {
			message: 'ECONNREFUSED',
		});

		expect(nodeApiError.message).toEqual(
			'The service refused the connection - perhaps it is offline',
		);
	});

	it('should return default message for 502', () => {
		const nodeApiError = new NodeApiError(node, {
			message: '502 Bad Gateway',
		});

		expect(nodeApiError.message).toEqual('Bad gateway - the service failed to handle your request');
	});

	it('should return default message for ENOTFOUND, NodeOperationError', () => {
		const nodeOperationError = new NodeOperationError(node, 'ENOTFOUND test error message');

		expect(nodeOperationError.message).toEqual(
			'The connection cannot be established, this usually occurs due to an incorrect host (domain) value',
		);
	});

	it('should return default message for ENOTFOUND, NodeApiError', () => {
		const nodeApiError = new NodeApiError(node, { message: 'ENOTFOUND test error message' });

		expect(nodeApiError.message).toEqual(
			'The connection cannot be established, this usually occurs due to an incorrect host (domain) value',
		);
	});

	it('should return default message for EEXIST based on code, NodeApiError', () => {
		const nodeApiError = new NodeApiError(node, {
			message: 'test error message',
			code: 'EEXIST',
		});

		expect(nodeApiError.message).toEqual('The file or directory already exists');
	});

	it('should update description GETADDRINFO, NodeOperationError', () => {
		const nodeOperationError = new NodeOperationError(node, 'GETADDRINFO test error message', {
			description: 'test error description',
		});

		expect(nodeOperationError.message).toEqual('The server closed the connection unexpectedly');

		//description should not include error message
		expect(nodeOperationError.description).toEqual('test error description');
	});

	it('should remove description if it is equal to message, NodeOperationError', () => {
		const nodeOperationError = new NodeOperationError(node, 'some text', {
			description: 'some text',
		});

		expect(nodeOperationError.message).toEqual('some text');

		expect(nodeOperationError.description).toEqual(undefined);
	});

	it('should remove description if it is equal to message, message provided in options take precedence over original, NodeApiError', () => {
		const nodeApiError = new NodeApiError(
			node,
			{
				message: 'original message',
			},
			{ message: 'new text', description: 'new text' },
		);

		expect(nodeApiError.message).toEqual('new text');

		expect(nodeApiError.description).toEqual(undefined);
	});

	it('should return mapped message for MYMAPPEDMESSAGE, NodeOperationError', () => {
		const nodeOperationError = new NodeOperationError(node, 'MYMAPPEDMESSAGE test error message', {
			messageMapping: {
				MYMAPPEDMESSAGE: 'test error message',
			},
		});

		expect(nodeOperationError.message).toEqual('test error message');
	});

	it('should return mapped message for MYMAPPEDMESSAGE, NodeApiError', () => {
		const nodeApiError = new NodeApiError(
			node,
			{ message: 'MYMAPPEDMESSAGE test error message' },
			{
				messageMapping: {
					MYMAPPEDMESSAGE: 'test error message',
				},
			},
		);

		expect(nodeApiError.message).toEqual('test error message');
	});

	it('should return default message for EACCES, custom mapping not found, NodeOperationError', () => {
		const nodeOperationError = new NodeOperationError(node, 'EACCES test error message', {
			messageMapping: {
				MYMAPPEDMESSAGE: 'test error message',
			},
		});

		expect(nodeOperationError.message).toEqual(
			'Forbidden by access permissions, make sure you have the right permissions',
		);
	});
});

describe('NodeApiError message and description logic', () => {
	it('case: customMessage && customDescription, result: message === customMessage; description === customDescription', () => {
		const apiError = { message: 'Original message', code: 404 };
		const nodeApiError = new NodeApiError(node, apiError, {
			message: 'Custom message',
			description: 'Custom description',
		});

		expect(nodeApiError.message).toEqual('Custom message');
		expect(nodeApiError.description).toEqual('Custom description');
		expect(nodeApiError.messages).toContain('Original message');
	});

	it('case: customMessage && !customDescription && extractedMessage, result: message === customMessage; description === extractedMessage', () => {
		const apiError = {
			message: 'Original message',
			code: 404,
			response: { data: { error: { message: 'Extracted message' } } },
		};
		const nodeApiError = new NodeApiError(node, apiError, {
			message: 'Custom message',
		});

		expect(nodeApiError.message).toEqual('Custom message');
		expect(nodeApiError.description).toEqual('Extracted message');
		expect(nodeApiError.messages).toContain('Original message');
	});

	it('case: customMessage && !customDescription && !extractedMessage, result: message === customMessage; !description', () => {
		const apiError = {
			message: '',
			code: 404,
			response: { data: { error: { foo: 'Extracted message' } } },
		};
		const nodeApiError = new NodeApiError(node, apiError, {
			message: 'Custom message',
		});

		expect(nodeApiError.message).toEqual('Custom message');
		expect(nodeApiError.description).toBeFalsy();
		expect(nodeApiError.messages.length).toBe(0);
	});

	it('case: !customMessage && httpCodeMapping && extractedMessage, result: message === httpCodeMapping; description === extractedMessage', () => {
		const apiError = {
			message: 'Original message',
			code: 404,
			response: { data: { error: { message: 'Extracted message' } } },
		};
		const nodeApiError = new NodeApiError(node, apiError);

		expect(nodeApiError.message).toEqual('The resource you are requesting could not be found');
		expect(nodeApiError.description).toEqual('Extracted message');
		expect(nodeApiError.messages).toContain('Original message');
	});

	it('case: !customMessage && httpCodeMapping && !extractedMessage, result: message === httpCodeMapping; !description', () => {
		const apiError = {
			message: '',
			code: 500,
		};
		const nodeApiError = new NodeApiError(node, apiError);

		expect(nodeApiError.message).toEqual('The service was not able to process your request');
		expect(nodeApiError.description).toBeFalsy();
	});

	it('case: !customMessage && !httpCodeMapping && extractedMessage, result: message === extractedMessage; !description', () => {
		const apiError = {
			message: '',
			code: 300,
			response: { data: { error: { message: 'Extracted message' } } },
		};
		const nodeApiError = new NodeApiError(node, apiError);

		expect(nodeApiError.message).toEqual('Extracted message');
		expect(nodeApiError.description).toBeFalsy();
	});

	it('case: !customMessage && !httpCodeMapping && !extractedMessage, result: message === UNKNOWN_ERROR_MESSAGE; description === UNKNOWN_ERROR_DESCRIPTION', () => {
		const apiError = {};
		const nodeApiError = new NodeApiError(node, apiError);

		expect(nodeApiError.message).toEqual(UNKNOWN_ERROR_MESSAGE);
		expect(nodeApiError.description).toEqual(UNKNOWN_ERROR_DESCRIPTION);
	});

	it('case: Error code sent as "any"', () => {
		const error = {
			code: 400,
			message: "Invalid value 'test' for viewId parameter.",
			status: 'INVALID_ARGUMENT',
		};
		const [message, ...rest] = error.message.split('\n');
		const description = rest.join('\n');
		const httpCode = error.code as any;
		const nodeApiError = new NodeApiError(node, error as JsonObject, {
			message,
			description,
			httpCode,
		});

		expect(nodeApiError.message).toEqual(error.message);
	});
});



================================================
FILE: packages/workflow/test/node-helpers.conditions.test.ts
================================================
import type { INodeParameters, INodeProperties } from '../src/interfaces';
import { getNodeParameters } from '../src/node-helpers';

describe('NodeHelpers', () => {
	describe('getNodeParameters, displayOptions set using DisplayCondition', () => {
		const tests: Array<{
			description: string;
			input: {
				nodePropertiesArray: INodeProperties[];
				nodeValues: INodeParameters | null;
			};
			output: {
				noneDisplayedFalse: {
					defaultsFalse: INodeParameters;
					defaultsTrue: INodeParameters;
				};
				noneDisplayedTrue: {
					defaultsFalse: INodeParameters;
					defaultsTrue: INodeParameters;
				};
			};
		}> = [
			{
				description: 'simple values with displayOptions "show" number (gt). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'number1',
							displayName: 'number1',
							type: 'number',
							default: 2,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									number1: [{ _cnd: { gt: 1 } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" number (lt). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'number1',
							displayName: 'number1',
							type: 'number',
							default: 2,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									number1: [{ _cnd: { lt: 3 } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" number (between). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'number1',
							displayName: 'number1',
							type: 'number',
							default: 2,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									number1: [{ _cnd: { between: { from: 1, to: 3 } } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" number (lte). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'number1',
							displayName: 'number1',
							type: 'number',
							default: 2,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									number1: [{ _cnd: { lte: 3 } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" number (gte). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'number1',
							displayName: 'number1',
							type: 'number',
							default: 2,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									number1: [{ _cnd: { gte: 1 } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							number1: 2,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) which is boolean. All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'boolean1',
							displayName: 'boolean1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									boolean1: [{ _cnd: { eq: true } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						boolean1: true,
						string1: 'own string1',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
							string1: 'own string1',
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'own string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
							string1: 'own string1',
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'own string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "hide" (match) which is boolean. All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'boolean1',
							displayName: 'boolean1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								hide: {
									boolean1: [{ _cnd: { eq: true } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						boolean1: true,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) which is boolean. One values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'boolean1',
							displayName: 'boolean1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									boolean1: [{ _cnd: { eq: true } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						boolean1: true,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (match). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: [{ _cnd: { includes: 'mode1' } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) on two which depend on each other of which is boolean. One value should be displayed. One values set (none-default).',
				input: {
					nodePropertiesArray: [
						{
							name: 'string1',
							displayName: 'string1',
							type: 'string',
							default: 'default string1',
						},
						{
							name: 'boolean1',
							displayName: 'boolean1',
							displayOptions: {
								show: {
									string1: [{ _cnd: { eq: 'default string1' } }],
								},
							},
							type: 'boolean',
							default: false,
						},
						{
							name: 'string2',
							displayName: 'string2',
							displayOptions: {
								show: {
									boolean1: [{ _cnd: { not: false } }],
								},
							},
							type: 'string',
							default: 'default string2',
						},
					],
					nodeValues: {
						boolean1: true,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: true,
							string2: 'default string2',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: true,
							string2: 'default string2',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) on two which depend on each other of which is boolean. One value should be displayed. One values set. (default)',
				input: {
					nodePropertiesArray: [
						{
							name: 'string1',
							displayName: 'string1',
							type: 'string',
							default: 'default string1',
						},
						{
							name: 'boolean1',
							displayName: 'boolean1',
							displayOptions: {
								show: {
									string1: [{ _cnd: { endsWith: 'string1' } }],
								},
							},
							type: 'boolean',
							default: false,
						},
						{
							name: 'string2',
							displayName: 'string2',
							displayOptions: {
								show: {
									boolean1: [{ _cnd: { eq: true } }],
								},
							},
							type: 'string',
							default: 'default string2',
						},
					],
					nodeValues: {
						boolean1: false,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: false,
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: false,
							string2: 'default string2',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (match). All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: [{ _cnd: { startsWith: 'mo' } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						mode: 'mode1',
						string1: 'default string1',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (no-match). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: [{ _cnd: { endsWith: '2' } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (no-match). All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: [{ _cnd: { startsWith: 'foo' } }],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						mode: 'mode1',
						string1: 'default string1',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},

			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (match) on option. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'mode',
											displayName: 'mode',
											type: 'string',
											default: 'mode1',
										},
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													mode: [{ _cnd: { endsWith: 'mode1' } }],
												},
											},
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								number1: 1,
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode1',
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode1',
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													'/mode': [{ _cnd: { eq: 'mode1' } }],
												},
											},
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								string1: 'own string1',
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									string1: 'own string1',
								},
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									string1: 'own string1',
									number1: 0,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									string1: 'own string1',
								},
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									string1: 'own string1',
									number1: 0,
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (no-match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													'/mode': [{ _cnd: { includes: 'de2' } }],
												},
											},
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								string1: 'own string1',
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									number1: 0,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									string1: 'own string1',
								},
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									string1: 'own string1',
									number1: 0,
								},
							},
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: false" and with displayOptions "show" (match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': [{ _cnd: { eq: 'mode1' } }],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: {
							string1: 'own string1',
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								string1: 'own string1',
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								string1: 'own string1',
							},
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: false" and with displayOptions "show" (no-match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': [{ _cnd: { eq: 'mode2' } }],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: {
							string1: 'own string1',
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							// TODO: Write some code which cleans up data like that
							values: {},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								string1: 'own string1',
							},
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: true" and with displayOptions "show" (match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': [{ _cnd: { eq: 'mode1' } }],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: [
							{
								string1: 'own string1',
							},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
								},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
								},
							],
						},
					},
				},
			},

			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: true" and with displayOptions "show" (no-match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': [{ _cnd: { eq: 'mode2' } }],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: [
							{
								string1: 'own string1',
								number1: 0,
							},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (no-match) on option. One value set also the not displayed one.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'mode',
											displayName: 'mode',
											type: 'string',
											default: 'mode1',
										},
										{
											displayName: 'string1',
											name: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													mode: [{ _cnd: { eq: 'mode1' } }],
												},
											},
											default: 'default string1',
										},
										{
											displayName: 'number1',
											name: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								mode: 'mode2',
								string1: 'default string1',
								number1: 1,
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									mode: 'mode2',
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode2',
									number1: 1,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									mode: 'mode2',
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode2',
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
				},
			},

			{
				description:
					'two identically named properties of which only one gets displayed with different options. No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { endsWith: '1' } }],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { endsWith: '2' } }],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
						},
					},
				},
			},
			{
				description:
					'One property which is dependency on two identically named properties of which only one gets displayed with different options. No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option1' } }],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option2' } }],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value1',
							required: true,
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option1' } }],
									subOption: [{ _cnd: { includes: '1a' } }],
								},
							},
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value2',
							required: true,
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option2' } }],
									subOption: [{ _cnd: { includes: '2a' } }],
								},
							},
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
				},
			},
			{
				description:
					'One property which is dependency on two identically named properties of which only one gets displayed with different options. No value set at all. Order reversed',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value2',
							required: true,
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option2' } }],
									subOption: [{ _cnd: { includes: '2a' } }],
								},
							},
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option2' } }],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option1' } }],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value1',
							required: true,
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option1' } }],
									subOption: [{ _cnd: { eq: 'option1a' } }],
								},
							},
						},
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
				},
			},
			{
				description:
					'One property which is dependency on two identically named properties of which only one gets displayed with different options. No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option1' } }],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option2' } }],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value1',
							required: true,
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option1' } }],
									subOption: [{ _cnd: { eq: 'option1a' } }],
								},
							},
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value2',
							required: true,
							displayOptions: {
								show: {
									mainOption: [{ _cnd: { eq: 'option2' } }],
									subOption: [{ _cnd: { eq: 'option2a' } }],
								},
							},
						},
					],
					nodeValues: {
						mainOption: 'option2',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							mainOption: 'option2',
						},
						defaultsTrue: {
							mainOption: 'option2',
							subOption: 'option2a',
							dependentParameter: 'value2',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							mainOption: 'option2',
						},
						defaultsTrue: {
							mainOption: 'option2',
							subOption: 'option2a',
							dependentParameter: 'value2',
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: true". Which contains parameters which get displayed on a parameter with a default expression with relative parameter references.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values1',
							name: 'values1',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							description: 'The value to set.',
							default: {},
							options: [
								{
									displayName: 'Options1',
									name: 'options1',
									values: [
										{
											displayName: 'Key',
											name: 'key',
											type: 'string',
											default: '',
										},
										{
											displayName: 'Type',
											name: 'type',
											type: 'hidden',
											default: '={{$parameter["&key"].split("|")[1]}}',
										},
										{
											displayName: 'Title Value',
											name: 'titleValue',
											displayOptions: {
												show: {
													type: [{ _cnd: { eq: 'title' } }],
												},
											},
											type: 'string',
											default: 'defaultTitle',
										},
										{
											displayName: 'Title Number',
											name: 'numberValue',
											displayOptions: {
												show: {
													type: [{ _cnd: { eq: 'number' } }],
												},
											},
											type: 'number',
											default: 1,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values1: {
							options1: [
								{
									key: 'asdf|title',
									titleValue: 'different',
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										titleValue: 'different',
									},
								],
							},
						},
						defaultsTrue: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										type: '={{$parameter["&key"].split("|")[1]}}',
										// This is not great that it displays this theoretically hidden parameter
										// but because we can not resolve the values for now
										numberValue: 1,
										titleValue: 'different',
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										titleValue: 'different',
									},
								],
							},
						},
						defaultsTrue: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										type: '={{$parameter["&key"].split("|")[1]}}',
										titleValue: 'different',
										numberValue: 1,
									},
								],
							},
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" using exists condition. No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'field1',
							displayName: 'Field 1',
							type: 'string',
							default: '',
						},
						{
							name: 'field2',
							displayName: 'Field 2',
							displayOptions: {
								show: {
									field1: [{ _cnd: { exists: true } }],
								},
							},
							type: 'string',
							default: 'default field2',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							field1: '',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							field1: '',
							field2: 'default field2',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" using exists condition. Field1 has a value.',
				input: {
					nodePropertiesArray: [
						{
							name: 'field1',
							displayName: 'Field 1',
							type: 'string',
							default: '',
						},
						{
							name: 'field2',
							displayName: 'Field 2',
							displayOptions: {
								show: {
									field1: [{ _cnd: { exists: true } }],
								},
							},
							type: 'string',
							default: 'default field2',
						},
					],
					nodeValues: {
						field1: 'some value',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							field1: 'some value',
						},
						defaultsTrue: {
							field1: 'some value',
							field2: 'default field2',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							field1: 'some value',
						},
						defaultsTrue: {
							field1: 'some value',
							field2: 'default field2',
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" using exists condition.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'data',
									displayName: 'Data',
									values: [
										{
											name: 'field1',
											displayName: 'Field 1',
											type: 'string',
											default: '',
										},
										{
											name: 'field2',
											displayName: 'Field 2',
											type: 'string',
											displayOptions: {
												show: {
													field1: [{ _cnd: { exists: true } }],
												},
											},
											default: 'default field2',
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							data: {
								field1: 'some value',
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								data: {
									field1: 'some value',
								},
							},
						},
						defaultsTrue: {
							values: {
								data: {
									field1: 'some value',
									field2: 'default field2',
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								data: {
									field1: 'some value',
								},
							},
						},
						defaultsTrue: {
							values: {
								data: {
									field1: 'some value',
									field2: 'default field2',
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" with "multipleValues: true" and with displayOptions "show" using exists condition.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'field1',
									displayName: 'Field 1',
									type: 'string',
									default: '',
								},
								{
									name: 'field2',
									displayName: 'Field 2',
									type: 'string',
									displayOptions: {
										show: {
											field1: [{ _cnd: { exists: true } }],
										},
									},
									default: 'default field2',
								},
							],
						},
					],
					nodeValues: {
						values: [
							{
								field1: 'value1',
							},
							{
								field1: '',
							},
							{},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: [
								{
									field1: 'value1',
								},
								{
									field1: '',
								},
								{},
							],
						},
						defaultsTrue: {
							values: [
								{
									field1: 'value1',
								},
								{
									field1: '',
								},
								{},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: [
								{
									field1: 'value1',
								},
								{
									field1: '',
								},
								{},
							],
						},
						defaultsTrue: {
							values: [
								{
									field1: 'value1',
								},
								{
									field1: '',
								},
								{},
							],
						},
					},
				},
			},
		];

		for (const testData of tests) {
			test(testData.description, () => {
				// returnDefaults: false | returnNoneDisplayed: false
				let result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					false,
					false,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedFalse.defaultsFalse);

				// returnDefaults: true | returnNoneDisplayed: false
				result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					true,
					false,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedFalse.defaultsTrue);

				// returnDefaults: false | returnNoneDisplayed: true
				result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					false,
					true,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedTrue.defaultsFalse);

				// returnDefaults: true | returnNoneDisplayed: true
				result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					true,
					true,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedTrue.defaultsTrue);
			});
		}
	});
});



================================================
FILE: packages/workflow/test/node-helpers.test.ts
================================================
import {
	NodeConnectionTypes,
	type INodeType,
	type NodeConnectionType,
	type INodeIssues,
	type INode,
	type INodeParameters,
	type INodeProperties,
	type INodeTypeDescription,
} from '../src/interfaces';
import {
	getNodeParameters,
	isSubNodeType,
	getParameterIssues,
	isTriggerNode,
	isExecutable,
	displayParameter,
	makeDescription,
	getUpdatedToolDescription,
	getToolDescriptionForNode,
	isDefaultNodeName,
	makeNodeName,
	isTool,
	getNodeWebhookPath,
} from '../src/node-helpers';
import type { Workflow } from '../src/workflow';
import { mock } from 'vitest-mock-extended';

describe('NodeHelpers', () => {
	describe('getNodeParameters', () => {
		const tests: Array<{
			description: string;
			input: {
				nodePropertiesArray: INodeProperties[];
				nodeValues: INodeParameters | null;
			};
			output: {
				noneDisplayedFalse: {
					defaultsFalse: INodeParameters;
					defaultsTrue: INodeParameters;
				};
				noneDisplayedTrue: {
					defaultsFalse: INodeParameters;
					defaultsTrue: INodeParameters;
				};
			};
		}> = [
			{
				description: 'simple values.',
				input: {
					nodePropertiesArray: [
						{
							name: 'string1',
							displayName: 'String 1',
							type: 'string',
							default: '',
						},
						{
							name: 'string2',
							displayName: 'String 2',
							type: 'string',
							default: 'default string 2',
						},
						{
							name: 'string3',
							displayName: 'String 3',
							type: 'string',
							default: 'default string 3',
						},
						{
							name: 'number1',
							displayName: 'Number 1',
							type: 'number',
							default: 10,
						},
						{
							name: 'number2',
							displayName: 'Number 2',
							type: 'number',
							default: 10,
						},
						{
							name: 'number3',
							displayName: 'Number 3',
							type: 'number',
							default: 10,
						},
						{
							name: 'boolean1',
							displayName: 'Boolean 1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'boolean2',
							displayName: 'Boolean 2',
							type: 'boolean',
							default: false,
						},
						{
							name: 'boolean3',
							displayName: 'Boolean 3',
							type: 'boolean',
							default: true,
						},
						{
							name: 'boolean4',
							displayName: 'Boolean 4',
							type: 'boolean',
							default: true,
						},
						{
							name: 'boolean5',
							displayName: 'Boolean 5',
							type: 'boolean',
							default: false,
						},
						{
							name: 'boolean6',
							displayName: 'Boolean 6',
							type: 'boolean',
							default: true,
						},
					],
					nodeValues: {
						boolean1: true,
						boolean3: false,
						boolean5: false,
						boolean6: true,
						string1: 'different',
						number1: 1,
						number3: 0,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
							boolean3: false,
							string1: 'different',
							number1: 1,
							number3: 0,
						},
						defaultsTrue: {
							boolean1: true,
							boolean2: false,
							boolean3: false,
							boolean4: true,
							boolean5: false,
							boolean6: true,
							string1: 'different',
							string2: 'default string 2',
							string3: 'default string 3',
							number1: 1,
							number2: 10,
							number3: 0,
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
							boolean3: false,
							string1: 'different',
							number1: 1,
							number3: 0,
						},
						defaultsTrue: {
							boolean1: true,
							boolean2: false,
							boolean3: false,
							boolean4: true,
							boolean5: false,
							boolean6: true,
							string1: 'different',
							string2: 'default string 2',
							string3: 'default string 3',
							number1: 1,
							number2: 10,
							number3: 0,
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) which is boolean. All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'boolean1',
							displayName: 'boolean1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									boolean1: [true],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						boolean1: true,
						string1: 'own string1',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
							string1: 'own string1',
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'own string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
							string1: 'own string1',
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'own string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "hide" (match) which is boolean. All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'boolean1',
							displayName: 'boolean1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								hide: {
									boolean1: [true],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						boolean1: true,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) which is boolean. One values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'boolean1',
							displayName: 'boolean1',
							type: 'boolean',
							default: false,
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									boolean1: [true],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						boolean1: true,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							boolean1: true,
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (match). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: ['mode1'],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) on two which depend on each other of which is boolean. One value should be displayed. One values set (none-default).',
				input: {
					nodePropertiesArray: [
						{
							name: 'string1',
							displayName: 'string1',
							type: 'string',
							default: 'default string1',
						},
						{
							name: 'boolean1',
							displayName: 'boolean1',
							displayOptions: {
								show: {
									string1: ['default string1'],
								},
							},
							type: 'boolean',
							default: false,
						},
						{
							name: 'string2',
							displayName: 'string2',
							displayOptions: {
								show: {
									boolean1: [true],
								},
							},
							type: 'string',
							default: 'default string2',
						},
					],
					nodeValues: {
						boolean1: true,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: true,
							string2: 'default string2',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							boolean1: true,
						},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: true,
							string2: 'default string2',
						},
					},
				},
			},
			{
				description:
					'simple values with displayOptions "show" (match) on two which depend on each other of which is boolean. One value should be displayed. One values set. (default)',
				input: {
					nodePropertiesArray: [
						{
							name: 'string1',
							displayName: 'string1',
							type: 'string',
							default: 'default string1',
						},
						{
							name: 'boolean1',
							displayName: 'boolean1',
							displayOptions: {
								show: {
									string1: ['default string1'],
								},
							},
							type: 'boolean',
							default: false,
						},
						{
							name: 'string2',
							displayName: 'string2',
							displayOptions: {
								show: {
									boolean1: [true],
								},
							},
							type: 'string',
							default: 'default string2',
						},
					],
					nodeValues: {
						boolean1: false,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: false,
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							string1: 'default string1',
							boolean1: false,
							string2: 'default string2',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (match). All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: ['mode1'],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						mode: 'mode1',
						string1: 'default string1',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (no-match). No values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: ['mode2'],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'simple values with displayOptions "show" (no-match). All values set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'string1',
							displayName: 'string1',
							displayOptions: {
								show: {
									mode: ['mode2'],
								},
							},
							type: 'string',
							default: 'default string1',
						},
					],
					nodeValues: {
						mode: 'mode1',
						string1: 'default string1',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							string1: 'default string1',
						},
					},
				},
			},
			{
				description: 'complex type "fixedCollection" with "multipleValues: true". One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'boolean',
									displayName: 'Boolean',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											name: 'boolean1',
											displayName: 'boolean1',
											type: 'boolean',
											default: false,
										},
									],
								},
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											displayName: 'number1',
											name: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: [
								{
									number1: 1,
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: [
									{
										number1: 1,
									},
								],
							},
						},
						defaultsTrue: {
							values: {
								number: [
									{
										string1: 'default string1',
										number1: 1,
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: [
									{
										number1: 1,
									},
								],
							},
						},
						defaultsTrue: {
							values: {
								number: [
									{
										string1: 'default string1',
										number1: 1,
									},
								],
							},
						},
					},
				},
			},
			{
				description: 'complex type "fixedCollection" with "multipleValues: false". One value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values',
							name: 'values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'boolean',
									displayName: 'Boolean',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											name: 'boolean1',
											displayName: 'boolean1',
											type: 'boolean',
											default: false,
										},
									],
								},
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											displayName: 'number1',
											name: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
								{
									name: 'singleString',
									displayName: 'Single String',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default singleString1',
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								number1: 1,
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false". Two values set one single one.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values',
							name: 'values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'boolean',
									displayName: 'Boolean',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											name: 'boolean1',
											displayName: 'boolean1',
											type: 'boolean',
											default: false,
										},
									],
								},
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											displayName: 'number1',
											name: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
								{
									name: 'singleString',
									displayName: 'Single String',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default singleString1',
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								number1: 1,
							},
							singleString: {
								string1: 'value1',
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
								singleString: {
									string1: 'value1',
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									string1: 'default string1',
									number1: 1,
								},
								singleString: {
									string1: 'value1',
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
								singleString: {
									string1: 'value1',
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									string1: 'default string1',
									number1: 1,
								},
								singleString: {
									string1: 'value1',
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: true" and complex type "collection"  with "multipleValues: true". One value set each.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values',
							name: 'values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							description: 'The value to set.',
							default: {},
							options: [
								{
									name: 'boolean',
									displayName: 'Boolean',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											name: 'boolean1',
											displayName: 'boolean1',
											type: 'boolean',
											default: false,
										},
									],
								},
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
										{
											name: 'collection1',
											displayName: 'collection1',
											type: 'collection',
											typeOptions: {
												multipleValues: true,
											},
											default: {},
											options: [
												{
													name: 'string1',
													displayName: 'string1',
													type: 'string',
													default: 'default string1',
												},
												{
													name: 'string2',
													displayName: 'string2',
													type: 'string',
													default: 'default string2',
												},
											],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: [
								{
									number1: 1,
									collection1: [
										{
											string1: 'value1',
										},
									],
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: [
									{
										number1: 1,
										collection1: [
											{
												string1: 'value1',
											},
										],
									},
								],
							},
						},
						defaultsTrue: {
							values: {
								number: [
									{
										string1: 'default string1',
										number1: 1,
										collection1: [
											{
												string1: 'value1',
											},
										],
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: [
									{
										number1: 1,
										collection1: [
											{
												string1: 'value1',
											},
										],
									},
								],
							},
						},
						defaultsTrue: {
							values: {
								number: [
									{
										string1: 'default string1',
										number1: 1,
										collection1: [
											{
												string1: 'value1',
											},
										],
									},
								],
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (match) on option. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'mode',
											displayName: 'mode',
											type: 'string',
											default: 'mode1',
										},
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													mode: ['mode1'],
												},
											},
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								number1: 1,
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode1',
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode1',
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													'/mode': ['mode1'],
												},
											},
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								string1: 'own string1',
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									string1: 'own string1',
								},
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									string1: 'own string1',
									number1: 0,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									string1: 'own string1',
								},
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									string1: 'own string1',
									number1: 0,
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (no-match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'string1',
											displayName: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													'/mode': ['mode2'],
												},
											},
											default: 'default string1',
										},
										{
											name: 'number1',
											displayName: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								string1: 'own string1',
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									number1: 0,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									string1: 'own string1',
								},
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								number: {
									string1: 'own string1',
									number1: 0,
								},
							},
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: false" and with displayOptions "show" (match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': ['mode1'],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: {
							string1: 'own string1',
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								string1: 'own string1',
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								string1: 'own string1',
							},
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: false" and with displayOptions "show" (no-match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': ['mode2'],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: {
							string1: 'own string1',
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							// TODO: Write some code which cleans up data like that
							values: {},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							mode: 'mode1',
							values: {
								string1: 'own string1',
							},
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: true" and with displayOptions "show" (match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': ['mode1'],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: [
							{
								string1: 'own string1',
							},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
								},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
								},
							],
						},
					},
				},
			},

			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: true" and with displayOptions "show" (no-match) on option which references root-value. One value set.',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							name: 'values',
							displayName: 'Values',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'string1',
									displayName: 'string1',
									type: 'string',
									displayOptions: {
										show: {
											'/mode': ['mode2'],
										},
									},
									default: 'default string1',
								},
								{
									name: 'number1',
									displayName: 'number1',
									type: 'number',
									default: 0,
								},
							],
						},
					],
					nodeValues: {
						values: [
							{
								string1: 'own string1',
								number1: 0,
							},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
						defaultsTrue: {
							mode: 'mode1',
							values: [
								{
									string1: 'own string1',
									number1: 0,
								},
							],
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: false" and with displayOptions "show" (no-match) on option. One value set also the not displayed one.',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							default: {},
							options: [
								{
									name: 'number',
									displayName: 'Number',
									values: [
										{
											name: 'mode',
											displayName: 'mode',
											type: 'string',
											default: 'mode1',
										},
										{
											displayName: 'string1',
											name: 'string1',
											type: 'string',
											displayOptions: {
												show: {
													mode: ['mode1'],
												},
											},
											default: 'default string1',
										},
										{
											displayName: 'number1',
											name: 'number1',
											type: 'number',
											default: 0,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							number: {
								mode: 'mode2',
								string1: 'default string1',
								number1: 1,
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								number: {
									mode: 'mode2',
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode2',
									number1: 1,
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								number: {
									mode: 'mode2',
									number1: 1,
								},
							},
						},
						defaultsTrue: {
							values: {
								number: {
									mode: 'mode2',
									string1: 'default string1',
									number1: 1,
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" with "multipleValues: true". One none-default value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {
						collection1: [
							{
								string1: 'value1',
							},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							collection1: [
								{
									string1: 'value1',
								},
							],
						},
						defaultsTrue: {
							collection1: [
								{
									string1: 'value1',
								},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							collection1: [
								{
									string1: 'value1',
								},
							],
						},
						defaultsTrue: {
							collection1: [
								{
									string1: 'value1',
								},
							],
						},
					},
				},
			},
			// Remember it is correct that default strings get returned here even when returnDefaults
			// is set to false because if they would not, there would be no way to know which value
			// got added and which one not.
			{
				description:
					'complex type "collection" with "multipleValues: true". One default value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {
						collection1: [
							{
								string1: 'default string1',
							},
						],
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							collection1: [
								{
									string1: 'default string1',
								},
							],
						},
						defaultsTrue: {
							collection1: [
								{
									string1: 'default string1',
								},
							],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							collection1: [
								{
									string1: 'default string1',
								},
							],
						},
						defaultsTrue: {
							collection1: [
								{
									string1: 'default string1',
								},
							],
						},
					},
				},
			},
			{
				description:
					'complex type "collection" with "multipleValues: false". One none-default value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {
						collection1: {
							string1: 'own string1',
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							collection1: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							collection1: {
								string1: 'own string1',
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							collection1: {
								string1: 'own string1',
							},
						},
						defaultsTrue: {
							collection1: {
								string1: 'own string1',
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" with "multipleValues: false". One default value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {
						collection1: {
							string1: 'default string1',
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							collection1: {
								string1: 'default string1',
							},
						},
						defaultsTrue: {
							collection1: {
								string1: 'default string1',
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							collection1: {
								string1: 'default string1',
							},
						},
						defaultsTrue: {
							collection1: {
								string1: 'default string1',
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" with "multipleValues: false". Only outer value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {
						collection1: {},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							collection1: {},
						},
						defaultsTrue: {
							collection1: {},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							collection1: {},
						},
						defaultsTrue: {
							collection1: {},
						},
					},
				},
			},
			{
				description: 'complex type "collection" with "multipleValues: false". No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							collection1: {},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							collection1: {},
						},
					},
				},
			},
			{
				description: 'complex type "collection" with "multipleValues: true". No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'collection1',
							name: 'collection1',
							type: 'collection',
							typeOptions: {
								multipleValues: true,
							},
							default: [],
							options: [
								{
									displayName: 'string1',
									name: 'string1',
									type: 'string',
									default: 'default string1',
								},
								{
									displayName: 'string2',
									name: 'string2',
									type: 'string',
									default: 'default string2',
								},
							],
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							collection1: [],
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							collection1: [],
						},
					},
				},
			},
			{
				description:
					'two identically named properties of which only one gets displayed with different options. No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option1'],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option2'],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
						},
					},
				},
			},
			{
				description:
					'One property which is dependency on two identically named properties of which only one gets displayed with different options. No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option1'],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option2'],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value1',
							required: true,
							displayOptions: {
								show: {
									mainOption: ['option1'],
									subOption: ['option1a'],
								},
							},
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value2',
							required: true,
							displayOptions: {
								show: {
									mainOption: ['option2'],
									subOption: ['option2a'],
								},
							},
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
				},
			},
			{
				description:
					'One property which is dependency on two identically named properties of which only one gets displayed with different options. No value set at all. Order reversed',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value2',
							required: true,
							displayOptions: {
								show: {
									mainOption: ['option2'],
									subOption: ['option2a'],
								},
							},
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option2'],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option1'],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value1',
							required: true,
							displayOptions: {
								show: {
									mainOption: ['option1'],
									subOption: ['option1a'],
								},
							},
						},
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
					],
					nodeValues: {},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							mainOption: 'option1',
							subOption: 'option1a',
							dependentParameter: 'value1',
						},
					},
				},
			},
			{
				description:
					'One property which is dependency on two identically named properties of which only one gets displayed with different options. No value set at all.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'mainOption',
							name: 'mainOption',
							type: 'options',
							options: [
								{
									name: 'option1',
									value: 'option1',
								},
								{
									name: 'option2',
									value: 'option2',
								},
							],
							default: 'option1',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option1'],
								},
							},
							options: [
								{
									name: 'option1a',
									value: 'option1a',
								},
								{
									name: 'option1b',
									value: 'option1b',
								},
							],
							default: 'option1a',
						},
						{
							displayName: 'subOption',
							name: 'subOption',
							type: 'options',
							displayOptions: {
								show: {
									mainOption: ['option2'],
								},
							},
							options: [
								{
									name: 'option2a',
									value: 'option2a',
								},
								{
									name: 'option2b',
									value: 'option2b',
								},
							],
							default: 'option2a',
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value1',
							required: true,
							displayOptions: {
								show: {
									mainOption: ['option1'],
									subOption: ['option1a'],
								},
							},
						},
						{
							displayName: 'dependentParameter',
							name: 'dependentParameter',
							type: 'string',
							default: 'value2',
							required: true,
							displayOptions: {
								show: {
									mainOption: ['option2'],
									subOption: ['option2a'],
								},
							},
						},
					],
					nodeValues: {
						mainOption: 'option2',
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							mainOption: 'option2',
						},
						defaultsTrue: {
							mainOption: 'option2',
							subOption: 'option2a',
							dependentParameter: 'value2',
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							mainOption: 'option2',
						},
						defaultsTrue: {
							mainOption: 'option2',
							subOption: 'option2a',
							dependentParameter: 'value2',
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: true". Which contains complex type "fixedCollection" with "multipleValues: true". One value set.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values1',
							name: 'values1',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							description: 'The value to set.',
							default: {},
							options: [
								{
									displayName: 'Options1',
									name: 'options1',
									values: [
										{
											displayName: 'Values2',
											name: 'values2',
											type: 'fixedCollection',
											typeOptions: {
												multipleValues: true,
											},
											description: 'The value to set.',
											default: {},
											options: [
												{
													displayName: 'Options2',
													name: 'options2',
													values: [
														{
															name: 'string1',
															displayName: 'string1',
															type: 'string',
															default: 'default string1',
														},
														{
															name: 'number1',
															displayName: 'number1',
															type: 'number',
															default: 0,
														},
													],
												},
											],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values1: {
							options1: [
								{
									values2: {
										options2: [
											{
												number1: 1,
											},
										],
									},
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values1: {
								options1: [
									{
										values2: {
											options2: [
												{
													number1: 1,
												},
											],
										},
									},
								],
							},
						},
						defaultsTrue: {
							values1: {
								options1: [
									{
										values2: {
											options2: [
												{
													string1: 'default string1',
													number1: 1,
												},
											],
										},
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values1: {
								options1: [
									{
										values2: {
											options2: [
												{
													number1: 1,
												},
											],
										},
									},
								],
							},
						},
						defaultsTrue: {
							values1: {
								options1: [
									{
										values2: {
											options2: [
												{
													string1: 'default string1',
													number1: 1,
												},
											],
										},
									},
								],
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: true". Which contains parameters which get displayed on a parameter with a default expression with relative parameter references.',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values1',
							name: 'values1',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							description: 'The value to set.',
							default: {},
							options: [
								{
									displayName: 'Options1',
									name: 'options1',
									values: [
										{
											displayName: 'Key',
											name: 'key',
											type: 'string',
											default: '',
										},
										{
											displayName: 'Type',
											name: 'type',
											type: 'hidden',
											default: '={{$parameter["&key"].split("|")[1]}}',
										},
										{
											displayName: 'Title Value',
											name: 'titleValue',
											displayOptions: {
												show: {
													type: ['title'],
												},
											},
											type: 'string',
											default: 'defaultTitle',
										},
										{
											displayName: 'Title Number',
											name: 'numberValue',
											displayOptions: {
												show: {
													type: ['number'],
												},
											},
											type: 'number',
											default: 1,
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values1: {
							options1: [
								{
									key: 'asdf|title',
									titleValue: 'different',
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										titleValue: 'different',
									},
								],
							},
						},
						defaultsTrue: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										type: '={{$parameter["&key"].split("|")[1]}}',
										// This is not great that it displays this theoretically hidden parameter
										// but because we can not resolve the values for now
										numberValue: 1,
										titleValue: 'different',
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										titleValue: 'different',
									},
								],
							},
						},
						defaultsTrue: {
							values1: {
								options1: [
									{
										key: 'asdf|title',
										type: '={{$parameter["&key"].split("|")[1]}}',
										titleValue: 'different',
										numberValue: 1,
									},
								],
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: true". Which contains parameter of type "multiOptions" and has so an array default value',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'propertyValues',
									displayName: 'Property',
									values: [
										{
											displayName: 'Options',
											name: 'multiSelectValue',
											type: 'multiOptions',
											options: [
												{
													name: 'Value1',
													value: 'value1',
												},
												{
													name: 'Value2',
													value: 'value2',
												},
											],
											default: [],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							propertyValues: [
								{
									multiSelectValue: [],
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								propertyValues: [{}],
							},
						},
						defaultsTrue: {
							values: {
								propertyValues: [
									{
										multiSelectValue: [],
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								propertyValues: [{}],
							},
						},
						defaultsTrue: {
							values: {
								propertyValues: [
									{
										multiSelectValue: [],
									},
								],
							},
						},
					},
				},
			},
			{
				description:
					'complex type "fixedCollection" with "multipleValues: true". Which contains parameter of type "string" with "multipleValues: true" and a custom default value',
				input: {
					nodePropertiesArray: [
						{
							name: 'values',
							displayName: 'Values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'propertyValues',
									displayName: 'Property',
									values: [
										{
											displayName: 'MultiString',
											name: 'multiString',
											type: 'string',
											typeOptions: {
												multipleValues: true,
											},
											default: ['value1'],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						values: {
							propertyValues: [
								{
									multiString: ['value1'],
								},
							],
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							values: {
								propertyValues: [{}],
							},
						},
						defaultsTrue: {
							values: {
								propertyValues: [
									{
										multiString: ['value1'],
									},
								],
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							values: {
								propertyValues: [{}],
							},
						},
						defaultsTrue: {
							values: {
								propertyValues: [
									{
										multiString: ['value1'],
									},
								],
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" which contains a "fixedCollection" with "multipleValues: false" that has all values set to the default values (by having it as an empty object) in combination with another value',
				input: {
					nodePropertiesArray: [
						{
							name: 'mode',
							displayName: 'mode',
							type: 'string',
							default: 'mode1',
						},
						{
							displayName: 'Options',
							name: 'options',
							placeholder: 'Add Option',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'Sort',
									name: 'sort',
									type: 'fixedCollection',
									typeOptions: {
										multipleValues: false,
									},
									default: {},
									placeholder: 'Add Sort',
									options: [
										{
											displayName: 'Sort',
											name: 'value',
											values: [
												{
													displayName: 'Descending',
													name: 'descending',
													type: 'boolean',
													default: true,
													description: 'Sort by descending order',
												},
												{
													displayName: 'Order By',
													name: 'ordering',
													type: 'options',
													default: 'date',
													options: [
														{
															name: 'Date',
															value: 'date',
														},
														{
															name: 'Name',
															value: 'name',
														},
													],
												},
											],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						mode: 'changed',
						options: {
							sort: {
								value: {},
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							mode: 'changed',
							options: {
								sort: {
									value: {},
								},
							},
						},
						defaultsTrue: {
							mode: 'changed',
							options: {
								sort: {
									value: {
										descending: true,
										ordering: 'date',
									},
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							mode: 'changed',
							options: {
								sort: {
									value: {},
								},
							},
						},
						defaultsTrue: {
							mode: 'changed',
							options: {
								sort: {
									value: {
										descending: true,
										ordering: 'date',
									},
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" which contains a "fixedCollection" with "multipleValues: false" that has all values set to the default values (by having it as an empty object)',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Options',
							name: 'options',
							placeholder: 'Add Option',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'Sort',
									name: 'sort',
									type: 'fixedCollection',
									typeOptions: {
										multipleValues: false,
									},
									default: {},
									placeholder: 'Add Sort',
									options: [
										{
											displayName: 'Sort',
											name: 'value',
											values: [
												{
													displayName: 'Descending',
													name: 'descending',
													type: 'boolean',
													default: true,
													description: 'Sort by descending order',
												},
												{
													displayName: 'Order By',
													name: 'ordering',
													type: 'options',
													default: 'date',
													options: [
														{
															name: 'Date',
															value: 'date',
														},
														{
															name: 'Name',
															value: 'name',
														},
													],
												},
											],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						options: {
							sort: {
								value: {},
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							options: {
								sort: {
									value: {},
								},
							},
						},
						defaultsTrue: {
							options: {
								sort: {
									value: {
										descending: true,
										ordering: 'date',
									},
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							options: {
								sort: {
									value: {},
								},
							},
						},
						defaultsTrue: {
							options: {
								sort: {
									value: {
										descending: true,
										ordering: 'date',
									},
								},
							},
						},
					},
				},
			},
			{
				description:
					'complex type "collection" which contains a "fixedCollection" with "multipleValues: false" that has all values set to the default values (by having each value set)',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Options',
							name: 'options',
							placeholder: 'Add Option',
							type: 'collection',
							default: {},
							options: [
								{
									displayName: 'Sort',
									name: 'sort',
									type: 'fixedCollection',
									typeOptions: {
										multipleValues: false,
									},
									default: {},
									options: [
										{
											displayName: 'Sort',
											name: 'value',
											values: [
												{
													displayName: 'Descending',
													name: 'descending',
													type: 'boolean',
													default: true,
												},
												{
													displayName: 'Order By',
													name: 'ordering',
													type: 'options',
													default: 'date',
													options: [
														{
															name: 'Date',
															value: 'date',
														},
														{
															name: 'Name',
															value: 'name',
														},
													],
												},
											],
										},
									],
								},
							],
						},
					],
					nodeValues: {
						options: {
							sort: {
								value: {
									descending: true,
									ordering: 'date',
								},
							},
						},
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {
							options: {
								sort: {
									value: {},
								},
							},
						},
						defaultsTrue: {
							options: {
								sort: {
									value: {
										descending: true,
										ordering: 'date',
									},
								},
							},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {
							options: {
								sort: {
									value: {},
								},
							},
						},
						defaultsTrue: {
							options: {
								sort: {
									value: {
										descending: true,
										ordering: 'date',
									},
								},
							},
						},
					},
				},
			},
			{
				description: 'nodeValues is null (for example when resolving expression fails)',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Custom Properties',
							name: 'customPropertiesUi',
							placeholder: 'Add Custom Property',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'customPropertiesValues',
									displayName: 'Custom Property',
									values: [
										{
											displayName: 'Property Name or ID',
											name: 'property',
											type: 'options',
											typeOptions: {
												loadOptionsMethod: 'getDealCustomProperties',
											},
											default: '',
											description:
												'Name of the property. Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>.',
										},
										{
											displayName: 'Value',
											name: 'value',
											type: 'string',
											default: '',
											required: true,
											description: 'Value of the property',
										},
									],
								},
							],
						},
					],
					nodeValues: null,
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {},
					},
				},
			},
			{
				description:
					'fixedCollection with multipleValues: true - skip when propertyValues is not an object or is an array',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values',
							name: 'values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'option1',
									displayName: 'Option 1',
									values: [
										{
											displayName: 'String',
											name: 'string1',
											type: 'string',
											default: 'default string',
										},
									],
								},
							],
						},
					],
					nodeValues: {
						// This simulates when propertyValues is incorrectly set as an array instead of an object
						values: [] as any,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							values: {},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							values: {},
						},
					},
				},
			},
			{
				description:
					'fixedCollection with multipleValues: true - skip when propertyValues is a string',
				input: {
					nodePropertiesArray: [
						{
							displayName: 'Values',
							name: 'values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'option1',
									displayName: 'Option 1',
									values: [
										{
											displayName: 'String',
											name: 'string1',
											type: 'string',
											default: 'default string',
										},
									],
								},
							],
						},
					],
					nodeValues: {
						// This simulates when propertyValues is incorrectly set as a string
						values: 'invalid value' as any,
					},
				},
				output: {
					noneDisplayedFalse: {
						defaultsFalse: {},
						defaultsTrue: {
							values: {},
						},
					},
					noneDisplayedTrue: {
						defaultsFalse: {},
						defaultsTrue: {
							values: {},
						},
					},
				},
			},
		];

		for (const testData of tests) {
			test(testData.description, () => {
				// returnDefaults: false | returnNoneDisplayed: false
				let result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					false,
					false,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedFalse.defaultsFalse);

				// returnDefaults: true | returnNoneDisplayed: false
				result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					true,
					false,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedFalse.defaultsTrue);

				// returnDefaults: false | returnNoneDisplayed: true
				result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					false,
					true,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedTrue.defaultsFalse);

				// returnDefaults: true | returnNoneDisplayed: true
				result = getNodeParameters(
					testData.input.nodePropertiesArray,
					testData.input.nodeValues,
					true,
					true,
					null,
					null,
				);
				expect(result).toEqual(testData.output.noneDisplayedTrue.defaultsTrue);
			});
		}
	});

	describe('isSubNodeType', () => {
		const tests: Array<[boolean, Pick<INodeTypeDescription, 'outputs'> | null]> = [
			[false, null],
			[false, { outputs: '={{random_expression}}' }],
			[false, { outputs: [] }],
			[false, { outputs: [NodeConnectionTypes.Main] }],
			[true, { outputs: [NodeConnectionTypes.AiAgent] }],
			[true, { outputs: [NodeConnectionTypes.Main, NodeConnectionTypes.AiAgent] }],
		];
		test.each(tests)('should return %p for %o', (expected, nodeType) => {
			expect(isSubNodeType(nodeType)).toBe(expected);
		});
	});

	describe('getParameterIssues', () => {
		const tests: Array<{
			description: string;
			input: {
				nodeProperties: INodeProperties;
				nodeValues: INodeParameters;
				path: string;
				node: INode;
			};
			output: INodeIssues;
		}> = [
			{
				description:
					'Fixed collection::Should not return issues if minimum or maximum field count is not set',
				input: {
					nodeProperties: {
						displayName: 'Workflow Inputs',
						name: 'workflowInputs',
						placeholder: 'Add Field',
						type: 'fixedCollection',
						description:
							'Define expected input fields. If no inputs are provided, all data from the calling workflow will be passed through.',
						typeOptions: {
							multipleValues: true,
							sortable: true,
						},
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 1.1,
										},
									},
								],
								inputSource: ['workflowInputs'],
							},
						},
						default: {},
						options: [
							{
								name: 'values',
								displayName: 'Values',
								values: [
									{
										displayName: 'Name',
										name: 'name',
										type: 'string',
										default: '',
										placeholder: 'e.g. fieldName',
										description: 'Name of the field',
										noDataExpression: true,
									},
									{
										displayName: 'Type',
										name: 'type',
										type: 'options',
										description: 'The field value type',
										options: [
											{
												name: 'Allow Any Type',
												value: 'any',
											},
											{
												name: 'String',
												value: 'string',
											},
											{
												name: 'Number',
												value: 'number',
											},
											{
												name: 'Boolean',
												value: 'boolean',
											},
											{
												name: 'Array',
												value: 'array',
											},
											{
												name: 'Object',
												value: 'object',
											},
										],
										default: 'string',
										noDataExpression: true,
									},
								],
							},
						],
					},
					nodeValues: {
						events: 'worklfow_call',
						inputSource: 'workflowInputs',
						workflowInputs: {},
						inputOptions: {},
					},
					path: '',
					node: {
						parameters: {
							events: 'worklfow_call',
							inputSource: 'workflowInputs',
							workflowInputs: {},
							inputOptions: {},
						},
						type: 'n8n-nodes-base.executeWorkflowTrigger',
						typeVersion: 1.1,
						position: [-140, -20],
						id: '9abdbdac-5f32-4876-b4d5-895d8ca4cb00',
						name: 'Test Node',
					} as INode,
				},
				output: {},
			},
			{
				description:
					'Fixed collection::Should not return issues if field count is within the specified range',
				input: {
					nodeProperties: {
						displayName: 'Workflow Inputs',
						name: 'workflowInputs',
						placeholder: 'Add Field',
						type: 'fixedCollection',
						description:
							'Define expected input fields. If no inputs are provided, all data from the calling workflow will be passed through.',
						typeOptions: {
							multipleValues: true,
							sortable: true,
							minRequiredFields: 1,
							maxAllowedFields: 3,
						},
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 1.1,
										},
									},
								],
								inputSource: ['workflowInputs'],
							},
						},
						default: {},
						options: [
							{
								name: 'values',
								displayName: 'Values',
								values: [
									{
										displayName: 'Name',
										name: 'name',
										type: 'string',
										default: '',
										placeholder: 'e.g. fieldName',
										description: 'Name of the field',
										noDataExpression: true,
									},
									{
										displayName: 'Type',
										name: 'type',
										type: 'options',
										description: 'The field value type',
										options: [
											{
												name: 'Allow Any Type',
												value: 'any',
											},
											{
												name: 'String',
												value: 'string',
											},
											{
												name: 'Number',
												value: 'number',
											},
											{
												name: 'Boolean',
												value: 'boolean',
											},
											{
												name: 'Array',
												value: 'array',
											},
											{
												name: 'Object',
												value: 'object',
											},
										],
										default: 'string',
										noDataExpression: true,
									},
								],
							},
						],
					},
					nodeValues: {
						events: 'worklfow_call',
						inputSource: 'workflowInputs',
						workflowInputs: {
							values: [
								{
									name: 'field1',
									type: 'string',
								},
								{
									name: 'field2',
									type: 'string',
								},
							],
						},
						inputOptions: {},
					},
					path: '',
					node: {
						parameters: {
							events: 'worklfow_call',
							inputSource: 'workflowInputs',
							workflowInputs: {},
							inputOptions: {},
						},
						type: 'n8n-nodes-base.executeWorkflowTrigger',
						typeVersion: 1.1,
						position: [-140, -20],
						id: '9abdbdac-5f32-4876-b4d5-895d8ca4cb00',
						name: 'Test Node',
					} as INode,
				},
				output: {},
			},
			{
				description:
					'Fixed collection::Should return an issue if field count is lower than minimum specified',
				input: {
					nodeProperties: {
						displayName: 'Workflow Inputs',
						name: 'workflowInputs',
						placeholder: 'Add Field',
						type: 'fixedCollection',
						description:
							'Define expected input fields. If no inputs are provided, all data from the calling workflow will be passed through.',
						typeOptions: {
							multipleValues: true,
							sortable: true,
							minRequiredFields: 1,
						},
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 1.1,
										},
									},
								],
								inputSource: ['workflowInputs'],
							},
						},
						default: {},
						options: [
							{
								name: 'values',
								displayName: 'Values',
								values: [
									{
										displayName: 'Name',
										name: 'name',
										type: 'string',
										default: '',
										placeholder: 'e.g. fieldName',
										description: 'Name of the field',
										noDataExpression: true,
									},
									{
										displayName: 'Type',
										name: 'type',
										type: 'options',
										description: 'The field value type',
										options: [
											{
												name: 'Allow Any Type',
												value: 'any',
											},
											{
												name: 'String',
												value: 'string',
											},
											{
												name: 'Number',
												value: 'number',
											},
											{
												name: 'Boolean',
												value: 'boolean',
											},
											{
												name: 'Array',
												value: 'array',
											},
											{
												name: 'Object',
												value: 'object',
											},
										],
										default: 'string',
										noDataExpression: true,
									},
								],
							},
						],
					},
					nodeValues: {
						events: 'worklfow_call',
						inputSource: 'workflowInputs',
						workflowInputs: {},
						inputOptions: {},
					},
					path: '',
					node: {
						parameters: {
							events: 'worklfow_call',
							inputSource: 'workflowInputs',
							workflowInputs: {},
							inputOptions: {},
						},
						type: 'n8n-nodes-base.executeWorkflowTrigger',
						typeVersion: 1.1,
						position: [-140, -20],
						id: '9abdbdac-5f32-4876-b4d5-895d8ca4cb00',
						name: 'Test Node',
					} as INode,
				},
				output: {
					parameters: {
						workflowInputs: ['At least 1 field is required.'],
					},
				},
			},
			{
				description:
					'Fixed collection::Should return an issue if field count is higher than maximum specified',
				input: {
					nodeProperties: {
						displayName: 'Workflow Inputs',
						name: 'workflowInputs',
						placeholder: 'Add Field',
						type: 'fixedCollection',
						description:
							'Define expected input fields. If no inputs are provided, all data from the calling workflow will be passed through.',
						typeOptions: {
							multipleValues: true,
							sortable: true,
							maxAllowedFields: 1,
						},
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 1.1,
										},
									},
								],
								inputSource: ['workflowInputs'],
							},
						},
						default: {},
						options: [
							{
								name: 'values',
								displayName: 'Values',
								values: [
									{
										displayName: 'Name',
										name: 'name',
										type: 'string',
										default: '',
										placeholder: 'e.g. fieldName',
										description: 'Name of the field',
										noDataExpression: true,
									},
									{
										displayName: 'Type',
										name: 'type',
										type: 'options',
										description: 'The field value type',
										options: [
											{
												name: 'Allow Any Type',
												value: 'any',
											},
											{
												name: 'String',
												value: 'string',
											},
											{
												name: 'Number',
												value: 'number',
											},
											{
												name: 'Boolean',
												value: 'boolean',
											},
											{
												name: 'Array',
												value: 'array',
											},
											{
												name: 'Object',
												value: 'object',
											},
										],
										default: 'string',
										noDataExpression: true,
									},
								],
							},
						],
					},
					nodeValues: {
						events: 'worklfow_call',
						inputSource: 'workflowInputs',
						workflowInputs: {
							values: [
								{
									name: 'field1',
									type: 'string',
								},
								{
									name: 'field2',
									type: 'string',
								},
							],
						},
						inputOptions: {},
					},
					path: '',
					node: {
						parameters: {
							events: 'worklfow_call',
							inputSource: 'workflowInputs',
							workflowInputs: {},
							inputOptions: {},
						},
						type: 'n8n-nodes-base.executeWorkflowTrigger',
						typeVersion: 1.1,
						position: [-140, -20],
						id: '9abdbdac-5f32-4876-b4d5-895d8ca4cb00',
						name: 'Test Node',
					} as INode,
				},
				output: {
					parameters: {
						workflowInputs: ['At most 1 field is allowed.'],
					},
				},
			},
			{
				description: 'Fixed collection::Should not return issues if the collection is hidden',
				input: {
					nodeProperties: {
						displayName: 'Workflow Inputs',
						name: 'workflowInputs',
						placeholder: 'Add Field',
						type: 'fixedCollection',
						description:
							'Define expected input fields. If no inputs are provided, all data from the calling workflow will be passed through.',
						typeOptions: {
							multipleValues: true,
							sortable: true,
							maxAllowedFields: 1,
						},
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 1.1,
										},
									},
								],
								inputSource: ['workflowInputs'],
							},
						},
						default: {},
						options: [
							{
								name: 'values',
								displayName: 'Values',
								values: [
									{
										displayName: 'Name',
										name: 'name',
										type: 'string',
										default: '',
										placeholder: 'e.g. fieldName',
										description: 'Name of the field',
										noDataExpression: true,
									},
									{
										displayName: 'Type',
										name: 'type',
										type: 'options',
										description: 'The field value type',
										options: [
											{
												name: 'Allow Any Type',
												value: 'any',
											},
											{
												name: 'String',
												value: 'string',
											},
											{
												name: 'Number',
												value: 'number',
											},
											{
												name: 'Boolean',
												value: 'boolean',
											},
											{
												name: 'Array',
												value: 'array',
											},
											{
												name: 'Object',
												value: 'object',
											},
										],
										default: 'string',
										noDataExpression: true,
									},
								],
							},
						],
					},
					nodeValues: {
						events: 'worklfow_call',
						inputSource: 'somethingElse',
						workflowInputs: {
							values: [
								{
									name: 'field1',
									type: 'string',
								},
								{
									name: 'field2',
									type: 'string',
								},
							],
						},
						inputOptions: {},
					},
					path: '',
					node: {
						parameters: {
							events: 'worklfow_call',
							inputSource: 'workflowInputs',
							workflowInputs: {},
							inputOptions: {},
						},
						type: 'n8n-nodes-base.executeWorkflowTrigger',
						typeVersion: 1.1,
						position: [-140, -20],
						id: '9abdbdac-5f32-4876-b4d5-895d8ca4cb00',
						name: 'Test Node',
					} as INode,
				},
				output: {},
			},
		];

		for (const testData of tests) {
			test(testData.description, () => {
				const result = getParameterIssues(
					testData.input.nodeProperties,
					testData.input.nodeValues,
					testData.input.path,
					testData.input.node,
					null,
				);
				expect(result).toEqual(testData.output);
			});
		}
	});

	describe('getParameterIssues, required parameters validation', () => {
		const testNode: INode = {
			id: '12345',
			name: 'Test Node',
			typeVersion: 1,
			type: 'n8n-nodes-base.testNode',
			position: [1, 1],
			parameters: {},
		};

		const testNodeType: INodeTypeDescription = {
			name: 'Test Node',
			version: 0,
			defaults: {},
			inputs: [],
			outputs: [],
			properties: [],
			displayName: '',
			group: [],
			description: '',
		};

		it('Should validate required dateTime parameters if empty string', () => {
			const nodeProperties: INodeProperties = {
				displayName: 'Date Time',
				name: 'testDateTime',
				type: 'dateTime',
				default: '',
				required: true,
			};
			const nodeValues: INodeParameters = {
				testDateTime: '',
			};

			const result = getParameterIssues(nodeProperties, nodeValues, '', testNode, null);

			expect(result).toEqual({
				parameters: {
					testDateTime: ['Parameter "Date Time" is required.'],
				},
			});
		});

		it('Should validate required dateTime parameters if empty undefined', () => {
			const nodeProperties: INodeProperties = {
				displayName: 'Date Time',
				name: 'testDateTime',
				type: 'dateTime',
				default: '',
				required: true,
			};
			const nodeValues: INodeParameters = {
				testDateTime: undefined,
			};

			const result = getParameterIssues(nodeProperties, nodeValues, '', testNode, testNodeType);

			expect(result).toEqual({
				parameters: {
					testDateTime: ['Parameter "Date Time" is required.'],
				},
			});
		});
	});

	describe('isTriggerNode', () => {
		const tests: Array<{
			description: string;
			input: INodeTypeDescription;
			expected: boolean;
		}> = [
			{
				description: 'Should return true for node with trigger in group',
				input: {
					name: 'TriggerNode',
					displayName: 'Trigger Node',
					group: ['trigger'],
					description: 'Trigger node description',
					version: 1,
					defaults: {},
					inputs: [],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: true,
			},
			{
				description: 'Should return true for node with multiple groups including trigger',
				input: {
					name: 'MultiGroupTriggerNode',
					displayName: 'Multi-Group Trigger Node',
					group: ['trigger', 'input'],
					description: 'Multi-group trigger node description',
					version: 1,
					defaults: {},
					inputs: [],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: true,
			},
			{
				description: 'Should return false for node without trigger in group',
				input: {
					name: 'RegularNode',
					displayName: 'Regular Node',
					group: ['input'],
					description: 'Regular node description',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: false,
			},
			{
				description: 'Should return false for node with empty group array',
				input: {
					name: 'EmptyGroupNode',
					displayName: 'Empty Group Node',
					group: [],
					description: 'Empty group node description',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: false,
			},
			{
				description:
					'Should return false when trigger is called Trigger, but does not have a trigger group',
				input: {
					name: 'AlmostTriggerNode',
					displayName: 'Almost Trigger Node',
					group: ['transform'],
					description: 'Almost trigger node description',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: false,
			},
		];

		for (const testData of tests) {
			test(testData.description, () => {
				const result = isTriggerNode(testData.input);
				expect(result).toEqual(testData.expected);
			});
		}
	});

	describe('isExecutable', () => {
		const workflowMock = {
			expression: {
				getSimpleParameterValue: vi.fn().mockReturnValue([NodeConnectionTypes.Main]),
			},
		} as unknown as Workflow;

		const tests: Array<{
			description: string;
			node: INode;
			nodeTypeData: INodeTypeDescription;
			expected: boolean;
			mockReturnValue?: NodeConnectionType[];
		}> = [
			{
				description: 'Should return true for trigger node',
				node: {
					id: 'triggerNodeId',
					name: 'TriggerNode',
					position: [0, 0],
					type: 'n8n-nodes-base.TriggerNode',
					typeVersion: 1,
					parameters: {},
				},
				nodeTypeData: {
					name: 'TriggerNode',
					displayName: 'Trigger Node',
					group: ['trigger'],
					description: 'Trigger node description',
					version: 1,
					defaults: {},
					inputs: [],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: true,
			},
			{
				description: 'Should return true for node with Main output',
				node: {
					id: 'mainOutputNodeId',
					name: 'MainOutputNode',
					position: [0, 0],
					type: 'n8n-nodes-base.MainOutputNode',
					typeVersion: 1,
					parameters: {},
				},
				nodeTypeData: {
					name: 'MainOutputNode',
					displayName: 'Main Output Node',
					group: ['transform'],
					description: 'Node with Main output',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main],
					properties: [],
				},
				expected: true,
			},
			{
				description: 'Should return false for node without Main output and not a trigger',
				node: {
					id: 'nonExecutableNodeId',
					name: 'NonExecutableNode',
					position: [0, 0],
					type: 'n8n-nodes-base.NonExecutableNode',
					typeVersion: 1,
					parameters: {},
				},
				nodeTypeData: {
					name: 'NonExecutableNode',
					displayName: 'Non-Executable Node',
					group: ['output'],
					description: 'Node without Main output and not a trigger',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.AiAgent],
					properties: [],
				},
				expected: false,
			},
			{
				description: 'Should return true for node with mixed outputs including Main',
				node: {
					id: 'mixedOutputNodeId',
					name: 'MixedOutputNode',
					position: [0, 0],
					type: 'n8n-nodes-base.MixedOutputNode',
					typeVersion: 1,
					parameters: {},
				},
				nodeTypeData: {
					name: 'MixedOutputNode',
					displayName: 'Mixed Output Node',
					group: ['transform'],
					description: 'Node with multiple output types including Main',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main, NodeConnectionTypes.AiAgent],
					properties: [],
				},
				expected: true,
			},
			{
				description: 'Should return true for node with only AiTool output and not a trigger',
				node: {
					id: 'aiToolOutputNodeId',
					name: 'AiToolOutputNode',
					position: [0, 0],
					type: 'n8n-nodes-base.AiToolOutputNode',
					typeVersion: 1,
					parameters: {},
				},
				nodeTypeData: {
					name: 'AiToolOutputNode',
					displayName: 'AI Tool Output Node',
					group: ['output'],
					description: 'Node with only AiTool output and not a trigger',
					version: 1,
					defaults: {},
					inputs: [],
					outputs: [NodeConnectionTypes.AiTool], // Only AiTool output, no Main
					properties: [],
				},
				expected: true,
			},
			{
				description: 'Should return true for node with dynamic outputs set to AiTool only',
				node: {
					id: 'dynamicAiToolNodeId',
					name: 'DynamicAiToolNode',
					position: [0, 0],
					type: 'n8n-nodes-base.DynamicAiToolNode',
					typeVersion: 1,
					parameters: {},
				},
				nodeTypeData: {
					name: 'DynamicAiToolNode',
					displayName: 'Dynamic AiTool Node',
					group: ['output'],
					description: 'Node with dynamic outputs that resolve to only AiTool',
					version: 1,
					defaults: {},
					inputs: [NodeConnectionTypes.Main],
					outputs: '={{["ai_tool"]}}', // Dynamic expression that resolves to AiTool only
					properties: [],
				},
				expected: true,
				mockReturnValue: [NodeConnectionTypes.AiTool],
			},
		];

		for (const testData of tests) {
			test(testData.description, () => {
				// If this test has a custom mock return value, configure it
				if (testData.mockReturnValue) {
					// eslint-disable-next-line @typescript-eslint/unbound-method
					vi.mocked(workflowMock.expression.getSimpleParameterValue).mockReturnValueOnce(
						testData.mockReturnValue,
					);
				}

				const result = isExecutable(workflowMock, testData.node, testData.nodeTypeData);
				expect(result).toEqual(testData.expected);
			});
		}
	});
	describe('displayParameter', () => {
		const testNode: INode = {
			id: '12345',
			name: 'Test Node',
			typeVersion: 1,
			type: 'n8n-nodes-base.testNode',
			position: [1, 1],
			parameters: {},
		};

		const testNodeType: INodeTypeDescription = {
			name: 'Test Node',
			version: 0,
			defaults: {},
			inputs: [],
			outputs: [],
			properties: [],
			displayName: '',
			group: [],
			description: '',
		};

		const defaultTestInput = {
			nodeValues: {},
			parameter: {
				displayName: 'Test Parameter',
				name: 'testParameter',
				type: 'string',
				default: '',
			} as INodeProperties,
			node: testNode,
			nodeTypeDescription: testNodeType,
			nodeValuesRoot: undefined as undefined | INodeParameters,
			displayKey: 'displayOptions' as 'displayOptions' | 'disabledOptions',
		};

		const tests: Array<[string, typeof defaultTestInput, boolean]> = [
			['Should return true if no displayOptions are defined', { ...defaultTestInput }, true],
			[
				'Should return true if displayOptions.show conditions are met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value1' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								condition: ['value1'],
							},
						},
					},
				},
				true,
			],
			[
				'Should return false if displayOptions.show conditions are not met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value2' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								condition: ['value1'],
							},
						},
					},
				},
				false,
			],
			[
				'Should return false if displayOptions.hide conditions are met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value1' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							hide: {
								condition: ['value1'],
							},
						},
					},
				},
				false,
			],
			[
				'Should return true if displayOptions.hide conditions are not met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value2' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							hide: {
								condition: ['value1'],
							},
						},
					},
				},
				true,
			],
			[
				'Should return true if displayOptions.show and hide conditions are both met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value1' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								condition: ['value1'],
							},
							hide: {
								condition: ['value1'],
							},
						},
					},
				},
				false, // Hide takes precedence over show
			],
			[
				'Should return true if displayOptions.show conditions are met with multiple values',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value2' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								condition: ['value1', 'value2'],
							},
						},
					},
				},
				true,
			],
			[
				'Should return false if displayOptions.hide conditions are met with multiple values',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value2' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							hide: {
								condition: ['value1', 'value2'],
							},
						},
					},
				},
				false,
			],
			[
				'Should return true if @tool is true in nodeTypeDescription of tool',
				{
					...defaultTestInput,
					nodeTypeDescription: {
						...testNodeType,
						name: testNodeType.name + 'Tool',
					},
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'@tool': [true],
							},
						},
					},
				},
				true,
			],
			[
				'Should return false if @tool is true in nodeTypeDescription of non-tool',
				{
					...defaultTestInput,
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'@tool': [true],
							},
						},
					},
				},
				false,
			],
			[
				'Should return true if @version condition is met',
				{
					...defaultTestInput,
					node: {
						...testNode,
						typeVersion: 2,
					},
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 2,
										},
									},
								],
							},
						},
					},
				},
				true,
			],
			[
				'Should return false if @version condition is not met',
				{
					...defaultTestInput,
					node: {
						...testNode,
						typeVersion: 1,
					},
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'@version': [
									{
										_cnd: {
											gte: 2,
										},
									},
								],
							},
						},
					},
				},
				false,
			],
			[
				'Should return true if @tool and @version conditions are both met',
				{
					...defaultTestInput,
					node: {
						...testNode,
						typeVersion: 2,
					},
					nodeTypeDescription: {
						...testNodeType,
						name: testNodeType.name + 'Tool',
					},
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'@tool': [true],
								'@version': [
									{
										_cnd: {
											gte: 2,
										},
									},
								],
							},
						},
					},
				},
				true,
			],
			[
				'Should return false if @tool is true but @version condition is not met',
				{
					...defaultTestInput,
					node: {
						...testNode,
						typeVersion: 1,
					},
					nodeTypeDescription: {
						...testNodeType,
						name: testNodeType.name + 'Tool',
					},
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'@tool': [true],
								'@version': [
									{
										_cnd: {
											gte: 2,
										},
									},
								],
							},
						},
					},
				},
				false,
			],
			[
				'Should return true if no disabledOptions are defined',
				{
					...defaultTestInput,
					displayKey: 'disabledOptions',
				},
				true,
			],
			[
				'Should return false if disabledOptions.hide conditions are met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value1' },
					parameter: {
						...defaultTestInput.parameter,
						disabledOptions: {
							hide: {
								condition: ['value1'],
							},
						},
					},
					displayKey: 'disabledOptions',
				},
				false,
			],
			[
				'Should return true if disabledOptions.hide conditions are not met',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value2' },
					parameter: {
						...defaultTestInput.parameter,
						disabledOptions: {
							hide: {
								condition: ['value1'],
							},
						},
					},
					displayKey: 'disabledOptions',
				},
				true,
			],
			[
				'Should return true if nodeValuesRoot contains a matching value for displayOptions.show',
				{
					...defaultTestInput,
					nodeValues: {},
					nodeValuesRoot: { condition: 'value1' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'/condition': ['value1'],
							},
						},
					},
				},
				true,
			],
			[
				'Should return false if nodeValuesRoot does not contain a matching value for displayOptions.show',
				{
					...defaultTestInput,
					nodeValues: { condition: 'value1' },
					nodeValuesRoot: { anotherKey: 'value1' },
					parameter: {
						...defaultTestInput.parameter,
						displayOptions: {
							show: {
								'/condition': ['value1'],
							},
						},
					},
				},
				false,
			],
		];

		for (const [description, input, expected] of tests) {
			test(description, () => {
				const result = displayParameter(
					input.nodeValues,
					input.parameter,
					input.node,
					input.nodeTypeDescription,
					input.nodeValuesRoot,
					input.displayKey,
				);
				expect(result).toEqual(expected);
			});
		}
	});

	describe('makeDescription', () => {
		let mockNodeTypeDescription: INodeTypeDescription;

		beforeEach(() => {
			// Arrange a basic mock node type description
			mockNodeTypeDescription = {
				displayName: 'Test Node',
				name: 'testNode',
				icon: 'fa:test',
				group: ['transform'],
				version: 1,
				description: 'This is a test node',
				defaults: {
					name: 'Test Node',
				},
				inputs: ['main'],
				outputs: ['main'],
				properties: [],
			};
		});

		test('should return action-based description when action is available', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							action: 'Create a new user',
						},
					],
					default: 'create',
				},
			];

			// Act
			const result = makeDescription(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Create a new user in Test Node');
		});

		test('should return resource-operation-based description when action is not available', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							// No action property
						},
					],
					default: 'create',
				},
			];

			// Act
			const result = makeDescription(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('create user in Test Node');
		});

		test('should return default description when resource or operation is missing', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				// No resource or operation
			};

			// Act
			const result = makeDescription(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('This is a test node');
		});

		test('should handle case where nodeTypeOperation is not found', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				// No matching operation property
			];

			// Act
			const result = makeDescription(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('create user in Test Node');
		});

		test('should handle case where options are not a list of INodePropertyOptions', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					// Options are not INodePropertyOptions[]
					options: [
						//@ts-expect-error
						{},
					],
					default: 'create',
				},
			];

			// Act
			const result = makeDescription(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('create user in Test Node');
		});
	});

	describe('getUpdatedToolDescription', () => {
		let mockNodeTypeDescription: INodeTypeDescription;

		beforeEach(() => {
			// Arrange a basic mock node type description
			mockNodeTypeDescription = {
				displayName: 'Test Node',
				name: 'testNode',
				icon: 'fa:test',
				group: ['transform'],
				version: 1,
				description: 'This is a test node',
				defaults: {
					name: 'Test Node',
				},
				inputs: ['main'],
				outputs: ['main'],
				properties: [],
				usableAsTool: true,
			};
		});

		test('should return undefined when descriptionType is not manual', () => {
			// Arrange
			const newParameters: INodeParameters = {
				descriptionType: 'automatic',
				resource: 'user',
				operation: 'create',
			};
			const currentParameters: INodeParameters = {
				descriptionType: 'automatic',
				resource: 'user',
				operation: 'create',
			};

			// Act
			const result = getUpdatedToolDescription(
				mockNodeTypeDescription,
				newParameters,
				currentParameters,
			);

			// Assert
			expect(result).toBeUndefined();
		});

		test('should return new description when toolDescription matches previous description', () => {
			// Arrange
			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							action: 'Create a new user',
						},
					],
					default: 'create',
				},
			];

			const currentParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
			};

			const newParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'update',
				toolDescription: 'Create a new user in Test Node', // Matches the previous description
			};

			// Act
			const result = getUpdatedToolDescription(
				mockNodeTypeDescription,
				newParameters,
				currentParameters,
			);

			// Assert
			expect(result).toBe('update user in Test Node');
		});

		test('should return new description when toolDescription matches node type description', () => {
			// Arrange
			const currentParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
			};

			const newParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'update',
				toolDescription: 'This is a test node', // Matches the node type description
			};

			// Act
			const result = getUpdatedToolDescription(
				mockNodeTypeDescription,
				newParameters,
				currentParameters,
			);

			// Assert
			expect(result).toBe('update user in Test Node');
		});

		test('should return undefined when toolDescription is custom', () => {
			// Arrange
			const currentParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
			};

			const newParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'update',
				toolDescription: 'My custom description', // Custom description
			};

			// Act
			const result = getUpdatedToolDescription(
				mockNodeTypeDescription,
				newParameters,
				currentParameters,
			);

			// Assert
			expect(result).toBeUndefined();
		});

		test('should return undefined for null inputs', () => {
			// Act
			const result = getUpdatedToolDescription(null, null);

			// Assert
			expect(result).toBeUndefined();
		});

		test('should return new description when toolDescription is empty or whitespace', () => {
			// Arrange
			const currentParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
			};

			const newParameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'update',
				toolDescription: '   ', // Empty/whitespace description
			};

			// Act
			const result = getUpdatedToolDescription(
				mockNodeTypeDescription,
				newParameters,
				currentParameters,
			);

			// Assert
			expect(result).toBe('update user in Test Node');
		});
	});

	describe('getToolDescriptionForNode', () => {
		let mockNode: INode;
		let mockNodeType: INodeType;

		beforeEach(() => {
			// Arrange a basic mock node
			mockNode = {
				id: 'test-node-id',
				name: 'Test Node',
				typeVersion: 1,
				type: 'test-node-type',
				position: [0, 0],
				parameters: {},
			};

			// Arrange a basic mock node type
			mockNodeType = {
				description: {
					displayName: 'Test Node Type',
					name: 'testNodeType',
					icon: 'fa:test',
					group: ['transform'],
					version: 1,
					description: 'This is the default node description',
					defaults: {
						name: 'Test Node Type',
					},
					inputs: ['main'],
					outputs: ['main'],
					properties: [],
				},
			} as INodeType;
		});

		test('should use generated description when descriptionType is auto', () => {
			// Arrange
			mockNode.parameters = {
				descriptionType: 'auto',
				resource: 'user',
				operation: 'create',
			};

			mockNodeType.description.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							action: 'Create a new user',
						},
					],
					default: 'create',
				},
			];

			// Act
			const result = getToolDescriptionForNode(mockNode, mockNodeType);

			// Assert
			expect(result).toBe('Create a new user in Test Node Type');
		});

		test('should use generated description when toolDescription is empty', () => {
			// Arrange
			mockNode.parameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
				toolDescription: '',
			};

			// Act
			const result = getToolDescriptionForNode(mockNode, mockNodeType);

			// Assert
			expect(result).toBe('create user in Test Node Type');
		});

		test('should use generated description when toolDescription is only whitespace', () => {
			// Arrange
			mockNode.parameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
				toolDescription: '   ',
			};

			// Act
			const result = getToolDescriptionForNode(mockNode, mockNodeType);

			// Assert
			expect(result).toBe('create user in Test Node Type');
		});

		test('should use custom toolDescription when it exists', () => {
			// Arrange
			mockNode.parameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
				toolDescription: 'My custom description',
			};

			// Act
			const result = getToolDescriptionForNode(mockNode, mockNodeType);

			// Assert
			expect(result).toBe('My custom description');
		});

		test('should fall back to node type description when toolDescription is undefined', () => {
			// Arrange
			mockNode.parameters = {
				descriptionType: 'manual',
			};

			// Act
			const result = getToolDescriptionForNode(mockNode, mockNodeType);

			// Assert
			expect(result).toBe('This is the default node description');
		});
	});
	describe('isDefaultNodeName', () => {
		let mockNodeTypeDescription: INodeTypeDescription;

		beforeEach(() => {
			// Arrange a basic mock node type description
			mockNodeTypeDescription = {
				displayName: 'Test Node',
				name: 'testNode',
				icon: 'fa:test',
				group: ['transform'],
				version: 1,
				description: 'This is a test node',
				defaults: {
					name: 'Test Node',
				},
				inputs: ['main'],
				outputs: ['main'],
				properties: [],
				usableAsTool: true,
			};
		});

		it.each([
			['Create a new user', true],
			['Test Node', false],
			['Test Node1', false],
			['Create a new user5', true],
			['Create a new user in Test Node5', false],
			['Create a new user 5', false],
			['Update user', false],
			['Update user5', false],
			['TestNode', false],
		])('should detect default names for input %s', (input, expected) => {
			// Arrange
			const name = input;

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							action: 'Create a new user',
						},
						{
							name: 'Update',
							value: 'update',
							action: 'Update a new user',
						},
					],
					default: 'create',
				},
			];

			const parameters: INodeParameters = {
				descriptionType: 'manual',
				resource: 'user',
				operation: 'create',
			};

			// Act
			const result = isDefaultNodeName(name, mockNodeTypeDescription, parameters);

			// Assert
			expect(result).toBe(expected);
		});
		it('should detect default names for tool node types', () => {
			// Arrange
			const name = 'Create user in Test Node';
			mockNodeTypeDescription.outputs = [NodeConnectionTypes.AiTool];

			const parameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			// Act
			const result = isDefaultNodeName(name, mockNodeTypeDescription, parameters);

			// Assert
			expect(result).toBe(true);
		});
		it('should detect non-default names for tool node types', () => {
			// Arrange
			// The default for tools would include ` in Test Node`
			const name = 'Create user';
			mockNodeTypeDescription.outputs = [NodeConnectionTypes.AiTool];

			const parameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			// Act
			const result = isDefaultNodeName(name, mockNodeTypeDescription, parameters);

			// Assert
			expect(result).toBe(false);
		});
	});
	describe('makeNodeName', () => {
		let mockNodeTypeDescription: INodeTypeDescription;

		beforeEach(() => {
			// Arrange a basic mock node type description
			mockNodeTypeDescription = {
				displayName: 'Test Node',
				name: 'testNode',
				icon: 'fa:test',
				group: ['transform'],
				version: 1,
				description: 'This is a test node',
				defaults: {
					name: 'Test Node',
				},
				inputs: ['main'],
				outputs: ['main'],
				properties: [],
			};
		});

		test('should return action-based name when action is available', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							action: 'Create a new user',
						},
					],
					default: 'create',
				},
			];

			// Act
			const result = makeNodeName(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Create a new user');
		});

		test('should return resource-operation-based name when action is not available', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							// No action property
						},
					],
					default: 'create',
				},
			];

			// Act
			const result = makeNodeName(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Create user');
		});

		test('should return default name when resource or operation is missing', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				// No resource or operation
			};

			// Act
			const result = makeNodeName(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Test Node');
		});

		test('should handle case where nodeTypeOperation is not found', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				// No matching operation property
			];

			// Act
			const result = makeNodeName(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Create user');
		});

		test('should handle case where options are not a list of INodePropertyOptions', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.properties = [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					displayOptions: {
						show: {
							resource: ['user'],
						},
					},
					// Options are not INodePropertyOptions[]
					options: [
						//@ts-expect-error
						{},
					],
					default: 'create',
				},
			];

			// Act
			const result = makeNodeName(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Create user');
		});
		test('should handle case where node is a tool', () => {
			// Arrange
			const nodeParameters: INodeParameters = {
				resource: 'user',
				operation: 'create',
			};

			mockNodeTypeDescription.outputs = [NodeConnectionTypes.AiTool];
			mockNodeTypeDescription.properties = [
				// No matching operation property
			];

			// Act
			const result = makeNodeName(nodeParameters, mockNodeTypeDescription);

			// Assert
			expect(result).toBe('Create user in Test Node');
		});

		test.each([
			['javaScript', 'Code in JavaScript'],
			['python', 'Code in Python (Beta)'],
			['pythonNative', 'Code in Python (Native) (Beta)'],
		])(
			'should return action-based name for Code node with %s language',
			(language, expectedAction) => {
				mockNodeTypeDescription.name = 'n8n-nodes-base.code';
				mockNodeTypeDescription.properties = [
					{
						displayName: 'Language',
						name: 'language',
						type: 'options',
						options: [
							{
								name: 'JavaScript',
								value: 'javaScript',
								action: 'Code in JavaScript',
							},
							{
								name: 'Python (Beta)',
								value: 'python',
								action: 'Code in Python (Beta)',
							},
							{
								name: 'Python (Native) (Beta)',
								value: 'pythonNative',
								action: 'Code in Python (Native) (Beta)',
							},
						],
						default: 'javaScript',
					},
				];
				const result = makeNodeName({ language }, mockNodeTypeDescription);
				expect(result).toBe(expectedAction);
			},
		);
	});
	describe('isTool', () => {
		it('should return true for a node with AiTool output', () => {
			const description = {
				outputs: [NodeConnectionTypes.AiTool],
				version: 0,
				defaults: {
					name: '',
					color: '',
				},
				inputs: [NodeConnectionTypes.Main],
				properties: [],
				displayName: '',
				group: [],
				description: '',
				name: 'n8n-nodes-base.someTool',
			};
			const parameters = {};
			const result = isTool(description, parameters);
			expect(result).toBe(true);
		});

		it('should return true for a node with AiTool output in NodeOutputConfiguration', () => {
			const description = {
				outputs: [{ type: NodeConnectionTypes.AiTool }, { type: NodeConnectionTypes.Main }],
				version: 0,
				defaults: {
					name: '',
					color: '',
				},
				inputs: [NodeConnectionTypes.Main],
				properties: [],
				displayName: '',
				group: [],
				description: '',
				name: 'n8n-nodes-base.someTool',
			};
			const parameters = {};
			const result = isTool(description, parameters);
			expect(result).toBe(true);
		});

		it('returns true for a vector store node in retrieve-as-tool mode', () => {
			const description = {
				outputs: [NodeConnectionTypes.Main],
				version: 0,
				defaults: {
					name: '',
					color: '',
				},
				inputs: [NodeConnectionTypes.Main],
				properties: [],
				displayName: '',
				description: '',
				group: [],
				name: 'n8n-nodes-base.vectorStore',
			};
			const parameters = { mode: 'retrieve-as-tool' };
			const result = isTool(description, parameters);
			expect(result).toBe(true);
		});

		it('returns false for node with no AiTool output', () => {
			const description = {
				outputs: [NodeConnectionTypes.Main],
				version: 0,
				defaults: {
					name: '',
					color: '',
				},
				inputs: [NodeConnectionTypes.Main],
				properties: [],
				displayName: '',
				group: [],
				description: '',
				name: 'n8n-nodes-base.someTool',
			};
			const parameters = { mode: 'retrieve-as-tool' };
			const result = isTool(description, parameters);
			expect(result).toBe(false);
		});
	});
	describe('getNodeWebhookPath', () => {
		const mockWorkflowId = 'workflow-123';
		const mockPath = 'test-path';

		it('should return path when restartWebhook is true', () => {
			const node = mock<INode>({ name: 'TestNode' });

			const result = getNodeWebhookPath(mockWorkflowId, node, mockPath, false, true);

			expect(result).toBe(mockPath);
		});

		it('should return path when node has webhookId and isFullPath is true', () => {
			const node = mock<INode>({ name: 'TestNode', webhookId: 'webhook-456' });

			const result = getNodeWebhookPath(mockWorkflowId, node, mockPath, true, false);

			expect(result).toBe(mockPath);
		});

		it('should return webhookId when node has webhookId, isFullPath is true, and path is empty', () => {
			const node = mock<INode>({ name: 'TestNode', webhookId: 'webhook-456' });

			const result = getNodeWebhookPath(mockWorkflowId, node, '', true, false);

			expect(result).toBe('webhook-456');
		});

		it('should return webhookId/path when node has webhookId and isFullPath is false', () => {
			const node = mock<INode>({ name: 'TestNode', webhookId: 'webhook-456' });

			const result = getNodeWebhookPath(mockWorkflowId, node, mockPath, false, false);

			expect(result).toBe('webhook-456/test-path');
		});

		it('should return workflowId/nodename/path when node has no webhookId', () => {
			const node = mock<INode>({ name: 'TestNode', webhookId: undefined });

			const result = getNodeWebhookPath(mockWorkflowId, node, mockPath, false, false);

			expect(result).toBe('workflow-123/testnode/test-path');
		});
	});
});



================================================
FILE: packages/workflow/test/node-reference-parser-utils.test.ts
================================================
import type { INode } from '../src/interfaces';
import {
	hasDotNotationBannedChar,
	backslashEscape,
	dollarEscape,
	applyAccessPatterns,
	extractReferencesInNodeExpressions,
} from '../src/node-reference-parser-utils';

const makeNode = (name: string, expressions?: string[]) =>
	({
		parameters: Object.fromEntries(expressions?.map((x, i) => [`p${i}`, `={{ ${x} }}`]) ?? []),
		name,
	}) as INode;

describe('NodeReferenceParserUtils', () => {
	describe('hasDotNotationBannedChar', () => {
		it('should return true for strings with banned characters', () => {
			expect(hasDotNotationBannedChar('1abc')).toBe(true);
			expect(hasDotNotationBannedChar('abc!')).toBe(true);
			expect(hasDotNotationBannedChar('abc@')).toBe(true);
		});

		it('should return false for strings without banned characters', () => {
			expect(hasDotNotationBannedChar('abc')).toBe(false);
			expect(hasDotNotationBannedChar('validName')).toBe(false);
		});
	});

	describe('backslashEscape', () => {
		it('should escape special characters with a backslash', () => {
			expect(backslashEscape('abc.def')).toBe('abc\\.def');
			expect(backslashEscape('[abc]')).toBe('\\[abc\\]');
			expect(backslashEscape('a+b')).toBe('a\\+b');
		});

		it('should return the same string if no escapable characters are present', () => {
			expect(backslashEscape('abc')).toBe('abc');
		});
	});

	describe('dollarEscape', () => {
		it('should escape dollar signs with double dollar signs', () => {
			expect(dollarEscape('$abc')).toBe('$$abc');
			expect(dollarEscape('abc$')).toBe('abc$$');
			expect(dollarEscape('$a$b$c')).toBe('$$a$$b$$c');
		});

		it('should return the same string if no dollar signs are present', () => {
			expect(dollarEscape('abc')).toBe('abc');
		});
	});

	describe('applyAccessPatterns', () => {
		it.each([
			{
				expression: '$node["oldName"].data',
				previousName: 'oldName',
				newName: 'newName',
				expected: '$node["newName"].data',
			},
			{
				expression: '$node.oldName.data',
				previousName: 'oldName',
				newName: 'new.Name',
				expected: '$node["new.Name"].data',
			},
			{
				expression: '$node["someOtherName"].data',
				previousName: 'oldName',
				newName: 'newName',
				expected: '$node["someOtherName"].data',
			},
			{
				expression: '$node["oldName"].data + $node["oldName"].info',
				previousName: 'oldName',
				newName: 'newName',
				expected: '$node["newName"].data + $node["newName"].info',
			},
			{
				expression: '$items("oldName", 0)',
				previousName: 'oldName',
				newName: 'newName',
				expected: '$items("newName", 0)',
			},
			{
				expression: "$items('oldName', 0)",
				previousName: 'oldName',
				newName: 'newName',
				expected: "$items('newName', 0)",
			},
			{
				expression: "$('oldName')",
				previousName: 'oldName',
				newName: 'newName',
				expected: "$('newName')",
			},
			{
				expression: '$("oldName")',
				previousName: 'oldName',
				newName: 'newName',
				expected: '$("newName")',
			},
			{
				expression: '$node["oldName"].data + $items("oldName", 0) + $("oldName")',
				previousName: 'oldName',
				newName: 'newName',
				expected: '$node["newName"].data + $items("newName", 0) + $("newName")',
			},
			{
				expression: '$node["oldName"].data + $items("oldName", 0)',
				previousName: 'oldName',
				newName: 'new-Name',
				expected: '$node["new-Name"].data + $items("new-Name", 0)',
			},
			{
				expression: '$node["old-Name"].data + $items("old-Name", 0)',
				previousName: 'old-Name',
				newName: 'newName',
				expected: '$node["newName"].data + $items("newName", 0)',
			},
			{
				expression: 'someRandomExpression("oldName")',
				previousName: 'oldName',
				newName: 'newName',
				expected: 'someRandomExpression("oldName")',
			},
			{
				expression: '$("old\\"Name")',
				previousName: 'old\\"Name',
				newName: 'n\\\'ew\\"Name',
				expected: '$("n\\\'ew\\"Name")',
			},
		])(
			'should correctly transform expression "$expression" with previousName "$previousName" and newName "$newName"',
			({ expression, previousName, newName, expected }) => {
				const result = applyAccessPatterns(expression, previousName, newName);
				expect(result).toBe(expected);
			},
		);
	});

	describe('extractReferencesInNodeExpressions', () => {
		let nodes: INode[] = [];
		let nodeNames: string[] = [];
		let startNodeName = 'Start';
		beforeEach(() => {
			nodes = [
				makeNode('B', ['$("A").item.json.myField']),
				makeNode('C', ['$("A").first().json.myField.anotherField']),
			];
			nodeNames = ['A', 'B', 'C'];
			startNodeName = 'Start';
		});
		it('should extract used expressions', () => {
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField', '$("A").item.json.myField'],
				['myField_anotherField_firstItem', '$("A").first().json.myField.anotherField'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: "={{ $('Start').item.json.myField }}" },
				},
				{
					name: 'C',
					parameters: { p0: "={{ $('Start').first().json.myField_anotherField_firstItem }}" },
				},
			]);
		});
		it('should handle metadata functions', () => {
			nodes = [
				makeNode('B', ['$("A").isExecuted ? 1 : 2']),
				makeNode('C', ['someFunction($("D").params["resource"])']),
			];
			nodeNames = ['A', 'B', 'C', 'D'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['A_isExecuted', '$("A").isExecuted'],
				['D_params', '$("D").params'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: "={{ $('Start').first().json.A_isExecuted ? 1 : 2 }}" },
				},
				{
					name: 'C',
					parameters: { p0: '={{ someFunction($(\'Start\').first().json.D_params["resource"]) }}' },
				},
			]);
		});
		it('should not handle standalone node references', () => {
			nodes = [makeNode('B', ['$("D")'])];
			nodeNames = ['B', 'D'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName, ['B']);
			expect([...result.variables.entries()]).toEqual([]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: '={{ $("D") }}' },
				},
			]);
		});

		it('should not handle reference to non-existent node', () => {
			nodes = [makeNode('B', ['$("E").item.json.x'])];
			nodeNames = ['B'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName, ['B']);
			expect([...result.variables.entries()]).toEqual([]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: '={{ $("E").item.json.x }}' },
				},
			]);
		});
		it('should not handle invalid node references', () => {
			nodes = [makeNode('B', ['$("D)'])];
			nodeNames = ['B', 'D'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: '={{ $("D) }}' },
				},
			]);
		});
		it('should not handle new fields on the node', () => {
			nodes = [makeNode('B', ['$("D").thisIsNotAField.json.x.y.z'])];
			nodeNames = ['B', 'D'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: '={{ $("D").thisIsNotAField.json.x.y.z }}' },
				},
			]);
		});
		it('should handle $json in graphInputNodeName only', () => {
			nodes = [makeNode('B', ['$json.a.b.c_d["e"]["f"]']), makeNode('C', ['$json.x.y.z'])];
			nodeNames = ['A', 'B', 'C'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName, ['B']);
			expect([...result.variables.entries()]).toEqual([['a_b_c_d', '$json.a.b.c_d']]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: '={{ $json.a_b_c_d["e"]["f"] }}' },
				},
				{
					name: 'C',
					parameters: { p0: '={{ $json.x.y.z }}' },
				},
			]);
		});
		it('should handle complex $json case for first node', () => {
			nodes = [
				{
					parameters: {
						p0: '=https://raw.githubusercontent.com/{{ $json.org }}/{{ $json.repo }}/refs/heads/master/package.json',
					},
					name: 'A',
				} as unknown as INode,
			];
			nodeNames = ['A', 'B'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName, ['A']);
			expect([...result.variables.entries()]).toEqual([
				['repo', '$json.repo'],
				['org', '$json.org'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'A',
					parameters: {
						p0: '=https://raw.githubusercontent.com/{{ $json.org }}/{{ $json.repo }}/refs/heads/master/package.json',
					},
				},
			]);
		});
		it('should support different node accessor patterns', () => {
			nodes = [
				makeNode('N', ['$("A").item.json.myField']),
				makeNode('O', ['$node["B"].item.json.myField']),
				makeNode('P', ['$node.C.item.json.myField']),
			];
			nodeNames = ['A', 'B', 'C', 'N', 'O', 'P'];

			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField', '$("A").item.json.myField'],
				['B_myField', '$node["B"].item.json.myField'],
				['C_myField', '$node.C.item.json.myField'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'N',
					parameters: { p0: "={{ $('Start').item.json.myField }}" },
				},
				{
					name: 'O',
					parameters: { p0: "={{ $('Start').item.json.B_myField }}" },
				},
				{
					name: 'P',
					parameters: { p0: "={{ $('Start').item.json.C_myField }}" },
				},
			]);
		});
		it('should handle simple name clashes', () => {
			nodes = [
				makeNode('B', ['$("A").item.json.myField']),
				makeNode('C', ['$("D").item.json.myField']),
				makeNode('E', ['$("F").item.json.myField']),
			];
			nodeNames = ['A', 'B', 'C', 'D', 'E', 'F'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField', '$("A").item.json.myField'],
				['D_myField', '$("D").item.json.myField'],
				['F_myField', '$("F").item.json.myField'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: "={{ $('Start').item.json.myField }}" },
				},
				{
					name: 'C',
					parameters: { p0: "={{ $('Start').item.json.D_myField }}" },
				},
				{
					name: 'E',
					parameters: { p0: "={{ $('Start').item.json.F_myField }}" },
				},
			]);
		});

		it('should handle complex name clashes', () => {
			nodes = [
				makeNode('F', ['$("A").item.json.myField']),
				makeNode('B', ['$("A").item.json.Node_Name_With_Gap_myField']),
				makeNode('C', ['$("D").item.json.Node_Name_With_Gap_myField']),
				makeNode('E', ['$("Node_Name_With_Gap").item.json.myField']),
			];
			nodeNames = ['A', 'B', 'C', 'D', 'E', 'F', 'Node_Name_With_Gap'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField', '$("A").item.json.myField'],
				['Node_Name_With_Gap_myField', '$("A").item.json.Node_Name_With_Gap_myField'],
				['D_Node_Name_With_Gap_myField', '$("D").item.json.Node_Name_With_Gap_myField'],
				// This is the `myField` variable from node 'E', referencing $("Node_Name_With_Gap").item.json.myField
				// It first has a clash with A.myField, requiring its node name to come attached
				// And then has _1 because it clashes B.Node_Name_With_Gap_myField
				['Node_Name_With_Gap_myField_1', '$("Node_Name_With_Gap").item.json.myField'],
			]);
			expect(result.nodes).toEqual([
				{ name: 'F', parameters: { p0: "={{ $('Start').item.json.myField }}" } },
				{
					name: 'B',
					parameters: { p0: "={{ $('Start').item.json.Node_Name_With_Gap_myField }}" },
				},
				{
					name: 'C',
					parameters: { p0: "={{ $('Start').item.json.D_Node_Name_With_Gap_myField }}" },
				},
				{
					name: 'E',
					parameters: { p0: "={{ $('Start').item.json.Node_Name_With_Gap_myField_1 }}" },
				},
			]);
		});

		it('should handle code node', () => {
			nodes = [
				{
					parameters: {
						jsCode:
							"for (const item of $input.all()) {\n  item.json.myNewField = $('DebugHelper').first().json.uid;\n}\n\nreturn $input.all();",
					},
					type: 'n8n-nodes-base.code',
					typeVersion: 2,
					position: [660, 0],
					id: 'c9de02d0-982a-4f8c-9af7-93f63795aa9b',
					name: 'Code',
				},
			];
			nodeNames = ['DebugHelper', 'Code'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['uid_firstItem', "$('DebugHelper').first().json.uid"],
			]);
			expect(result.nodes).toEqual([
				{
					parameters: {
						jsCode:
							"for (const item of $input.all()) {\n  item.json.myNewField = $('Start').first().json.uid_firstItem;\n}\n\nreturn $input.all();",
					},
					type: 'n8n-nodes-base.code',
					typeVersion: 2,
					position: [660, 0],
					id: 'c9de02d0-982a-4f8c-9af7-93f63795aa9b',
					name: 'Code',
				},
			]);
		});
		it('should not extract expression referencing node in subGraph', () => {
			nodes = [
				makeNode('B', ['$("A").item.json.myField']),
				makeNode('C', ['$("B").first().json.myField.anotherField']),
			];
			nodeNames = ['A', 'B', 'C'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([['myField', '$("A").item.json.myField']]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: { p0: "={{ $('Start').item.json.myField }}" },
				},
				{
					name: 'C',
					parameters: { p0: '={{ $("B").first().json.myField.anotherField }}' },
				},
			]);
		});
		it('should throw if node name clashes with start name', () => {
			nodes = [makeNode('Start', ['$("A").item.json.myField'])];
			nodeNames = ['A', 'Start'];
			expect(() => extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName)).toThrow();
		});

		it('should support custom Start node name', () => {
			nodes = [makeNode('Start', ['$("A").item.json.myField'])];
			nodeNames = ['A', 'Start'];
			startNodeName = 'A different start name';
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([['myField', '$("A").item.json.myField']]);
			expect(result.nodes).toEqual([
				{
					name: 'Start',
					parameters: { p0: "={{ $('A different start name').item.json.myField }}" },
				},
			]);
		});
		it('should throw if called with node in subgraph whose name is not in nodeNames list', () => {
			nodes = [makeNode('B', ['$("A").item.json.myField'])];
			nodeNames = ['A'];
			expect(() => extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName)).toThrow();
		});
		it('handles multiple expressions referencing different nodes in the same string', () => {
			nodes = [makeNode('B', ['$("A").item.json.myField + $("C").item.json.anotherField'])];
			nodeNames = ['A', 'B', 'C'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['anotherField', '$("C").item.json.anotherField'],
				['myField', '$("A").item.json.myField'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: {
						p0: "={{ $('Start').item.json.myField + $('Start').item.json.anotherField }}",
					},
				},
			]);
		});

		it('handles multiple expressions referencing different nested bits of the same field', () => {
			nodes = [
				makeNode('B', [
					'$("A").item.json.myField.nestedField',
					'$("A").item.json.myField.anotherNestedField',
					'$("A").item.json.myField.anotherNestedField.x.y.z',
				]),
			];
			nodeNames = ['A', 'B'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField_nestedField', '$("A").item.json.myField.nestedField'],
				['myField_anotherNestedField', '$("A").item.json.myField.anotherNestedField'],
				['myField_anotherNestedField_x_y_z', '$("A").item.json.myField.anotherNestedField.x.y.z'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: {
						p0: "={{ $('Start').item.json.myField_nestedField }}",
						p1: "={{ $('Start').item.json.myField_anotherNestedField }}",
						p2: "={{ $('Start').item.json.myField_anotherNestedField_x_y_z }}",
					},
				},
			]);
		});

		it('handles first(), last(), all() and items at the same time', () => {
			nodes = [
				makeNode('B', [
					'$("A").first().json.myField',
					'$("A").last().json.myField',
					'$("A").all().json.myField',
					'$("A").item.json.myField',
					'$("A").first()',
					'$("A").all()',
				]),
			];
			nodeNames = ['A', 'B'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField_firstItem', '$("A").first().json.myField'],
				['myField_lastItem', '$("A").last().json.myField'],
				['myField_allItems', '$("A").all().json.myField'],
				['myField', '$("A").item.json.myField'],
				['A_firstItem', '$("A").first()'],
				['A_allItems', '$("A").all()'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: {
						p0: "={{ $('Start').first().json.myField_firstItem }}",
						p1: "={{ $('Start').last().json.myField_lastItem }}",
						p2: "={{ $('Start').first().json.myField_allItems }}",
						p3: "={{ $('Start').item.json.myField }}",
						p4: "={{ $('Start').first().json.A_firstItem }}",
						p5: "={{ $('Start').first().json.A_allItems }}",
					},
				},
			]);
		});
		it('handles supported itemMatching examples', () => {
			nodes = [
				makeNode('B', [
					'$("A").itemMatching(0).json.myField',
					'$("A").itemMatching(1).json.myField',
					'$("C").itemMatching(1).json.myField',
					'$("A").itemMatching(20).json.myField',
				]),
			];
			nodeNames = ['A', 'B', 'C'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField_itemMatching_0', '$("A").itemMatching(0).json.myField'],
				['myField_itemMatching_1', '$("A").itemMatching(1).json.myField'],
				['C_myField_itemMatching_1', '$("C").itemMatching(1).json.myField'],
				['myField_itemMatching_20', '$("A").itemMatching(20).json.myField'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: {
						p0: "={{ $('Start').itemMatching(0).json.myField_itemMatching_0 }}",
						p1: "={{ $('Start').itemMatching(1).json.myField_itemMatching_1 }}",
						p2: "={{ $('Start').itemMatching(1).json.C_myField_itemMatching_1 }}",
						p3: "={{ $('Start').itemMatching(20).json.myField_itemMatching_20 }}",
					},
				},
			]);
		});
		it('does not throw for complex itemMatching example', () => {
			nodes = [
				makeNode('B', [
					'$("A").itemMatching(Math.PI).json.myField',
					'$("A").itemMatching(eval("const fib = (n) => n < 2 ? 1 : (fib(n - 1) + fib(n-2)); fib(15)")).json.anotherField',
					'$("A").itemMatching($("A").itemMatch(1).json.myField).json.myField',
				]),
			];
			nodeNames = ['A', 'B'];
			expect(() =>
				extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName),
			).not.toThrow();
		});
		it('should handle multiple expressions', () => {
			nodes = [
				makeNode('B', ['$("A").item.json.myField', '$("C").item.json.anotherField']),
				makeNode('D', ['$("A").item.json.myField', '$("B").item.json.someField']),
			];
			nodeNames = ['A', 'B', 'C', 'D'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField', '$("A").item.json.myField'],
				['anotherField', '$("C").item.json.anotherField'],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'B',
					parameters: {
						p0: "={{ $('Start').item.json.myField }}",
						p1: "={{ $('Start').item.json.anotherField }}",
					},
				},
				{
					name: 'D',
					parameters: {
						p0: "={{ $('Start').item.json.myField }}",
						p1: '={{ $("B").item.json.someField }}',
					},
				},
			]);
		});
		it('should support handle calls to normal js functions on the data accessor', () => {
			nodes = [makeNode('A', ['$("B B").first().toJsonObject().randomJSFunction()'])];
			nodeNames = ['A', 'B B'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([['B_B_firstItem', '$("B B").first()']]);
			expect(result.nodes).toEqual([
				{
					name: 'A',
					parameters: {
						p0: "={{ $('Start').first().json.B_B_firstItem.toJsonObject().randomJSFunction() }}",
					},
				},
			]);
		});
		it('should support handle spaces and special characters in nodeNames', () => {
			nodes = [
				makeNode('a_=-9-0!@#!%^$%&*(', ['$("A").item.json.myField']),
				makeNode('A node with spaces', [
					'$("A \\" |[w.e,i,r$d]| `\' Ñode  \\$\\( Name \\)").item.json.myField',
				]),
			];
			nodeNames = [
				'A',
				'A node with spaces',
				'A \\" |[w.e,i,r$d]| `\' Ñode  \\$\\( Name \\)',
				'a_=-9-0!@#!%^$%&*(',
			];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([
				['myField', '$("A").item.json.myField'],
				[
					'A__weir$d__ode__$_Name__myField',
					'$("A \\" |[w.e,i,r$d]| `\' Ñode  \\$\\( Name \\)").item.json.myField',
				],
			]);
			expect(result.nodes).toEqual([
				{
					name: 'a_=-9-0!@#!%^$%&*(',
					parameters: { p0: "={{ $('Start').item.json.myField }}" },
				},
				{
					name: 'A node with spaces',
					parameters: { p0: "={{ $('Start').item.json.A__weir$d__ode__$_Name__myField }}" },
				},
			]);
		});
		it('should handle assignments format of Set node correctly', () => {
			nodes = [
				{
					parameters: {
						assignments: {
							assignments: [
								{
									id: 'cf8bd6cb-f28a-4a73-b141-02e5c22cfe74',
									name: 'ghApiBaseUrl',
									value: '={{ $("A").item.json.x.y.z }}',
									type: 'string',
								},
							],
						},
						options: {},
					},
					type: 'n8n-nodes-base.set',
					typeVersion: 3.4,
					position: [80, 80],
					id: '6e2fd284-2aba-4dee-8921-18be9a291484',
					name: 'Params',
				},
			];
			nodeNames = ['A', 'Params'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([['x_y_z', '$("A").item.json.x.y.z']]);
			expect(result.nodes).toEqual([
				{
					parameters: {
						assignments: {
							assignments: [
								{
									id: 'cf8bd6cb-f28a-4a73-b141-02e5c22cfe74',
									name: 'ghApiBaseUrl',
									value: "={{ $('Start').item.json.x_y_z }}",
									type: 'string',
								},
							],
						},
						options: {},
					},
					type: 'n8n-nodes-base.set',
					typeVersion: 3.4,
					position: [80, 80],
					id: '6e2fd284-2aba-4dee-8921-18be9a291484',
					name: 'Params',
				},
			]);
		});
		it('should support handle unexpected code after the data accessor', () => {
			nodes = [makeNode('A', ['$("B").all()[0].json.first_node_variable'])];
			nodeNames = ['A', 'B'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([['B_allItems', '$("B").all()']]);
			expect(result.nodes).toEqual([
				{
					name: 'A',
					parameters: {
						p0: "={{ $('Start').first().json.B_allItems[0].json.first_node_variable }}",
					},
				},
			]);
		});
		it('should carry over unrelated properties', () => {
			nodes = [
				{
					parameters: {
						a: 3,
						b: { c: 4, d: true },
						d: 'hello',
						e: "={{ $('goodbye').item.json.f }}",
					},
					name: 'A',
				} as unknown as INode,
			];
			nodeNames = ['A', 'goodbye'];
			const result = extractReferencesInNodeExpressions(nodes, nodeNames, startNodeName);
			expect([...result.variables.entries()]).toEqual([['f', "$('goodbye').item.json.f"]]);
			expect(result.nodes).toEqual([
				{
					parameters: {
						a: 3,
						b: { c: 4, d: true },
						d: 'hello',
						e: "={{ $('Start').item.json.f }}",
					},
					name: 'A',
				},
			]);
		});
	});
});



================================================
FILE: packages/workflow/test/node-types.ts
================================================
import { mock } from 'vitest-mock-extended';

import {
	NodeConnectionTypes,
	type IDataObject,
	type INodeType,
	type INodeTypeData,
	type INodeTypes,
	type IVersionedNodeType,
	type LoadedClass,
} from '../src/interfaces';
import * as NodeHelpers from '../src/node-helpers';

const stickyNode: LoadedClass<INodeType> = {
	type: {
		description: {
			displayName: 'Sticky Note',
			name: 'n8n-nodes-base.stickyNote',
			icon: 'fa:sticky-note',
			group: ['input'],
			version: 1,
			description: 'Make your workflow easier to understand',
			defaults: { name: 'Sticky Note', color: '#FFD233' },
			inputs: [],
			outputs: [],
			properties: [
				{
					displayName: 'Content',
					name: 'content',
					type: 'string',
					required: true,
					default:
						"## I'm a note \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)",
				},
				{ displayName: 'Height', name: 'height', type: 'number', required: true, default: 160 },
				{ displayName: 'Width', name: 'width', type: 'number', required: true, default: 240 },
				{ displayName: 'Color', name: 'color', type: 'number', required: true, default: 1 },
			],
		},
	},
	sourcePath: '',
};

const googleSheetsNode: LoadedClass<IVersionedNodeType> = {
	sourcePath: '',
	type: {
		nodeVersions: {
			'1': {
				methods: {
					loadOptions: {},
					credentialTest: {},
				},
				description: {
					displayName: 'Google Sheets ',
					name: 'googleSheets',
					icon: 'file:googleSheets.svg',
					group: ['input', 'output'],
					defaultVersion: 4.2,
					subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
					description: 'Read, update and write data to Google Sheets',
					version: [1, 2],
					defaults: {
						name: 'Google Sheets',
					},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main],
					credentials: [
						{
							name: 'googleApi',
							required: true,
							displayOptions: {
								show: {
									authentication: ['serviceAccount'],
								},
							},
							testedBy: 'googleApiCredentialTest',
						},
						{
							name: 'googleSheetsOAuth2Api',
							required: true,
							displayOptions: {
								show: {
									authentication: ['oAuth2'],
								},
							},
						},
					],
					properties: [
						{
							displayName:
								'<strong>New node version available:</strong> get the latest version with added features from the nodes panel.',
							name: 'oldVersionNotice',
							type: 'notice',
							default: '',
						},
						{
							displayName: 'Authentication',
							name: 'authentication',
							type: 'options',
							options: [
								{
									name: 'Service Account',
									value: 'serviceAccount',
								},
								{
									name: 'OAuth2',
									value: 'oAuth2',
								},
							],
							default: 'serviceAccount',
							displayOptions: {
								show: {
									'@version': [1],
								},
							},
						},
						{
							displayName: 'Authentication',
							name: 'authentication',
							type: 'options',
							options: [
								{
									name: 'OAuth2 (recommended)',
									value: 'oAuth2',
								},
								{
									name: 'Service Account',
									value: 'serviceAccount',
								},
							],
							default: 'oAuth2',
							displayOptions: {
								show: {
									'@version': [2],
								},
							},
						},
						{
							displayName: 'Resource',
							name: 'resource',
							type: 'options',
							noDataExpression: true,
							options: [
								{
									name: 'Spreadsheet',
									value: 'spreadsheet',
								},
								{
									name: 'Sheet',
									value: 'sheet',
								},
							],
							default: 'sheet',
						},
						{
							displayName: 'Operation',
							name: 'operation',
							type: 'options',
							noDataExpression: true,
							displayOptions: {
								show: {
									resource: ['sheet'],
								},
							},
							options: [
								{
									name: 'Append',
									value: 'append',
									description: 'Append data to a sheet',
									action: 'Append data to a sheet',
								},
								{
									name: 'Clear',
									value: 'clear',
									description: 'Clear data from a sheet',
									action: 'Clear a sheet',
								},
								{
									name: 'Create',
									value: 'create',
									description: 'Create a new sheet',
									action: 'Create a sheet',
								},
								{
									name: 'Create or Update',
									value: 'upsert',
									description:
										'Create a new record, or update the current one if it already exists (upsert)',
									action: 'Create or update a sheet',
								},
								{
									name: 'Delete',
									value: 'delete',
									description: 'Delete columns and rows from a sheet',
									action: 'Delete a sheet',
								},
								{
									name: 'Lookup',
									value: 'lookup',
									description: 'Look up a specific column value and return the matching row',
									action: 'Look up a column value in a sheet',
								},
								{
									name: 'Read',
									value: 'read',
									description: 'Read data from a sheet',
									action: 'Read a sheet',
								},
								{
									name: 'Remove',
									value: 'remove',
									description: 'Remove a sheet',
									action: 'Remove a sheet',
								},
								{
									name: 'Update',
									value: 'update',
									description: 'Update rows in a sheet',
									action: 'Update a sheet',
								},
							],
							default: 'read',
						},
						{
							displayName: 'Spreadsheet ID',
							name: 'sheetId',
							type: 'string',
							displayOptions: {
								show: {
									resource: ['sheet'],
								},
							},
							default: '',
							required: true,
							description:
								'The ID of the Google Spreadsheet. Found as part of the sheet URL https://docs.google.com/spreadsheets/d/{ID}/.',
						},
						{
							displayName: 'Range',
							name: 'range',
							type: 'string',
							displayOptions: {
								show: {
									resource: ['sheet'],
								},
								hide: {
									operation: ['create', 'delete', 'remove'],
								},
							},
							default: 'A:F',
							required: true,
							description:
								'The table range to read from or to append data to. See the Google <a href="https://developers.google.com/sheets/api/guides/values#writing">documentation</a> for the details. If it contains multiple sheets it can also be added like this: "MySheet!A:F"',
						},
					],
				},
			},
			'4': {
				description: {
					subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
					version: [3, 4, 4.1, 4.2],
					credentials: [
						{
							displayOptions: {
								show: {
									authentication: ['serviceAccount'],
								},
							},
							name: 'googleApi',
							required: true,
							testedBy: 'googleApiCredentialTest',
						},
						{
							displayOptions: {
								show: {
									authentication: ['oAuth2'],
								},
							},
							name: 'googleSheetsOAuth2Api',
							required: true,
						},
					],
					defaults: {
						name: 'Google Sheets',
					},
					defaultVersion: 4.2,
					description: 'Read, update and write data to Google Sheets',
					displayName: 'Google Sheets',
					group: ['input', 'output'],
					icon: 'file:googleSheets.svg',
					inputs: [NodeConnectionTypes.Main],
					name: 'googleSheets',
					outputs: [NodeConnectionTypes.Main],
					properties: [
						{
							default: 'oAuth2',
							displayName: 'Authentication',
							name: 'authentication',
							options: [
								{
									name: 'Service Account',
									value: 'serviceAccount',
								},
								{
									name: 'OAuth2 (recommended)',
									value: 'oAuth2',
								},
							],
							type: 'options',
						},
						{
							default: 'sheet',
							displayName: 'Resource',
							name: 'resource',
							noDataExpression: true,
							options: [
								{
									name: 'Document',
									value: 'spreadsheet',
								},
								{
									name: 'Sheet Within Document',
									value: 'sheet',
								},
							],
							type: 'options',
						},
						{
							default: 'read',
							displayName: 'Operation',
							displayOptions: {
								show: {
									resource: ['sheet'],
								},
							},
							name: 'operation',
							noDataExpression: true,
							options: [
								{
									action: 'Append or update row in sheet',
									description: 'Append a new row or update an existing one (upsert)',
									name: 'Append or Update Row',
									value: 'appendOrUpdate',
								},
								{
									action: 'Append row in sheet',
									description: 'Create a new row in a sheet',
									name: 'Append Row',
									value: 'append',
								},
								{
									action: 'Clear sheet',
									description: 'Delete all the contents or a part of a sheet',
									name: 'Clear',
									value: 'clear',
								},
								{
									action: 'Create sheet',
									description: 'Create a new sheet',
									name: 'Create',
									value: 'create',
								},
								{
									action: 'Delete sheet',
									description: 'Permanently delete a sheet',
									name: 'Delete',
									value: 'remove',
								},
								{
									action: 'Delete rows or columns from sheet',
									description: 'Delete columns or rows from a sheet',
									name: 'Delete Rows or Columns',
									value: 'delete',
								},
								{
									action: 'Get row(s) in sheet',
									description: 'Retrieve one or more rows from a sheet',
									name: 'Get Row(s)',
									value: 'read',
								},
								{
									action: 'Update row in sheet',
									description: 'Update an existing row in a sheet',
									name: 'Update Row',
									value: 'update',
								},
							],
							type: 'options',
						},
						{
							default: {
								mode: 'list',
								value: '',
							},
							displayName: 'Document',
							displayOptions: {
								show: {
									resource: ['sheet'],
								},
							},
							modes: [
								{
									displayName: 'From List',
									name: 'list',
									type: 'list',
									typeOptions: {
										searchable: true,
										searchListMethod: 'spreadSheetsSearch',
									},
								},
								{
									displayName: 'By URL',
									extractValue: {
										regex:
											'https:\\/\\/(?:drive|docs)\\.google\\.com(?:\\/.*|)\\/d\\/([0-9a-zA-Z\\-_]+)(?:\\/.*|)',
										type: 'regex',
									},
									name: 'url',
									type: 'string',
									validation: [
										{
											properties: {
												errorMessage: 'Not a valid Google Drive File URL',
												regex:
													'https:\\/\\/(?:drive|docs)\\.google\\.com(?:\\/.*|)\\/d\\/([0-9a-zA-Z\\-_]+)(?:\\/.*|)',
											},
											type: 'regex',
										},
									],
								},
								{
									displayName: 'By ID',
									name: 'id',
									type: 'string',
									url: '=https://docs.google.com/spreadsheets/d/{{$value}}/edit',
									validation: [
										{
											properties: {
												errorMessage: 'Not a valid Google Drive File ID',
												regex: '[a-zA-Z0-9\\-_]{2,}',
											},
											type: 'regex',
										},
									],
								},
							],
							name: 'documentId',
							required: true,
							type: 'resourceLocator',
						},
						{
							default: {
								mode: 'list',
								value: '',
							},
							displayName: 'Sheet',
							displayOptions: {
								show: {
									operation: [
										'append',
										'appendOrUpdate',
										'clear',
										'delete',
										'read',
										'remove',
										'update',
									],
									resource: ['sheet'],
								},
							},
							modes: [
								{
									displayName: 'From List',
									name: 'list',
									type: 'list',
									typeOptions: {
										searchable: false,
										searchListMethod: 'sheetsSearch',
									},
								},
								{
									displayName: 'By URL',
									extractValue: {
										regex:
											'https:\\/\\/docs\\.google\\.com/spreadsheets\\/d\\/[0-9a-zA-Z\\-_]+\\/edit\\#gid=([0-9]+)',
										type: 'regex',
									},
									name: 'url',
									type: 'string',
									validation: [
										{
											properties: {
												errorMessage: 'Not a valid Sheet URL',
												regex:
													'https:\\/\\/docs\\.google\\.com/spreadsheets\\/d\\/[0-9a-zA-Z\\-_]+\\/edit\\#gid=([0-9]+)',
											},
											type: 'regex',
										},
									],
								},
								{
									displayName: 'By ID',
									name: 'id',
									type: 'string',
									validation: [
										{
											properties: {
												errorMessage: 'Not a valid Sheet ID',
												regex: '((gid=)?[0-9]{1,})',
											},
											type: 'regex',
										},
									],
								},
							],
							name: 'sheetName',
							required: true,
							type: 'resourceLocator',
							typeOptions: {
								loadOptionsDependsOn: ['documentId.value'],
							},
						},
					],
				},
			},
		},
		currentVersion: 4.2,
		description: {
			displayName: 'Google Sheets',
			name: 'googleSheets',
			icon: 'file:googleSheets.svg',
			group: ['input', 'output'],
			defaultVersion: 4.2,
			subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
			description: 'Read, update and write data to Google Sheets',
		},
		getNodeType(version: number | undefined) {
			return this.nodeVersions[Math.floor(version ?? this.currentVersion)];
		},
	},
};

const setNode: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Set',
			name: 'set',
			group: ['input'],
			version: 1,
			description: 'Sets a value',
			defaults: {
				name: 'Set',
				color: '#0000FF',
			},
			inputs: [NodeConnectionTypes.Main],
			outputs: [NodeConnectionTypes.Main],
			properties: [
				{
					displayName: 'Value1',
					name: 'value1',
					type: 'string',
					default: 'default-value1',
				},
				{
					displayName: 'Value2',
					name: 'value2',
					type: 'string',
					default: 'default-value2',
				},
			],
		},
	},
};

const codeNode: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Code',
			name: 'code',
			group: ['input'],
			version: 1,
			description: 'Code node',
			defaults: {
				name: 'Code',
				color: '#0000FF',
			},
			inputs: [NodeConnectionTypes.Main],
			outputs: [NodeConnectionTypes.Main],
			properties: [
				{
					displayName: 'Code',
					name: 'jsCode',
					type: 'string',
					default: '// placeholder',
				},
			],
		},
	},
};

const htmlNode: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'HTML',
			name: 'html',
			group: ['input'],
			version: 1,
			description: 'HTML node',
			defaults: {
				name: 'HTML',
				color: '#0000FF',
			},
			inputs: [NodeConnectionTypes.Main],
			outputs: [NodeConnectionTypes.Main],
			properties: [
				{
					displayName: 'HTML',
					name: 'html',
					type: 'string',
					default: '// placeholder',
				},
			],
		},
	},
};

const formNode: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Form',
			name: 'form',
			group: ['input'],
			version: 1,
			description: 'Form node',
			defaults: {
				name: 'Form',
				color: '#0000FF',
			},
			inputs: [NodeConnectionTypes.Main],
			outputs: [NodeConnectionTypes.Main],
			properties: [
				{
					displayName: 'Form Elements',
					name: 'formFields',
					placeholder: 'Add Form Element',
					type: 'fixedCollection',
					default: {},
					typeOptions: {
						multipleValues: true,
						sortable: true,
					},
					options: [
						{
							displayName: 'Values',
							name: 'values',
							values: [
								{
									displayName: 'Field Name',
									name: 'fieldLabel',
									type: 'string',
									default: '',
									placeholder: 'e.g. What is your name?',
									description: 'Label that appears above the input field',
									required: true,
									displayOptions: {
										hide: {
											fieldType: ['hiddenField', 'html'],
										},
									},
								},
								{
									displayName: 'Element Type',
									name: 'fieldType',
									type: 'options',
									default: 'text',
									description: 'The type of field to add to the form',
									options: [
										{
											name: 'Custom HTML',
											value: 'html',
										},
										{
											name: 'Date',
											value: 'date',
										},
										{
											name: 'Dropdown List',
											value: 'dropdown',
										},
										{
											name: 'Email',
											value: 'email',
										},
										{
											name: 'File',
											value: 'file',
										},
										{
											name: 'Hidden Field',
											value: 'hiddenField',
										},
										{
											name: 'Number',
											value: 'number',
										},
										{
											name: 'Password',
											value: 'password',
										},
										{
											name: 'Text',
											value: 'text',
										},
										{
											name: 'Textarea',
											value: 'textarea',
										},
									],
									required: true,
								},
								{
									displayName: 'Element Name',
									name: 'elementName',
									type: 'string',
									default: '',
									placeholder: 'e.g. content-section',
									description: 'Optional field. It can be used to include the html in the output.',
									displayOptions: {
										show: {
											fieldType: ['html'],
										},
									},
								},
								{
									displayName: 'Placeholder',
									name: 'placeholder',
									description: 'Sample text to display inside the field',
									type: 'string',
									default: '',
									displayOptions: {
										hide: {
											fieldType: ['dropdown', 'date', 'file', 'html', 'hiddenField'],
										},
									},
								},
								{
									displayName: 'Field Name',
									name: 'fieldName',
									description:
										'The name of the field, used in input attributes and referenced by the workflow',
									type: 'string',
									default: '',
									displayOptions: {
										show: {
											fieldType: ['hiddenField'],
										},
									},
								},
								{
									displayName: 'Field Value',
									name: 'fieldValue',
									description:
										'Input value can be set here or will be passed as a query parameter via Field Name if no value is set',
									type: 'string',
									default: '',
									displayOptions: {
										show: {
											fieldType: ['hiddenField'],
										},
									},
								},
								{
									displayName: 'Field Options',
									name: 'fieldOptions',
									placeholder: 'Add Field Option',
									description: 'List of options that can be selected from the dropdown',
									type: 'fixedCollection',
									default: { values: [{ option: '' }] },
									required: true,
									displayOptions: {
										show: {
											fieldType: ['dropdown'],
										},
									},
									typeOptions: {
										multipleValues: true,
										sortable: true,
									},
									options: [
										{
											displayName: 'Values',
											name: 'values',
											values: [
												{
													displayName: 'Option',
													name: 'option',
													type: 'string',
													default: '',
												},
											],
										},
									],
								},
								{
									displayName: 'Multiple Choice',
									name: 'multiselect',
									type: 'boolean',
									default: false,
									description:
										'Whether to allow the user to select multiple options from the dropdown list',
									displayOptions: {
										show: {
											fieldType: ['dropdown'],
										},
									},
								},
								{
									displayName: 'HTML',
									name: 'html',
									typeOptions: {
										editor: 'htmlEditor',
									},
									type: 'string',
									noDataExpression: true,
									default: '<!-- Your custom HTML here --->',
									description: 'HTML elements to display on the form page',
									hint: 'Does not accept <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code> or <code>&lt;input&gt;</code> tags',
									displayOptions: {
										show: {
											fieldType: ['html'],
										},
									},
								},
								{
									displayName: 'Multiple Files',
									name: 'multipleFiles',
									type: 'boolean',
									default: true,
									description:
										'Whether to allow the user to select multiple files from the file input or just one',
									displayOptions: {
										show: {
											fieldType: ['file'],
										},
									},
								},
								{
									displayName: 'Accepted File Types',
									name: 'acceptFileTypes',
									type: 'string',
									default: '',
									description: 'Comma-separated list of allowed file extensions',
									hint: 'Leave empty to allow all file types',
									placeholder: 'e.g. .jpg, .png',
									displayOptions: {
										show: {
											fieldType: ['file'],
										},
									},
								},
								{
									displayName:
										"The displayed date is formatted based on the locale of the user's browser",
									name: 'formatDate',
									type: 'notice',
									default: '',
									displayOptions: {
										show: {
											fieldType: ['date'],
										},
									},
								},
								{
									displayName: 'Required Field',
									name: 'requiredField',
									type: 'boolean',
									default: false,
									description:
										'Whether to require the user to enter a value for this field before submitting the form',
									displayOptions: {
										hide: {
											fieldType: ['html', 'hiddenField'],
										},
									},
								},
							],
						},
					],
				},
			],
		},
	},
};

const manualTriggerNode: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Manual Trigger',
			name: 'n8n-nodes-base.manualTrigger',
			icon: 'fa:mouse-pointer',
			group: ['trigger'],
			version: 1,
			description: 'Runs the flow on clicking a button in n8n',
			eventTriggerDescription: '',
			maxNodes: 1,
			defaults: {
				name: 'When clicking ‘Execute workflow’',
				color: '#909298',
			},
			inputs: [],
			outputs: [NodeConnectionTypes.Main],
			properties: [
				{
					displayName:
						'This node is where the workflow execution starts (when you click the ‘test’ button on the canvas).<br><br> <a data-action="showNodeCreator">Explore other ways to trigger your workflow</a> (e.g on a schedule, or a webhook)',
					name: 'notice',
					type: 'notice',
					default: '',
				},
			],
		},
	},
};

const executeWorkflowNode: LoadedClass<INodeType> = {
	type: {
		description: {
			name: 'n8n-nodes-base.executeWorkflow',
			displayName: 'Execute Sub-workflow',
			icon: 'fa:sign-in-alt',
			iconColor: 'orange-red',
			group: ['transform'],
			version: [1, 1.1, 1.2],
			subtitle: '={{"Workflow: " + $parameter["workflowId"]}}',
			description: 'Execute another workflow',
			defaults: { name: 'Execute Workflow', color: '#ff6d5a' },
			inputs: [],
			outputs: [],
			properties: [
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'hidden',
					noDataExpression: true,
					default: 'call_workflow',
					options: [{ name: 'Execute a Sub-Workflow', value: 'call_workflow' }],
				},
				{
					displayName:
						'This node is out of date. Please upgrade by removing it and adding a new one',
					name: 'outdatedVersionWarning',
					type: 'notice',
					displayOptions: { show: { '@version': [{ _cnd: { lte: 1.1 } }] } },
					default: '',
				},
				{
					displayName: 'Source',
					name: 'source',
					type: 'options',
					options: [
						{
							name: 'Database',
							value: 'database',
							description: 'Load the workflow from the database by ID',
						},
						{
							name: 'Local File',
							value: 'localFile',
							description: 'Load the workflow from a locally saved file',
						},
						{
							name: 'Parameter',
							value: 'parameter',
							description: 'Load the workflow from a parameter',
						},
						{ name: 'URL', value: 'url', description: 'Load the workflow from an URL' },
					],
					default: 'database',
					description: 'Where to get the workflow to execute from',
					displayOptions: { show: { '@version': [{ _cnd: { lte: 1.1 } }] } },
				},
				{
					displayName: 'Source',
					name: 'source',
					type: 'options',
					options: [
						{
							name: 'Database',
							value: 'database',
							description: 'Load the workflow from the database by ID',
						},
						{
							name: 'Define Below',
							value: 'parameter',
							description: 'Pass the JSON code of a workflow',
						},
					],
					default: 'database',
					description: 'Where to get the workflow to execute from',
					displayOptions: { show: { '@version': [{ _cnd: { gte: 1.2 } }] } },
				},
				{
					displayName: 'Workflow ID',
					name: 'workflowId',
					type: 'string',
					displayOptions: { show: { source: ['database'], '@version': [1] } },
					default: '',
					required: true,
					hint: 'Can be found in the URL of the workflow',
					description:
						"Note on using an expression here: if this node is set to run once with all items, they will all be sent to the <em>same</em> workflow. That workflow's ID will be calculated by evaluating the expression for the <strong>first input item</strong>.",
				},
				{
					displayName: 'Workflow',
					name: 'workflowId',
					type: 'workflowSelector',
					displayOptions: { show: { source: ['database'], '@version': [{ _cnd: { gte: 1.1 } }] } },
					default: '',
					required: true,
				},
				{
					displayName: 'Workflow Path',
					name: 'workflowPath',
					type: 'string',
					displayOptions: { show: { source: ['localFile'] } },
					default: '',
					placeholder: '/data/workflow.json',
					required: true,
					description: 'The path to local JSON workflow file to execute',
				},
				{
					displayName: 'Workflow JSON',
					name: 'workflowJson',
					type: 'json',
					typeOptions: { rows: 10 },
					displayOptions: { show: { source: ['parameter'] } },
					default: '\n\n\n',
					required: true,
					description: 'The workflow JSON code to execute',
				},
				{
					displayName: 'Workflow URL',
					name: 'workflowUrl',
					type: 'string',
					displayOptions: { show: { source: ['url'] } },
					default: '',
					placeholder: 'https://example.com/workflow.json',
					required: true,
					description: 'The URL from which to load the workflow from',
				},
				{
					displayName:
						'Any data you pass into this node will be output by the Execute Workflow Trigger. <a href="https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflow/" target="_blank">More info</a>',
					name: 'executeWorkflowNotice',
					type: 'notice',
					default: '',
					displayOptions: { show: { '@version': [{ _cnd: { lte: 1.1 } }] } },
				},
				{
					displayName: 'Workflow Inputs',
					name: 'workflowInputs',
					type: 'resourceMapper',
					noDataExpression: true,
					default: { mappingMode: 'defineBelow', value: null },
					required: true,
					typeOptions: {
						loadOptionsDependsOn: ['workflowId.value'],
						resourceMapper: {
							localResourceMapperMethod: 'loadSubWorkflowInputs',
							valuesLabel: 'Workflow Inputs',
							mode: 'map',
							fieldWords: { singular: 'input', plural: 'inputs' },
							addAllFields: true,
							multiKeyMatch: false,
							supportAutoMap: false,
							showTypeConversionOptions: true,
						},
					},
					displayOptions: {
						show: { source: ['database'], '@version': [{ _cnd: { gte: 1.2 } }] },
						hide: { workflowId: [''] },
					},
				},
				{
					displayName: 'Mode',
					name: 'mode',
					type: 'options',
					noDataExpression: true,
					options: [
						{
							name: 'Run once with all items',
							value: 'once',
							description: 'Pass all items into a single execution of the sub-workflow',
						},
						{
							name: 'Run once for each item',
							value: 'each',
							description: 'Call the sub-workflow individually for each item',
						},
					],
					default: 'once',
				},
				{
					displayName: 'Options',
					name: 'options',
					type: 'collection',
					default: {},
					placeholder: 'Add option',
					options: [
						{
							displayName: 'Wait For Sub-Workflow Completion',
							name: 'waitForSubWorkflow',
							type: 'boolean',
							default: true,
							description:
								'Whether the main workflow should wait for the sub-workflow to complete its execution before proceeding',
						},
					],
				},
			],
			hints: [
				{
					type: 'info',
					message:
						"Note on using an expression for workflow ID: if this node is set to run once with all items, they will all be sent to the <em>same</em> workflow. That workflow's ID will be calculated by evaluating the expression for the <strong>first input item</strong>.",
					displayCondition:
						'={{ $rawParameter.workflowId.startsWith("=") && $nodeVersion >= 1.2 }}',
					whenToDisplay: 'always',
					location: 'outputPane',
				},
			],
			codex: {
				categories: ['Core Nodes'],
				subcategories: { 'Core Nodes': ['Helpers', 'Flow'] },
				alias: ['n8n', 'call', 'sub', 'workflow', 'sub-workflow', 'subworkflow'],
				resources: {
					primaryDocumentation: [
						{
							url: 'https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.executeworkflow/',
						},
					],
				},
			},
		},
	},
	sourcePath: '',
};

const aiAgentNode: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'AI Agent',
			name: '@n8n/n8n-nodes-langchain.agent',
			icon: 'fa:robot',
			iconColor: 'black',
			group: ['transform'],
			version: [1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8],
			description: 'Generates an action plan and executes it. Can use external tools.',
			defaults: {
				name: 'AI Agent',
				color: '#404040',
			},
			inputs: [
				NodeConnectionTypes.Main,
				NodeConnectionTypes.AiLanguageModel,
				NodeConnectionTypes.AiTool,
				NodeConnectionTypes.AiMemory,
			],
			outputs: [NodeConnectionTypes.Main],
			properties: [],
		},
	},
};

const wikipediaTool: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Wikipedia',
			name: '@n8n/n8n-nodes-langchain.toolWikipedia',
			icon: 'file:wikipedia.svg',
			group: ['transform'],
			version: 1,
			description: 'Search in Wikipedia',
			defaults: {
				name: 'Wikipedia',
			},
			inputs: [],
			outputs: [NodeConnectionTypes.AiTool],
			properties: [],
		},
	},
};

const calculatorTool: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Calculator',
			name: '@n8n/n8n-nodes-langchain.toolCalculator',
			icon: 'fa:calculator',
			iconColor: 'black',
			group: ['transform'],
			version: 1,
			description: 'Make it easier for AI agents to perform arithmetic',
			defaults: {
				name: 'Calculator',
			},
			inputs: [],
			outputs: [NodeConnectionTypes.AiTool],
			properties: [],
		},
	},
};

const googleCalendarTool: LoadedClass<INodeType> = {
	sourcePath: '',
	type: {
		description: {
			displayName: 'Google Calendar',
			name: 'n8n-nodes-base.googleCalendarTool',
			icon: 'file:googleCalendar.svg',
			group: ['input'],
			version: [1, 1.1, 1.2, 1.3],
			subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
			description: 'Consume Google Calendar API',
			defaults: {
				name: 'Google Calendar',
			},
			inputs: [NodeConnectionTypes.Main],
			outputs: [NodeConnectionTypes.Main],
			usableAsTool: true,
			properties: [
				{ name: 'start', type: 'dateTime', displayName: 'Start', default: '' },
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					noDataExpression: true,
					displayOptions: {
						show: {
							resource: ['calendar'],
						},
					},
					options: [
						{
							name: 'Availability',
							value: 'availability',
							description: 'If a time-slot is available in a calendar',
							action: 'Get availability in a calendar',
						},
					],
					default: 'availability',
				},
				{
					displayName: 'Operation',
					name: 'operation',
					type: 'options',
					noDataExpression: true,
					displayOptions: {
						show: {
							resource: ['event'],
						},
					},
					options: [
						{
							name: 'Create',
							value: 'create',
							description: 'Add a event to calendar',
							action: 'Create an event',
						},
						{
							name: 'Delete',
							value: 'delete',
							description: 'Delete an event',
							action: 'Delete an event',
						},
						{
							name: 'Get',
							value: 'get',
							description: 'Retrieve an event',
							action: 'Get an event',
						},
						{
							name: 'Get Many',
							value: 'getAll',
							description: 'Retrieve many events from a calendar',
							action: 'Get many events',
						},
						{
							name: 'Update',
							value: 'update',
							description: 'Update an event',
							action: 'Update an event',
						},
					],
					default: 'create',
				},
				{
					displayName: 'Resource',
					name: 'resource',
					type: 'options',
					noDataExpression: true,
					options: [
						{
							name: 'Calendar',
							value: 'calendar',
						},
						{
							name: 'Event',
							value: 'event',
						},
					],
					default: 'event',
				},
			],
		},
	},
};

export class NodeTypes implements INodeTypes {
	nodeTypes: INodeTypeData = {
		'n8n-nodes-base.stickyNote': stickyNode,
		'n8n-nodes-base.set': setNode,
		'n8n-nodes-base.code': codeNode,
		'n8n-nodes-base.html': htmlNode,
		'n8n-nodes-base.form': formNode,
		'test.googleSheets': googleSheetsNode,
		'test.set': setNode,
		'n8n-nodes-base.executeWorkflow': executeWorkflowNode,
		'test.setMulti': {
			sourcePath: '',
			type: {
				description: {
					displayName: 'Set Multi',
					name: 'setMulti',
					group: ['input'],
					version: 1,
					description: 'Sets multiple values',
					defaults: {
						name: 'Set Multi',
						color: '#0000FF',
					},
					inputs: [NodeConnectionTypes.Main],
					outputs: [NodeConnectionTypes.Main],
					properties: [
						{
							displayName: 'Values',
							name: 'values',
							type: 'fixedCollection',
							typeOptions: {
								multipleValues: true,
							},
							default: {},
							options: [
								{
									name: 'string',
									displayName: 'String',
									values: [
										{
											displayName: 'Name',
											name: 'name',
											type: 'string',
											default: 'propertyName',
											placeholder: 'Name of the property to write data to.',
										},
										{
											displayName: 'Value',
											name: 'value',
											type: 'string',
											default: '',
											placeholder: 'The string value to write in the property.',
										},
									],
								},
							],
						},
					],
				},
			},
		},
		'n8n-nodes-base.manualTrigger': manualTriggerNode,
		'@n8n/n8n-nodes-langchain.agent': aiAgentNode,
		'n8n-nodes-base.googleCalendarTool': googleCalendarTool,
		'@n8n/n8n-nodes-langchain.toolCalculator': calculatorTool,
		'@n8n/n8n-nodes-langchain.toolWikipedia': wikipediaTool,
	};

	getByName(nodeType: string): INodeType | IVersionedNodeType {
		return this.nodeTypes[nodeType]?.type;
	}

	getByNameAndVersion(nodeType: string, version?: number): INodeType {
		if (this.nodeTypes[nodeType]?.type) {
			return NodeHelpers.getVersionedNodeType(this.nodeTypes[nodeType]?.type, version);
		}
		return mock<INodeType>({
			description: {
				properties: [],
				name: nodeType,
			},
		});
	}

	getKnownTypes(): IDataObject {
		throw new Error('Method not implemented.');
	}
}



================================================
FILE: packages/workflow/test/observable-object.test.ts
================================================
import type { IDataObject } from '../src/interfaces';
import * as ObservableObject from '../src/observable-object';

describe('ObservableObject', () => {
	test('should recognize that item on parent level got added (init empty)', () => {
		const testObject = ObservableObject.create({});
		expect(testObject.__dataChanged).toBeFalsy();
		testObject.a = {};
		expect(testObject.__dataChanged).toBeTruthy();

		// Make sure that "__dataChanged" does not returned as a key
		expect(Object.keys(testObject)).toEqual(['a']);
	});

	test('should not recognize that item on parent level changed if it is empty object and option "ignoreEmptyOnFirstChild" === true (init empty)', () => {
		const testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });
		expect(testObject.__dataChanged).toBeFalsy();
		testObject.a = {};
		expect(testObject.__dataChanged).toBeFalsy();
		expect(testObject.a).toEqual({});
	});

	test('should recognize that item on parent level changed if it is not empty object and option "ignoreEmptyOnFirstChild" === true (init empty)', () => {
		const testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });
		expect(testObject.__dataChanged).toBeFalsy();
		testObject.a = { b: 2 };
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a).toEqual({ b: 2 });
	});

	test('should not recognize that item on parent level changed if it is empty array and option "ignoreEmptyOnFirstChild" === true (init empty)', () => {
		const testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });
		expect(testObject.__dataChanged).toBeFalsy();
		testObject.a = [];
		expect(testObject.__dataChanged).toBeFalsy();
		expect(testObject.a).toEqual([]);
	});

	test('should recognize that item on parent level changed if it is not empty []] and option "ignoreEmptyOnFirstChild" === true (init empty)', () => {
		const testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });
		expect(testObject.__dataChanged).toBeFalsy();
		testObject.a = [1, 2];
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a).toEqual([1, 2]);
	});

	test('should recognize that item on parent level changed (init data exists)', () => {
		const testObject = ObservableObject.create({ a: 1 });
		expect(testObject.__dataChanged).toBeFalsy();
		expect(testObject.a).toEqual(1);
		testObject.a = 2;
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a).toEqual(2);
	});

	test('should recognize that array on parent level changed (init data exists)', () => {
		const testObject = ObservableObject.create({ a: [1, 2] });
		expect(testObject.__dataChanged).toBeFalsy();
		expect(testObject.a).toEqual([1, 2]);
		(testObject.a as number[]).push(3);
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a).toEqual([1, 2, 3]);
	});

	test('should recognize that item on first child level changed (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: 1 } });
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual(1);
		(testObject.a! as IDataObject).b = 2;
		expect(testObject.__dataChanged).toBeTruthy();
		expect((testObject.a! as IDataObject).b).toEqual(2);
	});

	test('should recognize that item on first child level changed if it is now empty and option "ignoreEmptyOnFirstChild" === true (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {
			ignoreEmptyOnFirstChild: true,
		});
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual(1);
		testObject.a = {};
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a).toEqual({});
	});

	test('should recognize that item on first child level changed if it is now empty and option "ignoreEmptyOnFirstChild" === false (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {
			ignoreEmptyOnFirstChild: false,
		});
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual(1);
		testObject.a = {};
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a).toEqual({});
	});

	test('should recognize that array on first child level changed (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: [1, 2] } });
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual([1, 2]);
		((testObject.a! as IDataObject).b as number[]).push(3);
		expect(testObject.__dataChanged).toBeTruthy();
		expect((testObject.a! as IDataObject).b).toEqual([1, 2, 3]);
	});

	test('should recognize that item on second child level changed (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: { c: 1 } } });
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual({ c: 1 });
		expect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(1);
		((testObject.a! as IDataObject).b! as IDataObject).c = 2;
		expect(testObject.__dataChanged).toBeTruthy();
		expect((testObject.a! as IDataObject).b).toEqual({ c: 2 });
	});

	test('should recognize that item on parent level got deleted (init data exists)', () => {
		const testObject = ObservableObject.create({ a: 1 });
		expect(testObject.__dataChanged).toBeFalsy();
		expect(testObject.a!).toEqual(1);
		delete testObject.a;
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a!).toEqual(undefined);
		expect(testObject).toEqual({});
	});

	test('should recognize that item on parent level got deleted even with and option "ignoreEmptyOnFirstChild" === true (init data exists)', () => {
		const testObject = ObservableObject.create({ a: 1 }, undefined, {
			ignoreEmptyOnFirstChild: true,
		});
		expect(testObject.__dataChanged).toBeFalsy();
		expect(testObject.a!).toEqual(1);
		delete testObject.a;
		expect(testObject.__dataChanged).toBeTruthy();
		expect(testObject.a!).toEqual(undefined);
		expect(testObject).toEqual({});
	});

	test('should recognize that item on second child level got deleted (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: { c: 1 } } });
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual({ c: 1 });
		delete (testObject.a! as IDataObject).b;
		expect(testObject.__dataChanged).toBeTruthy();
		expect((testObject.a! as IDataObject).b).toEqual(undefined);
		expect(testObject).toEqual({ a: {} });
	});

	test('should recognize that item on second child level changed with null (init data exists)', () => {
		const testObject = ObservableObject.create({ a: { b: { c: null } } });
		expect(testObject.__dataChanged).toBeFalsy();
		expect((testObject.a! as IDataObject).b).toEqual({ c: null });
		expect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(null);
		((testObject.a! as IDataObject).b! as IDataObject).c = 2;
		expect(testObject.__dataChanged).toBeTruthy();
		expect((testObject.a! as IDataObject).b).toEqual({ c: 2 });
	});

	// test('xxxxxx', () => {
	// 	const testObject = ObservableObject.create({ a: { } }, undefined, { ignoreEmptyOnFirstChild: true });
	// 	expect(testObject.__dataChanged).toBeFalsy();
	// 	expect(testObject).toEqual({ a: { b: { c: 1 } } });
	// 	((testObject.a! as DataObject).b as DataObject).c = 2;
	// 	// expect((testObject.a! as DataObject).b).toEqual({ c: 1 });
	// 	expect(testObject.__dataChanged).toBeTruthy();

	// 	// expect(testObject.a).toEqual({});

	// 	// expect((testObject.a! as DataObject).b).toEqual({ c: 1 });
	// 	// expect(((testObject.a! as DataObject).b! as DataObject).c).toEqual(1);
	// 	// ((testObject.a! as DataObject).b! as DataObject).c = 2;
	// 	// expect((testObject.a! as DataObject).b).toEqual({ c: 2 });
	// });
});



================================================
FILE: packages/workflow/test/rename-node-utils.test.ts
================================================
import { mockFn } from 'vitest-mock-extended';

import type { INode } from '../src/index';
import { renameFormFields } from '../src/node-parameters/rename-node-utils';

const makeNode = (formFieldValues: Array<Record<string, unknown>>) =>
	({
		parameters: {
			formFields: {
				values: formFieldValues,
			},
		},
	}) as unknown as INode;

const mockMapping = mockFn();

describe('renameFormFields', () => {
	beforeEach(() => {
		mockMapping.mockReset();
	});
	it.each([
		{ parameters: {} },
		{ parameters: { otherField: null } },
		{ parameters: { formFields: 'a' } },
		{ parameters: { formFields: { values: 3 } } },
		{ parameters: { formFields: { values: { newKey: true } } } },
		{ parameters: { formFields: { values: [] } } },
		{ parameters: { formFields: { values: [{ fieldType: 'json' }] } } },
		{ parameters: { formFields: { values: [{ fieldType: 'html' }] } } },
	] as unknown as INode[])('should not modify %s without formFields.values parameters', (node) => {
		renameFormFields(node, mockMapping);
		expect(mockMapping).not.toBeCalled();
	});

	it('should rename fields based on the provided mapping', () => {
		const node = makeNode([{ fieldType: 'html', html: 'some text' }]);

		renameFormFields(node, mockMapping);
		expect(mockMapping).toBeCalledWith('some text');
	});

	it('should rename multiple fields', () => {
		const node = makeNode([
			{ fieldType: 'html', html: 'some text' },
			{ fieldType: 'html', html: 'some text' },
			{ fieldType: 'html', html: 'some text' },
			{ fieldType: 'html', html: 'some text' },
			{ fieldType: 'html', html: 'some text' },
		]);

		renameFormFields(node, mockMapping);
		expect(mockMapping).toBeCalledTimes(5);
	});
});



================================================
FILE: packages/workflow/test/telemetry-helpers.test.ts
================================================
import { v5 as uuidv5, v3 as uuidv3, v4 as uuidv4, v1 as uuidv1 } from 'uuid';
import { mock } from 'vitest-mock-extended';

import { nodeTypes } from './ExpressionExtensions/helpers';
import type { NodeTypes } from './node-types';
import { STICKY_NODE_TYPE } from '../src/constants';
import { ApplicationError, ExpressionError, NodeApiError } from '../src/errors';
import type {
	INode,
	INodeTypeDescription,
	IRun,
	IRunData,
	NodeConnectionType,
	IWorkflowBase,
	INodeParameters,
} from '../src/interfaces';
import { NodeConnectionTypes } from '../src/interfaces';
import * as nodeHelpers from '../src/node-helpers';
import {
	ANONYMIZATION_CHARACTER as CHAR,
	extractLastExecutedNodeCredentialData,
	extractLastExecutedNodeStructuredOutputErrorInfo,
	generateNodesGraph,
	getDomainBase,
	getDomainPath,
	resolveAIMetrics,
	resolveVectorStoreMetrics,
	userInInstanceRanOutOfFreeAiCredits,
} from '../src/telemetry-helpers';
import { randomInt } from '../src/utils';
import { DEFAULT_EVALUATION_METRIC } from '../src/evaluation-helpers';

describe('getDomainBase should return protocol plus domain', () => {
	test('in valid URLs', () => {
		for (const url of validUrls(numericId)) {
			const { full, protocolPlusDomain } = url;
			expect(getDomainBase(full)).toBe(protocolPlusDomain);
		}
	});

	test('in malformed URLs', () => {
		for (const url of malformedUrls(numericId)) {
			const { full, protocolPlusDomain } = url;
			expect(getDomainBase(full)).toBe(protocolPlusDomain);
		}
	});
});

describe('getDomainPath should return pathname, excluding query string', () => {
	describe('anonymizing strings containing at least one number', () => {
		test('in valid URLs', () => {
			for (const url of validUrls(alphanumericId)) {
				const { full, pathname } = url;
				expect(getDomainPath(full)).toBe(pathname);
			}
		});

		test('in malformed URLs', () => {
			for (const url of malformedUrls(alphanumericId)) {
				const { full, pathname } = url;
				expect(getDomainPath(full)).toBe(pathname);
			}
		});
	});

	describe('anonymizing UUIDs', () => {
		test('in valid URLs', () => {
			for (const url of uuidUrls(validUrls)) {
				const { full, pathname } = url;
				expect(getDomainPath(full)).toBe(pathname);
			}
		});

		test('in malformed URLs', () => {
			for (const url of uuidUrls(malformedUrls)) {
				const { full, pathname } = url;
				expect(getDomainPath(full)).toBe(pathname);
			}
		});
	});

	describe('anonymizing emails', () => {
		test('in valid URLs', () => {
			for (const url of validUrls(email)) {
				const { full, pathname } = url;
				expect(getDomainPath(full)).toBe(pathname);
			}
		});

		test('in malformed URLs', () => {
			for (const url of malformedUrls(email)) {
				const { full, pathname } = url;
				expect(getDomainPath(full)).toBe(pathname);
			}
		});
	});
});

describe('generateNodesGraph', () => {
	test('should return node graph when node type is unknown', () => {
		const workflow: IWorkflowBase = {
			createdAt: new Date('2024-01-05T13:49:14.244Z'),
			updatedAt: new Date('2024-01-05T15:44:31.000Z'),
			id: 'NfV4GV9aQTifSLc2',
			name: 'My workflow 26',
			active: false,
			isArchived: false,
			nodes: [
				{
					parameters: {},
					id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
					name: 'When clicking "Execute Workflow"',
					type: 'n8n-nodes-base.manualTrigger',
					typeVersion: 1,
					position: [420, 420],
				},
				{
					parameters: {
						documentId: { __rl: true, mode: 'list', value: '' },
						sheetName: { __rl: true, mode: 'list', value: '' },
					},
					id: '266128b9-e5db-4c26-9555-185d48946afb',
					name: 'Google Sheets',
					type: 'test.unknown',
					typeVersion: 4.2,
					position: [640, 420],
				},
			],
			connections: {
				'When clicking "Execute Workflow"': {
					main: [[{ node: 'Google Sheets', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			},
			settings: { executionOrder: 'v1' },
			pinData: {},
			versionId: '70b92d94-0e9a-4b41-9976-a654df420af5',
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.manualTrigger', 'test.unknown'],
				node_connections: [{ start: '0', end: '1' }],
				nodes: {
					'0': {
						id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
						type: 'n8n-nodes-base.manualTrigger',
						version: 1,
						position: [420, 420],
					},
					'1': {
						id: '266128b9-e5db-4c26-9555-185d48946afb',
						type: 'test.unknown',
						version: 4.2,
						position: [640, 420],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'When clicking "Execute Workflow"': '0', 'Google Sheets': '1' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph when workflow is empty', () => {
		const workflow: IWorkflowBase = {
			createdAt: new Date('2024-01-05T13:49:14.244Z'),
			updatedAt: new Date('2024-01-05T15:44:31.000Z'),
			id: 'NfV4GV9aQTifSLc2',
			name: 'My workflow 26',
			active: false,
			isArchived: false,
			nodes: [],
			connections: {},
			settings: { executionOrder: 'v1' },
			pinData: {},
			versionId: '70b92d94-0e9a-4b41-9976-a654df420af5',
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: [],
				node_connections: [],
				nodes: {},
				notes: {},
				is_pinned: false,
			},
			nameIndices: {},
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph when workflow keys are not set', () => {
		const workflow: Partial<IWorkflowBase> = {};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: [],
				node_connections: [],
				nodes: {},
				notes: {},
				is_pinned: false,
			},
			nameIndices: {},
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph when node has multiple operation fields with different display options', () => {
		const workflow: IWorkflowBase = {
			createdAt: new Date('2024-01-05T13:49:14.244Z'),
			updatedAt: new Date('2024-01-05T15:44:31.000Z'),
			id: 'NfV4GV9aQTifSLc2',
			name: 'My workflow 26',
			active: false,
			isArchived: false,
			nodes: [
				{
					parameters: {},
					id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
					name: 'When clicking "Execute Workflow"',
					type: 'n8n-nodes-base.manualTrigger',
					typeVersion: 1,
					position: [420, 420],
				},
				{
					parameters: {
						documentId: { __rl: true, mode: 'list', value: '' },
						sheetName: { __rl: true, mode: 'list', value: '' },
					},
					id: '266128b9-e5db-4c26-9555-185d48946afb',
					name: 'Google Sheets',
					type: 'test.googleSheets',
					typeVersion: 4.2,
					position: [640, 420],
				},
			],
			connections: {
				'When clicking "Execute Workflow"': {
					main: [[{ node: 'Google Sheets', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			},
			settings: { executionOrder: 'v1' },
			pinData: {},
			versionId: '70b92d94-0e9a-4b41-9976-a654df420af5',
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.manualTrigger', 'test.googleSheets'],
				node_connections: [{ start: '0', end: '1' }],
				nodes: {
					'0': {
						id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
						type: 'n8n-nodes-base.manualTrigger',
						version: 1,
						position: [420, 420],
					},
					'1': {
						id: '266128b9-e5db-4c26-9555-185d48946afb',
						type: 'test.googleSheets',
						version: 4.2,
						position: [640, 420],
						operation: 'read',
						resource: 'sheet',
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'When clicking "Execute Workflow"': '0', 'Google Sheets': '1' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with stickies of default size', () => {
		const workflow: IWorkflowBase = {
			createdAt: new Date('2024-01-05T13:49:14.244Z'),
			updatedAt: new Date('2024-01-05T15:44:31.000Z'),
			id: 'NfV4GV9aQTifSLc2',
			name: 'My workflow 26',
			active: false,
			isArchived: false,
			nodes: [
				{
					parameters: {},
					id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
					name: 'When clicking "Execute Workflow"',
					type: 'n8n-nodes-base.manualTrigger',
					typeVersion: 1,
					position: [420, 420],
				},
				{
					parameters: {
						documentId: { __rl: true, mode: 'list', value: '' },
						sheetName: { __rl: true, mode: 'list', value: '' },
					},
					id: '266128b9-e5db-4c26-9555-185d48946afb',
					name: 'Google Sheets',
					type: 'test.googleSheets',
					typeVersion: 4.2,
					position: [640, 420],
				},
				{
					parameters: {
						content:
							"test\n\n## I'm a note \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)",
					},
					id: '03e85c3e-4303-4f93-8d62-e05d457e8f70',
					name: 'Sticky Note',
					type: 'n8n-nodes-base.stickyNote',
					typeVersion: 1,
					position: [240, 140],
				},
			],
			connections: {
				'When clicking "Execute Workflow"': {
					main: [[{ node: 'Google Sheets', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			},
			settings: { executionOrder: 'v1' },
			pinData: {},
			versionId: '70b92d94-0e9a-4b41-9976-a654df420af5',
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.manualTrigger', 'test.googleSheets'],
				node_connections: [{ start: '0', end: '1' }],
				nodes: {
					'0': {
						id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
						type: 'n8n-nodes-base.manualTrigger',
						version: 1,
						position: [420, 420],
					},
					'1': {
						id: '266128b9-e5db-4c26-9555-185d48946afb',
						type: 'test.googleSheets',
						version: 4.2,
						position: [640, 420],
						operation: 'read',
						resource: 'sheet',
					},
				},
				notes: { '0': { overlapping: false, position: [240, 140], height: 160, width: 240 } },
				is_pinned: false,
			},
			nameIndices: { 'When clicking "Execute Workflow"': '0', 'Google Sheets': '1' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with agent node and all prompt types when cloud telemetry is enabled', () => {
		const optionalPrompts = {
			humanMessage: 'Human message',
			systemMessage: 'System message',
			humanMessageTemplate: 'Human template',
			prefix: 'Prefix',
			suffixChat: 'Suffix Chat',
			suffix: 'Suffix',
			prefixPrompt: 'Prefix Prompt',
			suffixPrompt: 'Suffix Prompt',
		};

		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						agent: 'toolsAgent',
						text: 'Agent prompt text',
						options: {
							...optionalPrompts,
						},
					},
					id: 'agent-node-id',
					name: 'Agent Node',
					type: '@n8n/n8n-nodes-langchain.agent',
					typeVersion: 1,
					position: [100, 100],
				},
				{
					parameters: {},
					id: 'other-node-id',
					name: 'Other Node',
					type: 'n8n-nodes-base.set',
					typeVersion: 1,
					position: [200, 200],
				},
			],
			connections: {
				'Agent Node': {
					main: [[{ node: 'Other Node', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.agent', 'n8n-nodes-base.set'],
				node_connections: [{ start: '0', end: '1' }],
				nodes: {
					'0': {
						id: 'agent-node-id',
						type: '@n8n/n8n-nodes-langchain.agent',
						version: 1,
						position: [100, 100],
						agent: 'toolsAgent',
						prompts: { text: 'Agent prompt text', ...optionalPrompts },
					},
					'1': {
						id: 'other-node-id',
						type: 'n8n-nodes-base.set',
						version: 1,
						position: [200, 200],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Agent Node': '0', 'Other Node': '1' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with agent node without prompt types when cloud telemetry is disbaled', () => {
		const optionalPrompts = {
			humanMessage: 'Human message',
			systemMessage: 'System message',
			humanMessageTemplate: 'Human template',
			prefix: 'Prefix',
			suffixChat: 'Suffix Chat',
			suffix: 'Suffix',
			prefixPrompt: 'Prefix Prompt',
			suffixPrompt: 'Suffix Prompt',
		};

		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						agent: 'toolsAgent',
						text: 'Agent prompt text',
						options: {
							...optionalPrompts,
						},
					},
					id: 'agent-node-id',
					name: 'Agent Node',
					type: '@n8n/n8n-nodes-langchain.agent',
					typeVersion: 1,
					position: [100, 100],
				},
				{
					parameters: {},
					id: 'other-node-id',
					name: 'Other Node',
					type: 'n8n-nodes-base.set',
					typeVersion: 1,
					position: [200, 200],
				},
			],
			connections: {
				'Agent Node': {
					main: [[{ node: 'Other Node', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: false })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.agent', 'n8n-nodes-base.set'],
				node_connections: [{ start: '0', end: '1' }],
				nodes: {
					'0': {
						id: 'agent-node-id',
						type: '@n8n/n8n-nodes-langchain.agent',
						version: 1,
						position: [100, 100],
						agent: 'toolsAgent',
					},
					'1': {
						id: 'other-node-id',
						type: 'n8n-nodes-base.set',
						version: 1,
						position: [200, 200],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Agent Node': '0', 'Other Node': '1' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with agent tool node and prompt text when cloud telemetry is enabled', () => {
		const optionalPrompts = {
			humanMessage: 'Human message',
			systemMessage: 'System message',
			humanMessageTemplate: 'Human template',
			prefix: 'Prefix',
			suffixChat: 'Suffix Chat',
			suffix: 'Suffix',
			prefixPrompt: 'Prefix Prompt',
			suffixPrompt: 'Suffix Prompt',
		};

		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						text: 'Tool agent prompt',
						options: {
							...optionalPrompts,
						},
					},
					id: 'agent-tool-node-id',
					name: 'Agent Tool Node',
					type: '@n8n/n8n-nodes-langchain.agentTool',
					typeVersion: 1,
					position: [300, 300],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.agentTool'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'agent-tool-node-id',
						type: '@n8n/n8n-nodes-langchain.agentTool',
						version: 1,
						position: [300, 300],
						prompts: { text: 'Tool agent prompt', ...optionalPrompts },
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Agent Tool Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with openai langchain node and prompts array when cloud telemetry is enabled', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						messages: {
							values: [
								{ role: 'system', content: 'You are a helpful assistant.' },
								{ role: 'user', content: 'Hello!' },
							],
						},
					},
					id: 'openai-node-id',
					name: 'OpenAI Node',
					type: '@n8n/n8n-nodes-langchain.lmChatOpenAi',
					typeVersion: 1,
					position: [400, 400],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.lmChatOpenAi'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'openai-node-id',
						type: '@n8n/n8n-nodes-langchain.lmChatOpenAi',
						version: 1,
						position: [400, 400],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'OpenAI Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with chain summarization node and summarization prompts when cloud telemetry is enabled', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						options: {
							summarizationMethodAndPrompts: {
								values: { summaryPrompt: 'Summarize this text.' },
							},
						},
					},
					id: 'summarization-node-id',
					name: 'Summarization Node',
					type: '@n8n/n8n-nodes-langchain.chainSummarization',
					typeVersion: 1,
					position: [500, 500],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.chainSummarization'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'summarization-node-id',
						type: '@n8n/n8n-nodes-langchain.chainSummarization',
						version: 1,
						position: [500, 500],
						prompts: { summaryPrompt: 'Summarize this text.' },
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Summarization Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with langchain custom tool node and description prompt when cloud telemetry is enabled', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						description: 'Custom tool description',
					},
					id: 'custom-tool-node-id',
					name: 'Custom Tool Node',
					type: '@n8n/n8n-nodes-langchain.customTool',
					typeVersion: 1,
					position: [600, 600],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.customTool'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'custom-tool-node-id',
						type: '@n8n/n8n-nodes-langchain.customTool',
						version: 1,
						position: [600, 600],
						// prompts: { description: 'Custom tool description' },
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Custom Tool Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with chain llm node and messageValues prompts when cloud telemetry is enabled', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						messages: {
							messageValues: [
								{ role: 'system', content: 'Chain LLM system prompt.' },
								{ role: 'user', content: 'Chain LLM user prompt.' },
							],
						},
					},
					id: 'chain-llm-node-id',
					name: 'Chain LLM Node',
					type: '@n8n/n8n-nodes-langchain.chainLlm',
					typeVersion: 1,
					position: [700, 700],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['@n8n/n8n-nodes-langchain.chainLlm'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'chain-llm-node-id',
						type: '@n8n/n8n-nodes-langchain.chainLlm',
						version: 1,
						position: [700, 700],
						prompts: [
							{ role: 'system', content: 'Chain LLM system prompt.' },
							{ role: 'user', content: 'Chain LLM user prompt.' },
						],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Chain LLM Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return node graph with stickies indicating overlap', () => {
		const workflow: IWorkflowBase = {
			createdAt: new Date('2024-01-05T13:49:14.244Z'),
			updatedAt: new Date('2024-01-05T15:44:31.000Z'),
			id: 'NfV4GV9aQTifSLc2',
			name: 'My workflow 26',
			active: false,
			isArchived: false,
			nodes: [
				{
					parameters: {},
					id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
					name: 'When clicking "Execute Workflow"',
					type: 'n8n-nodes-base.manualTrigger',
					typeVersion: 1,
					position: [420, 420],
				},
				{
					parameters: {
						documentId: { __rl: true, mode: 'list', value: '' },
						sheetName: { __rl: true, mode: 'list', value: '' },
					},
					id: '266128b9-e5db-4c26-9555-185d48946afb',
					name: 'Google Sheets',
					type: 'test.googleSheets',
					typeVersion: 4.2,
					position: [640, 420],
				},
				{
					parameters: {
						content:
							"test\n\n## I'm a note \n**Double click** to edit me. [Guide](https://docs.n8n.io/workflows/sticky-notes/)",
						height: 488,
						width: 645,
					},
					id: '03e85c3e-4303-4f93-8d62-e05d457e8f70',
					name: 'Sticky Note',
					type: 'n8n-nodes-base.stickyNote',
					typeVersion: 1,
					position: [240, 140],
				},
			],
			connections: {
				'When clicking "Execute Workflow"': {
					main: [[{ node: 'Google Sheets', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			},
			settings: { executionOrder: 'v1' },
			pinData: {},
			versionId: '70b92d94-0e9a-4b41-9976-a654df420af5',
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			evaluationTriggerNodeNames: [],
			nodeGraph: {
				node_types: ['n8n-nodes-base.manualTrigger', 'test.googleSheets'],
				node_connections: [{ start: '0', end: '1' }],
				nodes: {
					'0': {
						id: 'fa7d5628-5a47-4c8f-98ef-fb3532e5a9f5',
						type: 'n8n-nodes-base.manualTrigger',
						version: 1,
						position: [420, 420],
					},
					'1': {
						id: '266128b9-e5db-4c26-9555-185d48946afb',
						type: 'test.googleSheets',
						version: 4.2,
						position: [640, 420],
						operation: 'read',
						resource: 'sheet',
					},
				},
				notes: { '0': { overlapping: true, position: [240, 140], height: 488, width: 645 } },
				is_pinned: false,
			},
			nameIndices: { 'When clicking "Execute Workflow"': '0', 'Google Sheets': '1' },
			webhookNodeNames: [],
		});
	});

	test('should return node graph indicating pinned data', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {},
					id: 'e59d3ad9-3448-4899-9f47-d2922c8727ce',
					name: 'When clicking "Execute Workflow"',
					type: 'n8n-nodes-base.manualTrigger',
					typeVersion: 1,
					position: [460, 460],
				},
			],
			connections: {},
			pinData: {
				'When clicking "Execute Workflow"': [],
			},
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nameIndices: {
				'When clicking "Execute Workflow"': '0',
			},
			nodeGraph: {
				is_pinned: true,
				node_connections: [],
				node_types: ['n8n-nodes-base.manualTrigger'],
				nodes: {
					'0': {
						id: 'e59d3ad9-3448-4899-9f47-d2922c8727ce',
						position: [460, 460],
						type: 'n8n-nodes-base.manualTrigger',
						version: 1,
					},
				},
				notes: {},
			},
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return graph with webhook node', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						path: 'bf4c0699-cff8-4440-8964-8e97fda8b4f8',
						options: {},
					},
					id: '5e49e129-2c59-4650-95ea-14d4b94db1f3',
					name: 'Webhook',
					type: 'n8n-nodes-base.webhook',
					typeVersion: 1.1,
					position: [520, 380],
					webhookId: 'bf4c0699-cff8-4440-8964-8e97fda8b4f8',
				},
			],
			connections: {},
			pinData: {},
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			evaluationTriggerNodeNames: [],
			nodeGraph: {
				node_types: ['n8n-nodes-base.webhook'],
				node_connections: [],
				nodes: {
					'0': {
						id: '5e49e129-2c59-4650-95ea-14d4b94db1f3',
						type: 'n8n-nodes-base.webhook',
						version: 1.1,
						position: [520, 380],
						response_mode: 'onReceived',
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { Webhook: '0' },
			webhookNodeNames: ['Webhook'],
		});
	});

	test('should return graph with http v4 node with generic auth', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						url: 'google.com/path/test',
						authentication: 'genericCredentialType',
						genericAuthType: 'httpBasicAuth',
						options: {},
					},
					id: '04d6e44f-09c1-454d-9225-60aeed7f022c',
					name: 'HTTP Request V4 with generic auth',
					type: 'n8n-nodes-base.httpRequest',
					typeVersion: 4.1,
					position: [780, 120],
					credentials: {
						httpBasicAuth: {
							id: 'yuuJAO2Ang5B64wd',
							name: 'Unnamed credential',
						},
					},
				},
			],
			connections: {},
			pinData: {},
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			evaluationTriggerNodeNames: [],
			nodeGraph: {
				node_types: ['n8n-nodes-base.httpRequest'],
				node_connections: [],
				nodes: {
					'0': {
						id: '04d6e44f-09c1-454d-9225-60aeed7f022c',
						type: 'n8n-nodes-base.httpRequest',
						version: 4.1,
						position: [780, 120],
						credential_type: 'httpBasicAuth',
						credential_set: true,
						domain_base: 'google.com',
						domain_path: '/path/test',
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'HTTP Request V4 with generic auth': '0' },
			webhookNodeNames: [],
		});
	});

	test('should return graph with HTTP V4 with predefined cred', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						url: 'google.com/path/test',
						authentication: 'predefinedCredentialType',
						nodeCredentialType: 'activeCampaignApi',
						options: {},
					},
					id: 'dcc4a9e1-c2c5-4d7e-aec0-2a23adabbb77',
					name: 'HTTP Request V4 with predefined cred',
					type: 'n8n-nodes-base.httpRequest',
					typeVersion: 4.1,
					position: [320, 220],
					credentials: {
						httpBasicAuth: {
							id: 'yuuJAO2Ang5B64wd',
							name: 'Unnamed credential',
						},
						activeCampaignApi: {
							id: 'SFCbnfgRBuSzRu6N',
							name: 'ActiveCampaign account',
						},
					},
				},
			],
			connections: {},
			pinData: {},
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			evaluationTriggerNodeNames: [],
			nodeGraph: {
				node_types: ['n8n-nodes-base.httpRequest'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'dcc4a9e1-c2c5-4d7e-aec0-2a23adabbb77',
						type: 'n8n-nodes-base.httpRequest',
						version: 4.1,
						position: [320, 220],
						credential_type: 'activeCampaignApi',
						credential_set: true,
						domain_base: 'google.com',
						domain_path: '/path/test',
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'HTTP Request V4 with predefined cred': '0' },
			webhookNodeNames: [],
		});
	});

	it.each([
		{
			workflow: {
				nodes: [
					{
						parameters: {
							mode: 'combineBySql',
							query: 'SELECT * FROM input1 LEFT JOIN input2 ON input1.name = input2.id',
						},
						id: 'b468b603-3e59-4515-b555-90cfebd64d47',
						name: 'Merge Node V3',
						type: 'n8n-nodes-base.merge',
						typeVersion: 3,
						position: [320, 460],
					},
				],
				connections: {},
				pinData: {},
			} as Partial<IWorkflowBase>,
			isCloudDeployment: false,
			expected: {
				nodeGraph: {
					node_types: ['n8n-nodes-base.merge'],
					node_connections: [],
					nodes: {
						'0': {
							id: 'b468b603-3e59-4515-b555-90cfebd64d47',
							type: 'n8n-nodes-base.merge',
							version: 3,
							position: [320, 460],
							operation: 'combineBySql',
						},
					},
					notes: {},
					is_pinned: false,
				},
				nameIndices: { 'Merge Node V3': '0' },
				webhookNodeNames: [],
				evaluationTriggerNodeNames: [],
			},
		},
		{
			workflow: {
				nodes: [
					{
						parameters: {
							mode: 'append',
						},
						id: 'b468b603-3e59-4515-b555-90cfebd64d47',
						name: 'Merge Node V3',
						type: 'n8n-nodes-base.merge',
						typeVersion: 3,
						position: [320, 460],
					},
				],
				connections: {},
				pinData: {},
			} as Partial<IWorkflowBase>,
			isCloudDeployment: true,
			expected: {
				nodeGraph: {
					node_types: ['n8n-nodes-base.merge'],
					node_connections: [],
					nodes: {
						'0': {
							id: 'b468b603-3e59-4515-b555-90cfebd64d47',
							type: 'n8n-nodes-base.merge',
							version: 3,
							position: [320, 460],
							operation: 'append',
						},
					},
					notes: {},
					is_pinned: false,
				},
				nameIndices: { 'Merge Node V3': '0' },
				webhookNodeNames: [],
				evaluationTriggerNodeNames: [],
			},
		},
		{
			workflow: {
				nodes: [
					{
						parameters: {
							mode: 'combineBySql',
							query: 'SELECT * FROM input1 LEFT JOIN input2 ON input1.name = input2.id',
						},
						id: 'b468b603-3e59-4515-b555-90cfebd64d47',
						name: 'Merge Node V3',
						type: 'n8n-nodes-base.merge',
						typeVersion: 3,
						position: [320, 460],
					},
				],
				connections: {},
				pinData: {},
			} as Partial<IWorkflowBase>,
			isCloudDeployment: true,
			expected: {
				nodeGraph: {
					node_types: ['n8n-nodes-base.merge'],
					node_connections: [],
					nodes: {
						'0': {
							id: 'b468b603-3e59-4515-b555-90cfebd64d47',
							type: 'n8n-nodes-base.merge',
							version: 3,
							position: [320, 460],
							operation: 'combineBySql',
							sql: 'SELECT * FROM input1 LEFT JOIN input2 ON input1.name = input2.id',
						},
					},
					notes: {},
					is_pinned: false,
				},
				nameIndices: { 'Merge Node V3': '0' },
				webhookNodeNames: [],
				evaluationTriggerNodeNames: [],
			},
		},
	])('should return graph with merge v3 node', ({ workflow, expected, isCloudDeployment }) => {
		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment })).toEqual(expected);
	});

	test('should return graph with http v1 node', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						url: 'https://google.com',
						options: {},
					},
					id: 'b468b603-3e59-4515-b555-90cfebd64d47',
					name: 'HTTP Request V1',
					type: 'n8n-nodes-base.httpRequest',
					typeVersion: 1,
					position: [320, 460],
				},
			],
			connections: {},
			pinData: {},
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.httpRequest'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'b468b603-3e59-4515-b555-90cfebd64d47',
						type: 'n8n-nodes-base.httpRequest',
						version: 1,
						position: [320, 460],
						domain: 'google.com',
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'HTTP Request V1': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should return graph with http v4 node with no parameters and no credentials', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						options: {},
					},
					id: 'd002e66f-deba-455c-9f8b-65239db453c3',
					name: 'HTTP Request v4 with defaults',
					type: 'n8n-nodes-base.httpRequest',
					typeVersion: 4.1,
					position: [600, 240],
				},
			],
			connections: {},
			pinData: {},
		};
		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.httpRequest'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'd002e66f-deba-455c-9f8b-65239db453c3',
						type: 'n8n-nodes-base.httpRequest',
						version: 4.1,
						position: [600, 240],
						credential_set: false,
						domain_base: '',
						domain_path: '',
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'HTTP Request v4 with defaults': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should support custom connections like in AI nodes', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {},
					id: 'fe69383c-e418-4f98-9c0e-924deafa7f93',
					name: 'When clicking ‘Execute workflow’',
					type: 'n8n-nodes-base.manualTrigger',
					typeVersion: 1,
					position: [540, 220],
				},
				{
					parameters: {},
					id: 'c5c374f1-6fad-46bb-8eea-ceec126b300a',
					name: 'Chain',
					type: '@n8n/n8n-nodes-langchain.chainLlm',
					typeVersion: 1,
					position: [760, 320],
				},
				{
					parameters: {
						options: {},
					},
					id: '198133b6-95dd-4f7e-90e5-e16c4cdbad12',
					name: 'Model',
					type: '@n8n/n8n-nodes-langchain.lmChatOpenAi',
					typeVersion: 1,
					position: [780, 500],
				},
			],
			connections: {
				'When clicking ‘Execute workflow’': {
					main: [
						[
							{
								node: 'Chain',
								type: NodeConnectionTypes.Main,
								index: 0,
							},
						],
					],
				},
				Model: {
					ai_languageModel: [
						[
							{
								node: 'Chain',
								type: NodeConnectionTypes.AiLanguageModel,
								index: 0,
							},
						],
					],
				},
			},
		};

		expect(generateNodesGraph(workflow, nodeTypes)).toEqual({
			nodeGraph: {
				node_types: [
					'n8n-nodes-base.manualTrigger',
					'@n8n/n8n-nodes-langchain.chainLlm',
					'@n8n/n8n-nodes-langchain.lmChatOpenAi',
				],
				node_connections: [
					{
						start: '0',
						end: '1',
					},
					{
						start: '2',
						end: '1',
					},
				],
				nodes: {
					'0': {
						id: 'fe69383c-e418-4f98-9c0e-924deafa7f93',
						type: 'n8n-nodes-base.manualTrigger',
						version: 1,
						position: [540, 220],
					},
					'1': {
						id: 'c5c374f1-6fad-46bb-8eea-ceec126b300a',
						type: '@n8n/n8n-nodes-langchain.chainLlm',
						version: 1,
						position: [760, 320],
					},
					'2': {
						id: '198133b6-95dd-4f7e-90e5-e16c4cdbad12',
						type: '@n8n/n8n-nodes-langchain.lmChatOpenAi',
						version: 1,
						position: [780, 500],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: {
				'When clicking ‘Execute workflow’': '0',
				Chain: '1',
				Model: '2',
			},
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should not fail on error to resolve a node parameter for sticky node type', () => {
		const workflow = mock<IWorkflowBase>({ nodes: [{ type: STICKY_NODE_TYPE }] });

		vi.spyOn(nodeHelpers, 'getNodeParameters').mockImplementationOnce(() => {
			throw new ApplicationError('Could not find property option');
		});

		expect(() => generateNodesGraph(workflow, nodeTypes)).not.toThrow();
	});

	test('should add run and items count', () => {
		const { workflow, runData } = generateTestWorkflowAndRunData();

		expect(generateNodesGraph(workflow, nodeTypes, { runData })).toEqual({
			nameIndices: {
				DebugHelper: '4',
				'Edit Fields': '1',
				'Edit Fields1': '2',
				'Edit Fields2': '3',
				'Execute Workflow Trigger': '0',
				Switch: '5',
			},
			nodeGraph: {
				is_pinned: false,
				node_connections: [
					{
						end: '1',
						start: '0',
					},
					{
						end: '4',
						start: '0',
					},
					{
						end: '5',
						start: '1',
					},
					{
						end: '1',
						start: '4',
					},
					{
						end: '2',
						start: '5',
					},
					{
						end: '3',
						start: '5',
					},
				],
				node_types: [
					'n8n-nodes-base.executeWorkflowTrigger',
					'n8n-nodes-base.set',
					'n8n-nodes-base.set',
					'n8n-nodes-base.set',
					'n8n-nodes-base.debugHelper',
					'n8n-nodes-base.switch',
				],
				nodes: {
					'0': {
						id: 'a2372c14-87de-42de-9f9e-1c499aa2c279',
						items_total: 1,
						position: [1000, 240],
						runs: 1,
						type: 'n8n-nodes-base.executeWorkflowTrigger',
						version: 1,
					},
					'1': {
						id: '0f7aa00e-248c-452c-8cd0-62cb55941633',
						items_total: 4,
						position: [1460, 640],
						runs: 2,
						type: 'n8n-nodes-base.set',
						version: 3.1,
					},
					'2': {
						id: '9165c185-9f1c-4ec1-87bf-76ca66dfae38',
						items_total: 4,
						position: [1860, 260],
						runs: 2,
						type: 'n8n-nodes-base.set',
						version: 3.4,
					},
					'3': {
						id: '7a915fd5-5987-4ff1-9509-06b24a0a4613',
						position: [1940, 680],
						type: 'n8n-nodes-base.set',
						version: 3.4,
					},
					'4': {
						id: '63050e7c-8ad5-4f44-8fdd-da555e40471b',
						items_total: 3,
						position: [1220, 240],
						runs: 1,
						type: 'n8n-nodes-base.debugHelper',
						version: 1,
					},
					'5': {
						id: 'fbf7525d-2d1d-4dcf-97a0-43b53d087ef3',
						items_total: 4,
						position: [1680, 640],
						runs: 2,
						type: 'n8n-nodes-base.switch',
						version: 3.2,
					},
				},
				notes: {},
			},
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should handle Evaluation node with undefined metrics - uses default predefined metric', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						operation: 'setMetrics',
						// metrics is undefined - should fall back to default metric
					},
					id: 'eval-node-id',
					name: 'Evaluation Node',
					type: 'n8n-nodes-base.evaluation',
					typeVersion: 1,
					position: [100, 100],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.evaluation'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'eval-node-id',
						type: 'n8n-nodes-base.evaluation',
						version: 1,
						position: [100, 100],
						metric_names: [DEFAULT_EVALUATION_METRIC], // Default metric
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Evaluation Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should handle Evaluation node with custom metric parameter', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						operation: 'setMetrics',
						metric: 'helpfulness',
						// metrics is undefined but metric parameter is set
					},
					id: 'eval-node-id',
					name: 'Evaluation Node',
					type: 'n8n-nodes-base.evaluation',
					typeVersion: 1,
					position: [100, 100],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.evaluation'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'eval-node-id',
						type: 'n8n-nodes-base.evaluation',
						version: 1,
						position: [100, 100],
						metric_names: ['helpfulness'], // Custom metric from parameter
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Evaluation Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});

	test('should handle Evaluation node with valid metrics assignments', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						operation: 'setMetrics',
						metrics: {
							assignments: [
								{ name: 'accuracy', value: 0.95 },
								{ name: 'precision', value: 0.87 },
								{ name: 'recall', value: 0.92 },
							],
						},
					},
					id: 'eval-node-id',
					name: 'Evaluation Node',
					type: 'n8n-nodes-base.evaluation',
					typeVersion: 1,
					position: [100, 100],
				},
			],
			connections: {},
			pinData: {},
		};

		expect(generateNodesGraph(workflow, nodeTypes, { isCloudDeployment: true })).toEqual({
			nodeGraph: {
				node_types: ['n8n-nodes-base.evaluation'],
				node_connections: [],
				nodes: {
					'0': {
						id: 'eval-node-id',
						type: 'n8n-nodes-base.evaluation',
						version: 1,
						position: [100, 100],
						metric_names: ['accuracy', 'precision', 'recall'],
					},
				},
				notes: {},
				is_pinned: false,
			},
			nameIndices: { 'Evaluation Node': '0' },
			webhookNodeNames: [],
			evaluationTriggerNodeNames: [],
		});
	});
});

describe('extractLastExecutedNodeCredentialData', () => {
	const cases: Array<[string, IRun]> = [
		['no data', mock<IRun>({ data: {} })],
		['no executionData', mock<IRun>({ data: { executionData: undefined } })],
		[
			'no nodeExecutionStack',
			mock<IRun>({ data: { executionData: { nodeExecutionStack: undefined } } }),
		],
		[
			'no node',
			mock<IRun>({
				data: { executionData: { nodeExecutionStack: [{ node: undefined }] } },
			}),
		],
		[
			'no credentials',
			mock<IRun>({
				data: { executionData: { nodeExecutionStack: [{ node: { credentials: undefined } }] } },
			}),
		],
	];

	test.each(cases)(
		'should return credentialId and credentialsType with null if %s',
		(_, runData) => {
			expect(extractLastExecutedNodeCredentialData(runData)).toBeNull();
		},
	);

	it('should return correct credentialId and credentialsType when last node executed has credential', () => {
		const runData = mock<IRun>({
			data: {
				executionData: {
					nodeExecutionStack: [{ node: { credentials: { openAiApi: { id: 'nhu-l8E4hX' } } } }],
				},
			},
		});

		expect(extractLastExecutedNodeCredentialData(runData)).toMatchObject(
			expect.objectContaining({ credentialId: 'nhu-l8E4hX', credentialType: 'openAiApi' }),
		);
	});
});

describe('userInInstanceRanOutOfFreeAiCredits', () => {
	it('should return false if could not find node credentials', () => {
		const runData = {
			status: 'error',
			mode: 'manual',
			data: {
				startData: {
					destinationNode: 'OpenAI',
					runNodeFilter: ['OpenAI'],
				},
				executionData: {
					nodeExecutionStack: [{ node: { credentials: {} } }],
				},
				resultData: {
					runData: {},
					lastNodeExecuted: 'OpenAI',
					error: new NodeApiError(
						{
							id: '1',
							typeVersion: 1,
							name: 'OpenAI',
							type: 'n8n-nodes-base.openAi',
							parameters: {},
							position: [100, 200],
						},
						{
							message: `400 - ${JSON.stringify({
								error: {
									message: 'error message',
									type: 'free_ai_credits_request_error',
									code: 200,
								},
							})}`,
							error: {
								message: 'error message',
								type: 'free_ai_credits_request_error',
								code: 200,
							},
						},
						{
							httpCode: '400',
						},
					),
				},
			},
		} as unknown as IRun;

		expect(userInInstanceRanOutOfFreeAiCredits(runData)).toBe(false);
	});

	it('should return false if could not credential type it is not openAiApi', () => {
		const runData = {
			status: 'error',
			mode: 'manual',
			data: {
				startData: {
					destinationNode: 'OpenAI',
					runNodeFilter: ['OpenAI'],
				},
				executionData: {
					nodeExecutionStack: [{ node: { credentials: { jiraApi: { id: 'nhu-l8E4hX' } } } }],
				},
				resultData: {
					runData: {},
					lastNodeExecuted: 'OpenAI',
					error: new NodeApiError(
						{
							id: '1',
							typeVersion: 1,
							name: 'OpenAI',
							type: 'n8n-nodes-base.openAi',
							parameters: {},
							position: [100, 200],
						},
						{
							message: `400 - ${JSON.stringify({
								error: {
									message: 'error message',
									type: 'free_ai_credits_request_error',
									code: 200,
								},
							})}`,
							error: {
								message: 'error message',
								type: 'free_ai_credits_request_error',
								code: 200,
							},
						},
						{
							httpCode: '400',
						},
					),
				},
			},
		} as unknown as IRun;

		expect(userInInstanceRanOutOfFreeAiCredits(runData)).toBe(false);
	});

	it('should return false if error is not NodeApiError', () => {
		const runData = {
			status: 'error',
			mode: 'manual',
			data: {
				startData: {
					destinationNode: 'OpenAI',
					runNodeFilter: ['OpenAI'],
				},
				executionData: {
					nodeExecutionStack: [{ node: { credentials: { openAiApi: { id: 'nhu-l8E4hX' } } } }],
				},
				resultData: {
					runData: {},
					lastNodeExecuted: 'OpenAI',
					error: new ExpressionError('error'),
				},
			},
		} as unknown as IRun;

		expect(userInInstanceRanOutOfFreeAiCredits(runData)).toBe(false);
	});

	it('should return false if error is not a free ai credit error', () => {
		const runData = {
			status: 'error',
			mode: 'manual',
			data: {
				startData: {
					destinationNode: 'OpenAI',
					runNodeFilter: ['OpenAI'],
				},
				executionData: {
					nodeExecutionStack: [{ node: { credentials: { openAiApi: { id: 'nhu-l8E4hX' } } } }],
				},
				resultData: {
					runData: {},
					lastNodeExecuted: 'OpenAI',
					error: new NodeApiError(
						{
							id: '1',
							typeVersion: 1,
							name: 'OpenAI',
							type: 'n8n-nodes-base.openAi',
							parameters: {},
							position: [100, 200],
						},
						{
							message: `400 - ${JSON.stringify({
								error: {
									message: 'error message',
									type: 'error_type',
									code: 200,
								},
							})}`,
							error: {
								message: 'error message',
								type: 'error_type',
								code: 200,
							},
						},
						{
							httpCode: '400',
						},
					),
				},
			},
		} as unknown as IRun;

		expect(userInInstanceRanOutOfFreeAiCredits(runData)).toBe(false);
	});

	it('should return true if the user has ran out of free AI credits', () => {
		const runData = {
			status: 'error',
			mode: 'manual',
			data: {
				startData: {
					destinationNode: 'OpenAI',
					runNodeFilter: ['OpenAI'],
				},
				executionData: {
					nodeExecutionStack: [{ node: { credentials: { openAiApi: { id: 'nhu-l8E4hX' } } } }],
				},
				resultData: {
					runData: {},
					lastNodeExecuted: 'OpenAI',
					error: new NodeApiError(
						{
							id: '1',
							typeVersion: 1,
							name: 'OpenAI',
							type: 'n8n-nodes-base.openAi',
							parameters: {},
							position: [100, 200],
						},
						{
							message: `400 - ${JSON.stringify({
								error: {
									message: 'error message',
									type: 'free_ai_credits_request_error',
									code: 400,
								},
							})}`,
							error: {
								message: 'error message',
								type: 'free_ai_credits_request_error',
								code: 400,
							},
						},
						{
							httpCode: '400',
						},
					),
				},
			},
		} as unknown as IRun;

		expect(userInInstanceRanOutOfFreeAiCredits(runData)).toBe(true);
	});
});

function validUrls(idMaker: typeof alphanumericId | typeof email, char = CHAR) {
	const firstId = idMaker();
	const secondId = idMaker();
	const firstIdObscured = char.repeat(firstId.length);
	const secondIdObscured = char.repeat(secondId.length);

	return [
		{
			full: `https://test.com/api/v1/users/${firstId}`,
			protocolPlusDomain: 'https://test.com',
			pathname: `/api/v1/users/${firstIdObscured}`,
		},
		{
			full: `https://test.com/api/v1/users/${firstId}/`,
			protocolPlusDomain: 'https://test.com',
			pathname: `/api/v1/users/${firstIdObscured}/`,
		},
		{
			full: `https://test.com/api/v1/users/${firstId}/posts/${secondId}`,
			protocolPlusDomain: 'https://test.com',
			pathname: `/api/v1/users/${firstIdObscured}/posts/${secondIdObscured}`,
		},
		{
			full: `https://test.com/api/v1/users/${firstId}/posts/${secondId}/`,
			protocolPlusDomain: 'https://test.com',
			pathname: `/api/v1/users/${firstIdObscured}/posts/${secondIdObscured}/`,
		},
		{
			full: `https://test.com/api/v1/users/${firstId}/posts/${secondId}/`,
			protocolPlusDomain: 'https://test.com',
			pathname: `/api/v1/users/${firstIdObscured}/posts/${secondIdObscured}/`,
		},
		{
			full: `https://test.com/api/v1/users?id=${firstId}`,
			protocolPlusDomain: 'https://test.com',
			pathname: '/api/v1/users',
		},
		{
			full: `https://test.com/api/v1/users?id=${firstId}&post=${secondId}`,
			protocolPlusDomain: 'https://test.com',
			pathname: '/api/v1/users',
		},
		{
			full: `https://test.com/api/v1/users/${firstId}/posts/${secondId}`,
			protocolPlusDomain: 'https://test.com',
			pathname: `/api/v1/users/${firstIdObscured}/posts/${secondIdObscured}`,
		},
	];
}

function malformedUrls(idMaker: typeof numericId | typeof email, char = CHAR) {
	const firstId = idMaker();
	const secondId = idMaker();
	const firstIdObscured = char.repeat(firstId.length);
	const secondIdObscured = char.repeat(secondId.length);

	return [
		{
			full: `test.com/api/v1/users/${firstId}/posts/${secondId}/`,
			protocolPlusDomain: 'test.com',
			pathname: `/api/v1/users/${firstIdObscured}/posts/${secondIdObscured}/`,
		},
		{
			full: `htp://test.com/api/v1/users/${firstId}/posts/${secondId}/`,
			protocolPlusDomain: 'htp://test.com',
			pathname: `/api/v1/users/${firstIdObscured}/posts/${secondIdObscured}/`,
		},
		{
			full: `test.com/api/v1/users?id=${firstId}`,
			protocolPlusDomain: 'test.com',
			pathname: '/api/v1/users',
		},
		{
			full: `test.com/api/v1/users?id=${firstId}&post=${secondId}`,
			protocolPlusDomain: 'test.com',
			pathname: '/api/v1/users',
		},
	];
}

const email = () => encodeURIComponent('test@test.com');

function uuidUrls(
	urlsMaker: typeof validUrls | typeof malformedUrls,
	baseName = 'test',
	namespaceUuid = uuidv4(),
) {
	return [
		...urlsMaker(() => uuidv5(baseName, namespaceUuid)),
		...urlsMaker(uuidv4),
		...urlsMaker(() => uuidv3(baseName, namespaceUuid)),
		...urlsMaker(uuidv1),
	];
}

function numericId(length = randomInt(1, 10)) {
	return Array.from({ length }, () => randomInt(10)).join('');
}

function alphanumericId() {
	return chooseRandomly([`john${numericId()}`, `title${numericId(1)}`, numericId()]);
}

const chooseRandomly = <T>(array: T[]) => array[randomInt(array.length)];

function generateTestWorkflowAndRunData(): { workflow: Partial<IWorkflowBase>; runData: IRunData } {
	const workflow: Partial<IWorkflowBase> = {
		nodes: [
			{
				parameters: {},
				id: 'a2372c14-87de-42de-9f9e-1c499aa2c279',
				name: 'Execute Workflow Trigger',
				type: 'n8n-nodes-base.executeWorkflowTrigger',
				typeVersion: 1,
				position: [1000, 240],
			},
			{
				parameters: {
					options: {},
				},
				id: '0f7aa00e-248c-452c-8cd0-62cb55941633',
				name: 'Edit Fields',
				type: 'n8n-nodes-base.set',
				typeVersion: 3.1,
				position: [1460, 640],
			},
			{
				parameters: {
					options: {},
				},
				id: '9165c185-9f1c-4ec1-87bf-76ca66dfae38',
				name: 'Edit Fields1',
				type: 'n8n-nodes-base.set',
				typeVersion: 3.4,
				position: [1860, 260],
			},
			{
				parameters: {
					options: {},
				},
				id: '7a915fd5-5987-4ff1-9509-06b24a0a4613',
				name: 'Edit Fields2',
				type: 'n8n-nodes-base.set',
				typeVersion: 3.4,
				position: [1940, 680],
			},
			{
				parameters: {
					category: 'randomData',
					randomDataSeed: '0',
					randomDataCount: 3,
				},
				id: '63050e7c-8ad5-4f44-8fdd-da555e40471b',
				name: 'DebugHelper',
				type: 'n8n-nodes-base.debugHelper',
				typeVersion: 1,
				position: [1220, 240],
			},
			{
				id: 'fbf7525d-2d1d-4dcf-97a0-43b53d087ef3',
				name: 'Switch',
				type: 'n8n-nodes-base.switch',
				typeVersion: 3.2,
				position: [1680, 640],
				parameters: {},
			},
		],
		connections: {
			'Execute Workflow Trigger': {
				main: [
					[
						{
							node: 'Edit Fields',
							type: 'main' as NodeConnectionType,
							index: 0,
						},
						{
							node: 'DebugHelper',
							type: 'main' as NodeConnectionType,
							index: 0,
						},
					],
				],
			},
			'Edit Fields': {
				main: [
					[
						{
							node: 'Switch',
							type: 'main' as NodeConnectionType,
							index: 0,
						},
					],
				],
			},
			DebugHelper: {
				main: [
					[
						{
							node: 'Edit Fields',
							type: 'main' as NodeConnectionType,
							index: 0,
						},
					],
				],
			},
			Switch: {
				main: [
					null,
					null,
					[
						{
							node: 'Edit Fields1',
							type: 'main' as NodeConnectionType,
							index: 0,
						},
					],
					[
						{
							node: 'Edit Fields2',
							type: 'main' as NodeConnectionType,
							index: 0,
						},
					],
				],
			},
		},
		pinData: {},
	};

	const runData: IRunData = {
		'Execute Workflow Trigger': [
			{
				hints: [],
				startTime: 1727793340927,
				executionTime: 0,
				executionIndex: 0,
				source: [],
				executionStatus: 'success',
				data: { main: [[{ json: {}, pairedItem: { item: 0 } }]] },
			},
		],
		DebugHelper: [
			{
				hints: [],
				startTime: 1727793340928,
				executionTime: 0,
				executionIndex: 1,
				source: [{ previousNode: 'Execute Workflow Trigger' }],
				executionStatus: 'success',
				data: {
					main: [
						[
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 0 },
							},
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 0 },
							},
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 0 },
							},
						],
					],
				},
			},
		],
		'Edit Fields': [
			{
				hints: [],
				startTime: 1727793340928,
				executionTime: 1,
				executionIndex: 2,
				source: [{ previousNode: 'DebugHelper' }],
				executionStatus: 'success',
				data: {
					main: [
						[
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 0 },
							},
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 1 },
							},
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 2 },
							},
						],
					],
				},
			},
			{
				hints: [],
				startTime: 1727793340931,
				executionTime: 0,
				executionIndex: 3,
				source: [{ previousNode: 'Execute Workflow Trigger' }],
				executionStatus: 'success',
				data: { main: [[{ json: {}, pairedItem: { item: 0 } }]] },
			},
		],
		Switch: [
			{
				hints: [],
				startTime: 1727793340929,
				executionTime: 1,
				executionIndex: 4,
				source: [{ previousNode: 'Edit Fields' }],
				executionStatus: 'success',
				data: {
					main: [
						[],
						[],
						[
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 0 },
							},
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 1 },
							},
							{
								json: {
									test: 'abc',
								},
								pairedItem: { item: 2 },
							},
						],
						[],
					],
				},
			},
			{
				hints: [],
				startTime: 1727793340931,
				executionTime: 0,
				executionIndex: 5,
				source: [{ previousNode: 'Edit Fields', previousNodeRun: 1 }],
				executionStatus: 'success',
				data: { main: [[], [], [{ json: {}, pairedItem: { item: 0 } }], []] },
			},
		],
		'Edit Fields1': [
			{
				hints: [],
				startTime: 1727793340930,
				executionTime: 0,
				executionIndex: 6,
				source: [{ previousNode: 'Switch', previousNodeOutput: 2 }],
				executionStatus: 'success',
				data: {
					main: [
						[
							{ json: {}, pairedItem: { item: 0 } },
							{ json: {}, pairedItem: { item: 1 } },
							{ json: {}, pairedItem: { item: 2 } },
						],
					],
				},
			},
			{
				hints: [],
				startTime: 1727793340932,
				executionTime: 1,
				executionIndex: 7,
				source: [{ previousNode: 'Switch', previousNodeOutput: 2, previousNodeRun: 1 }],
				executionStatus: 'success',
				data: { main: [[{ json: {}, pairedItem: { item: 0 } }]] },
			},
		],
	};

	return { workflow, runData };
}

describe('makeAIMetrics', () => {
	const makeNode = (parameters: object, type: string) =>
		({
			parameters,
			type,
			typeVersion: 2.1,
			id: '7cb0b373-715c-4a89-8bbb-3f238907bc86',
			name: 'a name',
			position: [0, 0],
		}) as INode;

	it('should count applicable nodes and parameters', async () => {
		const nodes = [
			makeNode(
				{
					sendTo: "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To', ``, 'string') }}",
					sendTwo: "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To', ``, 'string') }}",
					subject: "={{ $fromAI('Subject', ``, 'string') }}",
				},
				'n8n-nodes-base.gmailTool',
			),
			makeNode(
				{
					subject: "={{ $fromAI('Subject', ``, 'string') }}",
					verb: "={{ $fromAI('Verb', ``, 'string') }}",
				},
				'n8n-nodes-base.gmailTool',
			),
			makeNode(
				{
					subject: "'A Subject'",
				},
				'n8n-nodes-base.gmailTool',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['AI'],
						subcategories: { AI: ['Tools'] },
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const result = resolveAIMetrics(nodes, nodeTypes);
		expect(result).toMatchObject({
			aiNodeCount: 3,
			aiToolCount: 3,
			fromAIOverrideCount: 2,
			fromAIExpressionCount: 3,
		});
	});

	it('should not count non-applicable nodes and parameters', async () => {
		const nodes = [
			makeNode(
				{
					sendTo: 'someone',
				},
				'n8n-nodes-base.gmail',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {} as unknown as INodeTypeDescription,
			}),
		});

		const result = resolveAIMetrics(nodes, nodeTypes);
		expect(result).toMatchObject({});
	});

	it('should count ai nodes without tools', async () => {
		const nodes = [
			makeNode(
				{
					sendTo: 'someone',
				},
				'n8n-nodes-base.gmailTool',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['AI'],
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const result = resolveAIMetrics(nodes, nodeTypes);
		expect(result).toMatchObject({
			aiNodeCount: 1,
			aiToolCount: 0,
			fromAIOverrideCount: 0,
			fromAIExpressionCount: 0,
		});
	});
});

describe('resolveVectorStoreMetrics', () => {
	const makeNode = (parameters: object, type: string) =>
		({
			parameters,
			type,
			typeVersion: 1,
			id: '7cb0b373-715c-4a89-8bbb-3f238907bc86',
			name: 'a name',
			position: [0, 0],
		}) as INode;

	it('should return empty object if no vector store nodes are present', () => {
		const nodes = [
			makeNode(
				{
					mode: 'insert',
				},
				'n8n-nodes-base.nonVectorStoreNode',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['Non-AI'],
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const run = mock<IRun>({
			data: {
				resultData: {
					runData: {},
				},
			},
		});

		const result = resolveVectorStoreMetrics(nodes, nodeTypes, run);
		expect(result).toMatchObject({});
	});

	it('should detect vector store nodes that inserted data', () => {
		const nodes = [
			makeNode(
				{
					mode: 'insert',
				},
				'n8n-nodes-base.vectorStoreNode',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['AI'],
						subcategories: { AI: ['Vector Stores'] },
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const run = mock<IRun>({
			data: {
				resultData: {
					runData: {
						'a name': [
							{
								executionStatus: 'success',
							},
						],
					},
				},
			},
		});

		const result = resolveVectorStoreMetrics(nodes, nodeTypes, run);
		expect(result).toMatchObject({
			insertedIntoVectorStore: true,
			queriedDataFromVectorStore: false,
		});
	});

	it('should detect vector store nodes that queried data', () => {
		const nodes = [
			makeNode(
				{
					mode: 'retrieve',
				},
				'n8n-nodes-base.vectorStoreNode',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['AI'],
						subcategories: { AI: ['Vector Stores'] },
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const run = mock<IRun>({
			data: {
				resultData: {
					runData: {
						'a name': [
							{
								executionStatus: 'success',
							},
						],
					},
				},
			},
		});

		const result = resolveVectorStoreMetrics(nodes, nodeTypes, run);
		expect(result).toMatchObject({
			insertedIntoVectorStore: false,
			queriedDataFromVectorStore: true,
		});
	});

	it('should detect vector store nodes that both inserted and queried data', () => {
		const nodes = [
			makeNode(
				{
					mode: 'insert',
				},
				'n8n-nodes-base.vectorStoreNode',
			),
			makeNode(
				{
					mode: 'retrieve',
				},
				'n8n-nodes-base.vectorStoreNode',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['AI'],
						subcategories: { AI: ['Vector Stores'] },
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const run = mock<IRun>({
			data: {
				resultData: {
					runData: {
						'a name': [
							{
								executionStatus: 'success',
							},
						],
					},
				},
			},
		});

		const result = resolveVectorStoreMetrics(nodes, nodeTypes, run);
		expect(result).toMatchObject({
			insertedIntoVectorStore: true,
			queriedDataFromVectorStore: true,
		});
	});

	it('should return empty object if no successful executions are found', () => {
		const nodes = [
			makeNode(
				{
					mode: 'insert',
				},
				'n8n-nodes-base.vectorStoreNode',
			),
		];

		const nodeTypes = mock<NodeTypes>({
			getByNameAndVersion: () => ({
				description: {
					codex: {
						categories: ['AI'],
						subcategories: { AI: ['Vector Stores'] },
					},
				} as unknown as INodeTypeDescription,
			}),
		});

		const run = mock<IRun>({
			data: {
				resultData: {
					runData: {
						'a name': [
							{
								executionStatus: 'error',
							},
						],
					},
				},
			},
		});

		const result = resolveVectorStoreMetrics(nodes, nodeTypes, run);
		expect(result).toMatchObject({
			insertedIntoVectorStore: false,
			queriedDataFromVectorStore: false,
		});
	});
});

describe('extractLastExecutedNodeStructuredOutputErrorInfo', () => {
	const mockWorkflow = (nodes: INode[], connections?: any): IWorkflowBase => ({
		createdAt: new Date(),
		updatedAt: new Date(),
		id: 'test-workflow',
		name: 'Test Workflow',
		active: false,
		isArchived: false,
		nodes,
		connections: connections || {},
		settings: {},
		pinData: {},
		versionId: 'test-version',
	});

	const mockAgentNode = (name = 'Agent', hasOutputParser = true): INode => ({
		id: 'agent-node-id',
		name,
		type: '@n8n/n8n-nodes-langchain.agent',
		typeVersion: 1,
		position: [100, 100],
		parameters: {
			hasOutputParser,
		},
	});

	const mockLanguageModelNode = (name = 'Model', model = 'gpt-4'): INode => ({
		id: 'model-node-id',
		name,
		type: 'n8n-nodes-langchain.lmChatOpenAi',
		typeVersion: 1,
		position: [200, 200],
		parameters: {
			model,
		},
	});

	const mockToolNode = (name: string): INode => ({
		id: `tool-${name}`,
		name,
		type: 'n8n-nodes-base.httpRequestTool',
		typeVersion: 1,
		position: [300, 300],
		parameters: {},
	});

	const mockRunData = (lastNodeExecuted: string, error?: any, nodeRunData?: any): IRun => ({
		mode: 'manual',
		status: error ? 'error' : 'success',
		startedAt: new Date(),
		stoppedAt: new Date(),
		data: {
			startData: {},
			resultData: {
				lastNodeExecuted,
				error,
				runData: nodeRunData || {},
			},
		} as any,
	});

	it('should return empty object when there is no error', () => {
		const workflow = mockWorkflow([mockAgentNode()]);
		const runData = mockRunData('Agent');

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({});
	});

	it('should return empty object when lastNodeExecuted is not defined', () => {
		const workflow = mockWorkflow([mockAgentNode()]);
		const runData = mockRunData('', new Error('Some error'));

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({});
	});

	it('should return empty object when last executed node is not found in workflow', () => {
		const workflow = mockWorkflow([mockAgentNode('Agent')]);
		const runData = mockRunData('NonExistentNode', new Error('Some error'));

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({});
	});

	it('should return empty object when last executed node is not an agent node', () => {
		const workflow = mockWorkflow([mockLanguageModelNode('Model')]);
		const runData = mockRunData('Model', new Error('Some error'));

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({});
	});

	it('should return empty object when agent node does not have output parser', () => {
		const workflow = mockWorkflow([mockAgentNode('Agent', false)]);
		const runData = mockRunData('Agent', new Error('Some error'));

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({});
	});

	it('should return error info without output parser fail reason when error is not output parser error', () => {
		const workflow = mockWorkflow([mockAgentNode()]);
		const runData = mockRunData('Agent', new Error('Different error'), {
			Agent: [
				{
					error: {
						message: 'Some other error',
					},
				},
			],
		});

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			num_tools: 0,
		});
	});

	it('should return error info with output parser fail reason', () => {
		const workflow = mockWorkflow([mockAgentNode()]);
		const runData = mockRunData('Agent', new Error('Some error'), {
			Agent: [
				{
					error: {
						message: "Model output doesn't fit required format",
						context: {
							outputParserFailReason: 'Failed to parse JSON output',
						},
					},
				},
			],
		});

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			output_parser_fail_reason: 'Failed to parse JSON output',
			num_tools: 0,
		});
	});

	it('should count connected tools correctly', () => {
		const agentNode = mockAgentNode();
		const tool1 = mockToolNode('Tool1');
		const tool2 = mockToolNode('Tool2');
		const workflow = mockWorkflow([agentNode, tool1, tool2], {
			Tool1: {
				[NodeConnectionTypes.AiTool]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
				],
			},
			Tool2: {
				[NodeConnectionTypes.AiTool]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
				],
			},
		});
		const runData = mockRunData('Agent', new Error('Some error'));

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			num_tools: 2,
		});
	});

	it('should extract model name from connected language model node', () => {
		const agentNode = mockAgentNode();
		const modelNode = mockLanguageModelNode('OpenAI Model', 'gpt-4-turbo');
		const workflow = mockWorkflow([agentNode, modelNode], {
			'OpenAI Model': {
				[NodeConnectionTypes.AiLanguageModel]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiLanguageModel, index: 0 }],
				],
			},
		});
		const runData = mockRunData('Agent', new Error('Some error'));
		vi.spyOn(nodeHelpers, 'getNodeParameters').mockReturnValueOnce(
			mock<INodeParameters>({ model: { value: 'gpt-4-turbo' } }),
		);

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			num_tools: 0,
			model_name: 'gpt-4-turbo',
		});
	});

	it('should handle complete scenario with tools, model, and output parser error', () => {
		const agentNode = mockAgentNode();
		const modelNode = mockLanguageModelNode('OpenAI Model', 'gpt-4');
		const tool1 = mockToolNode('HTTPTool');
		const tool2 = mockToolNode('SlackTool');
		const tool3 = mockToolNode('GoogleSheetsTool');

		const workflow = mockWorkflow([agentNode, modelNode, tool1, tool2, tool3], {
			'OpenAI Model': {
				[NodeConnectionTypes.AiLanguageModel]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiLanguageModel, index: 0 }],
				],
			},
			HTTPTool: {
				[NodeConnectionTypes.AiTool]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
				],
			},
			SlackTool: {
				[NodeConnectionTypes.AiTool]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
				],
			},
			GoogleSheetsTool: {
				[NodeConnectionTypes.AiTool]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
				],
			},
		});

		const runData = mockRunData('Agent', new Error('Workflow error'), {
			Agent: [
				{
					error: {
						message: "Model output doesn't fit required format",
						context: {
							outputParserFailReason: 'Invalid JSON structure: Expected object, got string',
						},
					},
				},
			],
		});

		vi.spyOn(nodeHelpers, 'getNodeParameters').mockReturnValueOnce(
			mock<INodeParameters>({ model: { value: 'gpt-4.1-mini' } }),
		);

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			output_parser_fail_reason: 'Invalid JSON structure: Expected object, got string',
			num_tools: 3,
			model_name: 'gpt-4.1-mini',
		});
	});

	it('should pick correct model when workflow has multiple model nodes but only one connected to agent', () => {
		const agentNode = mockAgentNode();
		const connectedModel = mockLanguageModelNode('Connected Model', 'gpt-4');
		const unconnectedModel = mockLanguageModelNode('Unconnected Model', 'claude-3');

		const workflow = mockWorkflow([agentNode, connectedModel, unconnectedModel], {
			'Connected Model': {
				[NodeConnectionTypes.AiLanguageModel]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiLanguageModel, index: 0 }],
				],
			},
			// Unconnected Model is not connected to anything
		});

		const runData = mockRunData('Agent', new Error('Some error'));

		vi.spyOn(nodeHelpers, 'getNodeParameters').mockReturnValueOnce(
			mock<INodeParameters>({ model: 'gpt-4' }),
		);

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			num_tools: 0,
			model_name: 'gpt-4',
		});
	});

	it('should only count tools connected to the agent when workflow has multiple tool nodes', () => {
		const agentNode = mockAgentNode();
		const connectedTool1 = mockToolNode('ConnectedTool1');
		const connectedTool2 = mockToolNode('ConnectedTool2');
		const unconnectedTool1 = mockToolNode('UnconnectedTool1');
		const unconnectedTool2 = mockToolNode('UnconnectedTool2');
		const someOtherNode: INode = {
			id: 'other-node',
			name: 'SomeOtherNode',
			type: 'n8n-nodes-base.set',
			typeVersion: 1,
			position: [400, 400],
			parameters: {},
		};

		const workflow = mockWorkflow(
			[
				agentNode,
				connectedTool1,
				connectedTool2,
				unconnectedTool1,
				unconnectedTool2,
				someOtherNode,
			],
			{
				ConnectedTool1: {
					[NodeConnectionTypes.AiTool]: [
						[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
					],
				},
				ConnectedTool2: {
					[NodeConnectionTypes.AiTool]: [
						[{ node: 'Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
					],
				},
				// UnconnectedTool1 and UnconnectedTool2 are connected to SomeOtherNode, not to Agent
				UnconnectedTool1: {
					[NodeConnectionTypes.AiTool]: [
						[{ node: 'SomeOtherNode', type: NodeConnectionTypes.AiTool, index: 0 }],
					],
				},
				UnconnectedTool2: {
					[NodeConnectionTypes.AiTool]: [
						[{ node: 'SomeOtherNode', type: NodeConnectionTypes.AiTool, index: 0 }],
					],
				},
			},
		);

		const runData = mockRunData('Agent', new Error('Some error'));

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			num_tools: 2, // Only ConnectedTool1 and ConnectedTool2
		});
	});

	it('should extract model name from modelName parameter when model parameter is not present', () => {
		const agentNode = mockAgentNode();
		const modelNode: INode = {
			id: 'model-node-id',
			name: 'Google Gemini Model',
			type: 'n8n-nodes-langchain.lmChatGoogleGemini',
			typeVersion: 1,
			position: [200, 200],
			parameters: {
				// Using modelName instead of model
				modelName: 'gemini-1.5-pro',
			},
		};
		const workflow = mockWorkflow([agentNode, modelNode], {
			'Google Gemini Model': {
				[NodeConnectionTypes.AiLanguageModel]: [
					[{ node: 'Agent', type: NodeConnectionTypes.AiLanguageModel, index: 0 }],
				],
			},
		});
		const runData = mockRunData('Agent', new Error('Some error'));

		vi.spyOn(nodeHelpers, 'getNodeParameters').mockReturnValueOnce(
			mock<INodeParameters>({ modelName: 'gemini-1.5-pro' }),
		);

		const result = extractLastExecutedNodeStructuredOutputErrorInfo(workflow, nodeTypes, runData);
		expect(result).toEqual({
			num_tools: 0,
			model_name: 'gemini-1.5-pro',
		});
	});

	it('should capture Agent node streaming parameters', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						agent: 'toolsAgent',
						options: {
							enableStreaming: false,
						},
					},
					id: 'agent-id-streaming-disabled',
					name: 'Agent with streaming disabled',
					type: '@n8n/n8n-nodes-langchain.agent',
					typeVersion: 2.1,
					position: [100, 100],
				},
				{
					parameters: {
						agent: 'conversationalAgent',
						options: {
							enableStreaming: true,
						},
					},
					id: 'agent-id-streaming-enabled',
					name: 'Agent with streaming enabled',
					type: '@n8n/n8n-nodes-langchain.agent',
					typeVersion: 2.1,
					position: [300, 100],
				},
				{
					parameters: {
						agent: 'openAiFunctionsAgent',
					},
					id: 'agent-id-default-streaming',
					name: 'Agent with default streaming',
					type: '@n8n/n8n-nodes-langchain.agent',
					typeVersion: 2.1,
					position: [500, 100],
				},
			],
			connections: {},
		};

		const result = generateNodesGraph(workflow, nodeTypes);

		expect(result.nodeGraph.nodes['0']).toEqual({
			id: 'agent-id-streaming-disabled',
			type: '@n8n/n8n-nodes-langchain.agent',
			version: 2.1,
			position: [100, 100],
			agent: 'toolsAgent',
			is_streaming: false,
		});

		expect(result.nodeGraph.nodes['1']).toEqual({
			id: 'agent-id-streaming-enabled',
			type: '@n8n/n8n-nodes-langchain.agent',
			version: 2.1,
			position: [300, 100],
			agent: 'conversationalAgent',
			is_streaming: true,
		});

		expect(result.nodeGraph.nodes['2']).toEqual({
			id: 'agent-id-default-streaming',
			type: '@n8n/n8n-nodes-langchain.agent',
			version: 2.1,
			position: [500, 100],
			agent: 'openAiFunctionsAgent',
			is_streaming: true,
		});
	});

	it('should capture Chat Trigger node streaming parameters', () => {
		const workflow: Partial<IWorkflowBase> = {
			nodes: [
				{
					parameters: {
						public: true,
						options: {
							responseMode: 'streaming',
						},
					},
					id: 'chat-trigger-id',
					name: 'Chat Trigger',
					type: '@n8n/n8n-nodes-langchain.chatTrigger',
					typeVersion: 1,
					position: [100, 100],
				},
				{
					parameters: {
						public: false,
						options: {
							responseMode: 'lastNode',
						},
					},
					id: 'chat-trigger-id-2',
					name: 'Chat Trigger 2',
					type: '@n8n/n8n-nodes-langchain.chatTrigger',
					typeVersion: 1,
					position: [300, 100],
				},
			],
			connections: {},
		};

		const result = generateNodesGraph(workflow, nodeTypes);

		expect(result.nodeGraph.nodes['0']).toEqual({
			id: 'chat-trigger-id',
			type: '@n8n/n8n-nodes-langchain.chatTrigger',
			version: 1,
			position: [100, 100],
			response_mode: 'streaming',
			public_chat: true,
		});

		expect(result.nodeGraph.nodes['1']).toEqual({
			id: 'chat-trigger-id-2',
			type: '@n8n/n8n-nodes-langchain.chatTrigger',
			version: 1,
			position: [300, 100],
			response_mode: 'lastNode',
			public_chat: false,
		});
	});
});



================================================
FILE: packages/workflow/test/tool-helpers.test.ts
================================================
import type { INode } from '../src/interfaces';
import { nodeNameToToolName } from '../src/tool-helpers';

describe('nodeNameToToolName', () => {
	const getNodeWithName = (name: string): INode => ({
		id: 'test-node',
		name,
		type: 'test',
		typeVersion: 1,
		position: [0, 0] as [number, number],
		parameters: {},
	});

	it('should replace spaces with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test Node'))).toBe('Test_Node');
	});

	it('should replace dots with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test.Node'))).toBe('Test_Node');
	});

	it('should replace question marks with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test?Node'))).toBe('Test_Node');
	});

	it('should replace exclamation marks with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test!Node'))).toBe('Test_Node');
	});

	it('should replace equals signs with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test=Node'))).toBe('Test_Node');
	});

	it('should replace multiple special characters with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test.Node?With!Special=Chars'))).toBe(
			'Test_Node_With_Special_Chars',
		);
	});

	it('should handle names that already have underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test_Node'))).toBe('Test_Node');
	});

	it('should handle names with consecutive special characters', () => {
		expect(nodeNameToToolName(getNodeWithName('Test..!!??==Node'))).toBe('Test_Node');
	});

	it('should replace various special characters with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test#+*()[]{}:;,<>/\\\'"%$Node'))).toBe('Test_Node');
	});

	it('should replace emojis with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('Test 😀 Node'))).toBe('Test_Node');
	});

	it('should replace multiple emojis with underscores', () => {
		expect(nodeNameToToolName(getNodeWithName('🚀 Test 📊 Node 🎉'))).toBe('_Test_Node_');
	});

	it('should handle complex emoji sequences', () => {
		expect(nodeNameToToolName(getNodeWithName('Test 👨‍💻 Node 🔥'))).toBe('Test_Node_');
	});

	describe('when passed a string directly', () => {
		it('should replace spaces with underscores', () => {
			expect(nodeNameToToolName('Test Node')).toBe('Test_Node');
		});

		it('should replace dots with underscores', () => {
			expect(nodeNameToToolName('Test.Node')).toBe('Test_Node');
		});

		it('should replace multiple special characters with underscores', () => {
			expect(nodeNameToToolName('Test.Node?With!Special=Chars')).toBe(
				'Test_Node_With_Special_Chars',
			);
		});

		it('should handle consecutive special characters', () => {
			expect(nodeNameToToolName('Test..!!??==Node')).toBe('Test_Node');
		});

		it('should replace various special characters with underscores', () => {
			expect(nodeNameToToolName('Test#+*()[]{}:;,<>/\\\'"%$Node')).toBe('Test_Node');
		});
	});
});



================================================
FILE: packages/workflow/test/type-validation.test.ts
================================================
import { DateTime, Settings } from 'luxon';

import { getValueDescription, tryToParseDateTime, validateFieldType } from '../src/type-validation';

describe('Type Validation', () => {
	describe('string-alphanumeric', () => {
		test('should validate and parse alphanumeric strings, not starting with a number', () => {
			const VALID_STRINGS = ['abc123', 'ABC123', 'abc_123', '_abc123', 'abcABC123_'];
			VALID_STRINGS.forEach((value) =>
				expect(validateFieldType('string', value, 'string-alphanumeric')).toEqual({
					valid: true,
					newValue: value,
				}),
			);
		});

		test('should not validate non-alphanumeric strings, or starting with a number', () => {
			const INVALID_STRINGS = [
				'abc-123',
				'abc 123',
				'abc@123',
				'abc#123',
				'abc.123',
				'abc$123',
				'abc&123',
				'abc!123',
				'abc(123)',
				'bπc123',
				'πι',
				'123abc', // Cannot start with number
				'456_abc', // Cannot start with number
			];
			INVALID_STRINGS.forEach((value) =>
				expect(validateFieldType('string', value, 'string-alphanumeric').valid).toBe(false),
			);
		});
	});
	describe('Dates', () => {
		test('should validate and cast ISO dates', () => {
			const VALID_ISO_DATES = [
				'1994-11-05T08:15:30-05:00',
				'1994-11-05T13:15:30Z',
				'1997-07-16T19:20+01:00',
				'1997-07-16T19:20:30+01:00',
				'1997-07-16T19:20:30.45+01:00',
				'2018-05-16',
				'1972-06-30T23:59:40Z',
				'2019-03-26T14:00:00.9Z',
				'2019-03-26T14:00:00.4999Z',
				'2023-05-17T10:52:32+0000',
				'2023-05-17T10:52:32+0000',
			];
			VALID_ISO_DATES.forEach((date) =>
				expect(validateFieldType('date', date, 'dateTime')).toEqual({
					valid: true,
					newValue: expect.any(DateTime),
				}),
			);
		});

		test('should validate and cast RFC2822 dates', () => {
			const VALID_RFC_DATES = [
				'Tue, 04 Jun 2013 07:40:03 -0400',
				'Tue, 4 Jun 2013 02:24:39 +0530',
				'Wed, 17 May 2023 10:52:32 +0000',
			];
			VALID_RFC_DATES.forEach((date) =>
				expect(validateFieldType('date', date, 'dateTime')).toEqual({
					valid: true,
					newValue: expect.any(DateTime),
				}),
			);
		});

		test('should validate and cast HTTP dates', () => {
			const VALID_HTTP_DATES = [
				'Wed, 21 Oct 2015 07:28:00 GMT',
				'Wed, 01 Jun 2022 08:00:00 GMT',
				'Tue, 15 Nov 1994 12:45:26 GMT',
				'Wed, 1 Jun 2022 08:00:00 GMT',
			];
			VALID_HTTP_DATES.forEach((date) =>
				expect(validateFieldType('date', date, 'dateTime')).toEqual({
					valid: true,
					newValue: expect.any(DateTime),
				}),
			);
		});

		test('should validate and cast SQL dates', () => {
			const VALID_SQL_DATES = ['2008-11-11', '2008-11-11 13:23:44'];
			VALID_SQL_DATES.forEach((date) =>
				expect(validateFieldType('date', date, 'dateTime')).toEqual({
					valid: true,
					newValue: expect.any(DateTime),
				}),
			);
		});

		test('should validate and cast other valid dates', () => {
			const OTHER_VALID_DATES = [
				'Wed, 17 May 2023 10:52:32',
				'SMT, 17 May 2023 10:52:32',
				'1-Feb-2024',
				new Date(),
				DateTime.now(),
			];
			OTHER_VALID_DATES.forEach((date) =>
				expect(validateFieldType('date', date, 'dateTime')).toEqual({
					valid: true,
					newValue: expect.any(DateTime),
				}),
			);
		});

		test('should not validate invalid dates', () => {
			const INVALID_DATES = [
				'1994-11-05M08:15:30-05:00',
				'18-05-2020',
				'',
				'1685084980', // We are not supporting timestamps
				'1685085012135',
				1685084980,
				1685085012135,
				true,
				[],
			];
			INVALID_DATES.forEach((date) =>
				expect(validateFieldType('date', date, 'dateTime').valid).toBe(false),
			);
		});
	});

	it('should validate boolean values properly', () => {
		const TRUE_VALUES = ['true', 'TRUE', 1, '1', '01'];
		TRUE_VALUES.forEach((value) =>
			expect(validateFieldType('boolean', value, 'boolean')).toEqual({
				valid: true,
				newValue: true,
			}),
		);

		const FALSE_VALUES = ['false', 'FALSE', 0, '0', '000', '0000'];
		FALSE_VALUES.forEach((value) =>
			expect(validateFieldType('boolean', value, 'boolean')).toEqual({
				valid: true,
				newValue: false,
			}),
		);
	});

	it('should not validate invalid boolean values', () => {
		const INVALID_VALUES = ['tru', 'fals', 1111, 2, -1, 'yes', 'no'];
		INVALID_VALUES.forEach((value) =>
			expect(validateFieldType('boolean', value, 'boolean').valid).toEqual(false),
		);
	});

	it('should validate and cast numbers', () => {
		const VALID_NUMBERS = [
			['1', 1],
			['-1', -1],
			['1.1', 1.1],
			['-1.1', -1.1],
			[1, 1],
			[true, 1],
		];
		VALID_NUMBERS.forEach(([value, expected]) =>
			expect(validateFieldType('number', value, 'number')).toEqual({
				valid: true,
				newValue: expected,
			}),
		);

		const INVALID_NUMBERS = ['A', '1,1', '1972-06-30T23:59:40Z', [1, 2]];
		INVALID_NUMBERS.forEach((value) =>
			expect(validateFieldType('number', value, 'number').valid).toEqual(false),
		);
	});

	it('should validate and cast JSON & JS objects properly', () => {
		const VALID_OBJECTS = [
			['{"a": 1}', { a: 1 }],
			['{a: 1}', { a: 1 }],
			["{'a': '1'}", { a: '1' }],
			["{'\\'single quoted\\' \"double quoted\"': 1}", { '\'single quoted\' "double quoted"': 1 }],
			['{"a": 1, "b": { "c": 10, "d": "test"}}', { a: 1, b: { c: 10, d: 'test' } }],
			["{\"a\": 1, b: { 'c': 10, d: 'test'}}", { a: 1, b: { c: 10, d: 'test' } }],
			[{ name: 'John' }, { name: 'John' }],
			[
				{ name: 'John', address: { street: 'Via Roma', city: 'Milano' } },
				{ name: 'John', address: { street: 'Via Roma', city: 'Milano' } },
			],
		];
		VALID_OBJECTS.forEach(([value, expected]) =>
			expect(validateFieldType('json', value, 'object')).toEqual({
				valid: true,
				newValue: expected,
			}),
		);

		const INVALID_OBJECTS = [
			['one', 'two'],
			'1',
			'[1]',
			'1.1',
			1.1,
			'"a"',
			'["apples", "oranges"]',
			[{ name: 'john' }, { name: 'bob' }],
			'[ { name: "john" }, { name: "bob" } ]',
		];
		INVALID_OBJECTS.forEach((value) =>
			expect(validateFieldType('json', value, 'object').valid).toEqual(false),
		);
	});

	it('should validate and cast arrays properly', () => {
		const VALID_ARRAYS = [
			['["apples", "oranges"]', ['apples', 'oranges']],
			['[1]', [1]],
			['[1, 2]', [1, 2]],
		];
		VALID_ARRAYS.forEach(([value, expected]) =>
			expect(validateFieldType('array', value, 'array')).toEqual({
				valid: true,
				newValue: expected,
			}),
		);

		const INVALID_ARRAYS = [
			'"apples", "oranges"',
			'1',
			'1.1',
			'1, 2',
			'1. 2. 3',
			'[1, 2, 3',
			'1, 2, 3]',
			'{1, 2, {3, 4}, 5}',
			'1, 2, {3, 4}, 5',
			{ name: 'John' },
		];
		INVALID_ARRAYS.forEach((value) =>
			expect(validateFieldType('array', value, 'array').valid).toEqual(false),
		);
	});

	it('should validate options properly', () => {
		expect(
			validateFieldType('options', 'oranges', 'options', {
				valueOptions: [
					{ name: 'apples', value: 'apples' },
					{ name: 'oranges', value: 'oranges' },
				],
			}).valid,
		).toEqual(true);
		expect(
			validateFieldType('options', 'something else', 'options', {
				valueOptions: [
					{ name: 'apples', value: 'apples' },
					{ name: 'oranges', value: 'oranges' },
				],
			}).valid,
		).toEqual(false);
	});

	it('should validate and cast time properly', () => {
		const VALID_TIMES = [
			['23:23', '23:23'],
			['23:23:23', '23:23:23'],
			['23:23:23+1000', '23:23:23+1000'],
			['23:23:23-1000', '23:23:23-1000'],
			['22:00:00+01:00', '22:00:00+01:00'],
			['22:00:00-01:00', '22:00:00-01:00'],
			['22:00:00+01', '22:00:00+01'],
			['22:00:00-01', '22:00:00-01'],
		];
		VALID_TIMES.forEach(([value, expected]) =>
			expect(validateFieldType('time', value, 'time')).toEqual({
				valid: true,
				newValue: expected,
			}),
		);

		const INVALID_TIMES = ['23:23:23:23', '23', 'foo', '23:23:', '23::23::23'];
		INVALID_TIMES.forEach((value) =>
			expect(validateFieldType('time', value, 'time').valid).toEqual(false),
		);
	});

	describe('options', () => {
		describe('strict=true', () => {
			it('should not convert/cast types', () => {
				const options = { strict: true };
				expect(validateFieldType('test', '42', 'number', options).valid).toBe(false);
				expect(validateFieldType('test', 'true', 'boolean', options).valid).toBe(false);
				expect(validateFieldType('test', [], 'object', options).valid).toBe(false);
			});
		});

		describe('parseStrings=true', () => {
			it('should parse strings from other types', () => {
				const options = { parseStrings: true };
				expect(validateFieldType('test', 42, 'string')).toEqual({ valid: true, newValue: 42 });
				expect(validateFieldType('test', 42, 'string', options)).toEqual({
					valid: true,
					newValue: '42',
				});
				expect(validateFieldType('test', true, 'string', options)).toEqual({
					valid: true,
					newValue: 'true',
				});
			});
		});
	});
	describe('getValueDescription util function', () => {
		it('should return correct description', () => {
			expect(getValueDescription('foo')).toBe("'foo'");
			expect(getValueDescription(42)).toBe("'42'");
			expect(getValueDescription(true)).toBe("'true'");
			expect(getValueDescription(null)).toBe("'null'");
			expect(getValueDescription(undefined)).toBe("'undefined'");
			expect(getValueDescription([{}])).toBe('array');
			expect(getValueDescription({})).toBe('object');
		});
	});

	describe('tryToParseDateTime', () => {
		it('should NOT use defaultZone if set', () => {
			const result = tryToParseDateTime('2025-04-17T06:22:20-04:00', 'Europe/Brussels');

			expect(result.zoneName).toEqual('UTC-4');
			expect(result.toISO()).toEqual('2025-04-17T06:22:20.000-04:00');
		});

		it('should use defaultZone if timezone is not set', () => {
			const result = tryToParseDateTime('2025-04-17T06:22:20', 'Europe/Brussels');

			expect(result.zoneName).toEqual('Europe/Brussels');
			expect(result.toISO()).toEqual('2025-04-17T06:22:20.000+02:00');
		});

		it('should use the system timezone when defaultZone arg is not given', () => {
			Settings.defaultZone = 'UTC-7';
			const result = tryToParseDateTime('2025-04-17T06:22:20');

			expect(result.zoneName).toEqual('UTC-7');
			expect(result.toISO()).toEqual('2025-04-17T06:22:20.000-07:00');
		});

		it('should not impact DateTime zone', () => {
			const dateTime = DateTime.fromObject(
				{ year: 2025, month: 1, day: 1 },
				{ zone: 'Asia/Tokyo' },
			);
			const result = tryToParseDateTime(dateTime, 'Europe/Brussels');

			expect(result.zoneName).toEqual('Asia/Tokyo');
			expect(result.toISO()).toEqual('2025-01-01T00:00:00.000+09:00');
		});
	});
});



================================================
FILE: packages/workflow/test/utils.test.ts
================================================
import { ALPHABET } from '../src/constants';
import { ApplicationError } from '@n8n/errors';
import { ExecutionCancelledError } from '../src/errors/execution-cancelled.error';
import {
	jsonParse,
	jsonStringify,
	deepCopy,
	isDomainAllowed,
	isObjectEmpty,
	fileTypeFromMimeType,
	randomInt,
	randomString,
	hasKey,
	isSafeObjectProperty,
	setSafeObjectProperty,
	sleepWithAbort,
} from '../src/utils';

describe('isObjectEmpty', () => {
	it('should handle null and undefined', () => {
		expect(isObjectEmpty(null)).toEqual(true);
		expect(isObjectEmpty(undefined)).toEqual(true);
	});

	it('should handle arrays', () => {
		expect(isObjectEmpty([])).toEqual(true);
		expect(isObjectEmpty([1, 2, 3])).toEqual(false);
	});

	it('should handle Set and Map', () => {
		expect(isObjectEmpty(new Set())).toEqual(true);
		expect(isObjectEmpty(new Set([1, 2, 3]))).toEqual(false);

		expect(isObjectEmpty(new Map())).toEqual(true);
		expect(
			isObjectEmpty(
				new Map([
					['a', 1],
					['b', 2],
				]),
			),
		).toEqual(false);
	});

	it('should handle Buffer, ArrayBuffer, and Uint8Array', () => {
		expect(isObjectEmpty(Buffer.from(''))).toEqual(true);
		expect(isObjectEmpty(Buffer.from('abcd'))).toEqual(false);

		expect(isObjectEmpty(Uint8Array.from([]))).toEqual(true);
		expect(isObjectEmpty(Uint8Array.from([1, 2, 3]))).toEqual(false);

		expect(isObjectEmpty(new ArrayBuffer(0))).toEqual(true);
		expect(isObjectEmpty(new ArrayBuffer(1))).toEqual(false);
	});

	it('should handle plain objects', () => {
		expect(isObjectEmpty({})).toEqual(true);
		expect(isObjectEmpty({ a: 1, b: 2 })).toEqual(false);
	});

	it('should handle instantiated classes', () => {
		expect(isObjectEmpty(new (class Test {})())).toEqual(true);
		expect(
			isObjectEmpty(
				new (class Test {
					prop = 123;
				})(),
			),
		).toEqual(false);
	});

	it('should not call Object.keys unless a plain object', () => {
		const keySpy = vi.spyOn(Object, 'keys');
		const { calls } = keySpy.mock;

		const assertCalls = (count: number) => {
			if (calls.length !== count) {
				throw new ApplicationError('`Object.keys()` was called an unexpected number of times', {
					extra: { times: calls.length },
				});
			}
		};

		assertCalls(0);
		isObjectEmpty(null);
		assertCalls(0);
		isObjectEmpty([1, 2, 3]);
		assertCalls(0);
		isObjectEmpty(Buffer.from('123'));
		assertCalls(0);
		isObjectEmpty({});
		assertCalls(1);
	});
});

describe('jsonParse', () => {
	it('parses JSON', () => {
		expect(jsonParse('[1, 2, 3]')).toEqual([1, 2, 3]);
		expect(jsonParse('{ "a": 1 }')).toEqual({ a: 1 });
	});

	it('optionally throws `errorMessage', () => {
		expect(() => {
			jsonParse('', { errorMessage: 'Invalid JSON' });
		}).toThrow('Invalid JSON');
	});

	it('optionally returns a `fallbackValue`', () => {
		expect(jsonParse('', { fallbackValue: { foo: 'bar' } })).toEqual({ foo: 'bar' });
	});
});

describe('jsonStringify', () => {
	const source: any = { a: 1, b: 2, d: new Date(1680089084200), r: new RegExp('^test$', 'ig') };
	source.c = source;

	it('should throw errors on circular references by default', () => {
		expect(() => jsonStringify(source)).toThrow('Converting circular structure to JSON');
	});

	it('should break circular references when requested', () => {
		expect(jsonStringify(source, { replaceCircularRefs: true })).toEqual(
			'{"a":1,"b":2,"d":"2023-03-29T11:24:44.200Z","r":{},"c":"[Circular Reference]"}',
		);
	});

	it('should not detect duplicates as circular references', () => {
		const y = { z: 5 };
		const x = [y, y, { y }];
		expect(jsonStringify(x, { replaceCircularRefs: true })).toEqual(
			'[{"z":5},{"z":5},{"y":{"z":5}}]',
		);
	});
});

describe('deepCopy', () => {
	it('should deep copy an object', () => {
		const serializable = {
			x: 1,
			y: 2,
			toJSON: () => 'x:1,y:2',
		};
		const object = {
			deep: {
				props: {
					list: [{ a: 1 }, { b: 2 }, { c: 3 }],
				},
				arr: [1, 2, 3],
			},
			serializable,
			arr: [
				{
					prop: {
						list: ['a', 'b', 'c'],
					},
				},
			],
			func: () => {},
			date: new Date(1667389172201),
			undef: undefined,
			nil: null,
			bool: true,
			num: 1,
		};
		const copy = deepCopy(object);
		expect(copy).not.toBe(object);
		expect(copy.arr).toEqual(object.arr);
		expect(copy.arr).not.toBe(object.arr);
		expect(copy.date).toBe('2022-11-02T11:39:32.201Z');
		expect(copy.serializable).toBe(serializable.toJSON());
		expect(copy.deep.props).toEqual(object.deep.props);
		expect(copy.deep.props).not.toBe(object.deep.props);
	});

	it('should avoid max call stack in case of circular deps', () => {
		const object: Record<string, any> = {
			deep: {
				props: {
					list: [{ a: 1 }, { b: 2 }, { c: 3 }],
				},
				arr: [1, 2, 3],
			},
			arr: [
				{
					prop: {
						list: ['a', 'b', 'c'],
					},
				},
			],
			func: () => {},
			date: new Date(1667389172201),
			undef: undefined,
			nil: null,
			bool: true,
			num: 1,
		};

		object.circular = object;
		object.deep.props.circular = object;
		object.deep.arr.push(object);

		const copy = deepCopy(object);
		expect(copy).not.toBe(object);
		expect(copy.arr).toEqual(object.arr);
		expect(copy.arr).not.toBe(object.arr);
		expect(copy.date).toBe('2022-11-02T11:39:32.201Z');
		expect(copy.deep.props.circular).toBe(copy);
		expect(copy.deep.props.circular).not.toBe(object);
		expect(copy.deep.arr.slice(-1)[0]).toBe(copy);
		expect(copy.deep.arr.slice(-1)[0]).not.toBe(object);
	});
});

describe('fileTypeFromMimeType', () => {
	it('should recognize json', () => {
		expect(fileTypeFromMimeType('application/json')).toEqual('json');
	});

	it('should recognize html', () => {
		expect(fileTypeFromMimeType('text/html')).toEqual('html');
	});

	it('should recognize image', () => {
		expect(fileTypeFromMimeType('image/jpeg')).toEqual('image');
		expect(fileTypeFromMimeType('image/png')).toEqual('image');
		expect(fileTypeFromMimeType('image/avif')).toEqual('image');
		expect(fileTypeFromMimeType('image/webp')).toEqual('image');
	});

	it('should recognize audio', () => {
		expect(fileTypeFromMimeType('audio/wav')).toEqual('audio');
		expect(fileTypeFromMimeType('audio/webm')).toEqual('audio');
		expect(fileTypeFromMimeType('audio/ogg')).toEqual('audio');
		expect(fileTypeFromMimeType('audio/mp3')).toEqual('audio');
	});

	it('should recognize video', () => {
		expect(fileTypeFromMimeType('video/mp4')).toEqual('video');
		expect(fileTypeFromMimeType('video/webm')).toEqual('video');
		expect(fileTypeFromMimeType('video/ogg')).toEqual('video');
	});

	it('should recognize text', () => {
		expect(fileTypeFromMimeType('text/plain')).toEqual('text');
		expect(fileTypeFromMimeType('text/css')).toEqual('text');
		expect(fileTypeFromMimeType('text/html')).not.toEqual('text');
		expect(fileTypeFromMimeType('text/javascript')).toEqual('text');
		expect(fileTypeFromMimeType('application/javascript')).toEqual('text');
	});

	it('should recognize pdf', () => {
		expect(fileTypeFromMimeType('application/pdf')).toEqual('pdf');
	});
});

const repeat = (fn: () => void, times = 10) => Array(times).fill(0).forEach(fn);

describe('randomInt', () => {
	it('should generate random integers', () => {
		repeat(() => {
			const result = randomInt(10);
			expect(result).toBeLessThanOrEqual(10);
			expect(result).toBeGreaterThanOrEqual(0);
		});
	});

	it('should generate random in range', () => {
		repeat(() => {
			const result = randomInt(10, 100);
			expect(result).toBeLessThanOrEqual(100);
			expect(result).toBeGreaterThanOrEqual(10);
		});
	});
});

describe('randomString', () => {
	it('should return a random string of the specified length', () => {
		repeat(() => {
			const result = randomString(42);
			expect(result).toHaveLength(42);
		});
	});

	it('should return a random string of the in the length range', () => {
		repeat(() => {
			const result = randomString(10, 100);
			expect(result.length).toBeGreaterThanOrEqual(10);
			expect(result.length).toBeLessThanOrEqual(100);
		});
	});

	it('should only contain characters from the specified character set', () => {
		repeat(() => {
			const result = randomString(1000);
			result.split('').every((char) => ALPHABET.includes(char));
		});
	});
});

type Expect<T extends true> = T;
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
	? true
	: false;

describe('hasKey', () => {
	it('should return false if the input is null', () => {
		const x = null;
		const result = hasKey(x, 'key');

		expect(result).toEqual(false);
	});
	it('should return false if the input is undefined', () => {
		const x = undefined;
		const result = hasKey(x, 'key');

		expect(result).toEqual(false);
	});
	it('should return false if the input is a number', () => {
		const x = 1;
		const result = hasKey(x, 'key');

		expect(result).toEqual(false);
	});
	it('should return false if the input is an array out of bounds', () => {
		const x = [1, 2];
		const result = hasKey(x, 5);

		expect(result).toEqual(false);
	});

	it('should return true if the input is an array within bounds', () => {
		const x = [1, 2];
		const result = hasKey(x, 1);

		expect(result).toEqual(true);
	});
	it('should return true if the input is an array with the key `length`', () => {
		const x = [1, 2];
		const result = hasKey(x, 'length');

		expect(result).toEqual(true);
	});
	it('should return false if the input is an array with the key `toString`', () => {
		const x = [1, 2];
		const result = hasKey(x, 'toString');

		expect(result).toEqual(false);
	});
	it('should return false if the input is an object without the key', () => {
		const x = { a: 3 };
		const result = hasKey(x, 'a');

		expect(result).toEqual(true);
	});

	it('should return true if the input is an object with the key', () => {
		const x = { a: 3 };
		const result = hasKey(x, 'b');

		expect(result).toEqual(false);
	});

	it('should provide a type guard', () => {
		const x: unknown = { a: 3 };
		if (hasKey(x, '0')) {
			const y: Expect<Equal<typeof x, Record<'0', unknown>>> = true;
			y;
		} else {
			const z: Expect<Equal<typeof x, unknown>> = true;
			z;
		}
	});
});

describe('isSafeObjectProperty', () => {
	it.each([
		['__proto__', false],
		['prototype', false],
		['constructor', false],
		['getPrototypeOf', false],
		['safeKey', true],
		['anotherKey', true],
		['toString', true],
	])('should return %s for key "%s"', (key, expected) => {
		expect(isSafeObjectProperty(key)).toBe(expected);
	});
});

describe('setSafeObjectProperty', () => {
	it.each([
		['safeKey', 123, { safeKey: 123 }],
		['__proto__', 456, {}],
		['constructor', 'test', {}],
	])('should set property "%s" safely', (key, value, expected) => {
		const obj: Record<string, unknown> = {};
		setSafeObjectProperty(obj, key, value);
		expect(obj).toEqual(expected);
	});
});

describe('sleepWithAbort', () => {
	it('should resolve after the specified time when not aborted', async () => {
		const start = Date.now();
		await sleepWithAbort(100);
		const end = Date.now();
		const elapsed = end - start;

		// Allow some tolerance for timing
		expect(elapsed).toBeGreaterThanOrEqual(90);
		expect(elapsed).toBeLessThan(200);
	});

	it('should reject immediately if abort signal is already aborted', async () => {
		const abortController = new AbortController();
		abortController.abort();

		await expect(sleepWithAbort(1000, abortController.signal)).rejects.toThrow(
			ExecutionCancelledError,
		);
	});

	it('should reject when abort signal is triggered during sleep', async () => {
		const abortController = new AbortController();

		// Start the sleep and abort after 50ms
		setTimeout(() => abortController.abort(), 50);

		const start = Date.now();
		await expect(sleepWithAbort(1000, abortController.signal)).rejects.toThrow(
			ExecutionCancelledError,
		);
		const end = Date.now();
		const elapsed = end - start;

		// Should have been aborted after ~50ms, not the full 1000ms
		expect(elapsed).toBeLessThan(200);
	});

	it('should work without abort signal', async () => {
		const start = Date.now();
		await sleepWithAbort(100, undefined);
		const end = Date.now();
		const elapsed = end - start;

		expect(elapsed).toBeGreaterThanOrEqual(90);
		expect(elapsed).toBeLessThan(200);
	});

	it('should clean up timeout when aborted during sleep', async () => {
		const abortController = new AbortController();
		const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');

		// Start the sleep and abort after 50ms
		const sleepPromise = sleepWithAbort(1000, abortController.signal);
		setTimeout(() => abortController.abort(), 50);

		await expect(sleepPromise).rejects.toThrow(ExecutionCancelledError);

		// clearTimeout should have been called to clean up
		expect(clearTimeoutSpy).toHaveBeenCalled();

		clearTimeoutSpy.mockRestore();
	});
});

describe('isDomainAllowed', () => {
	describe('when no allowed domains are specified', () => {
		it('should allow all domains when allowedDomains is empty', () => {
			expect(isDomainAllowed('https://example.com', { allowedDomains: '' })).toBe(true);
		});

		it('should allow all domains when allowedDomains contains only whitespace', () => {
			expect(isDomainAllowed('https://example.com', { allowedDomains: '   ' })).toBe(true);
		});
	});

	describe('in strict validation mode', () => {
		it('should allow exact domain matches', () => {
			expect(
				isDomainAllowed('https://example.com', {
					allowedDomains: 'example.com',
				}),
			).toBe(true);
		});

		it('should allow domains from a comma-separated list', () => {
			expect(
				isDomainAllowed('https://example.com', {
					allowedDomains: 'test.com,example.com,other.org',
				}),
			).toBe(true);
		});

		it('should handle whitespace in allowed domains list', () => {
			expect(
				isDomainAllowed('https://example.com', {
					allowedDomains: ' test.com , example.com , other.org ',
				}),
			).toBe(true);
		});

		it('should block non-matching domains', () => {
			expect(
				isDomainAllowed('https://malicious.com', {
					allowedDomains: 'example.com',
				}),
			).toBe(false);
		});

		it('should block subdomains not set', () => {
			expect(
				isDomainAllowed('https://sub.example.com', {
					allowedDomains: 'example.com',
				}),
			).toBe(false);
		});
	});

	describe('with wildcard domains', () => {
		it('should allow matching wildcard domains', () => {
			expect(
				isDomainAllowed('https://test.example.com', {
					allowedDomains: '*.example.com',
				}),
			).toBe(true);
		});

		it('should allow nested subdomains with wildcards', () => {
			expect(
				isDomainAllowed('https://deep.nested.example.com', {
					allowedDomains: '*.example.com',
				}),
			).toBe(true);
		});

		it('should block non-matching domains with wildcards', () => {
			expect(
				isDomainAllowed('https://example.org', {
					allowedDomains: '*.example.com',
				}),
			).toBe(false);
		});
	});

	describe('edge cases', () => {
		it('should handle invalid URLs safely', () => {
			expect(
				isDomainAllowed('not-a-valid-url', {
					allowedDomains: 'example.com',
				}),
			).toBe(false);
		});

		it('should handle URLs with ports', () => {
			expect(
				isDomainAllowed('https://example.com:8080/path', {
					allowedDomains: 'example.com',
				}),
			).toBe(true);
		});

		it('should handle URLs with authentication', () => {
			expect(
				isDomainAllowed('https://user:pass@example.com', {
					allowedDomains: 'example.com',
				}),
			).toBe(true);
		});

		it('should handle URLs with query parameters and fragments', () => {
			expect(
				isDomainAllowed('https://example.com/path?query=test#fragment', {
					allowedDomains: 'example.com',
				}),
			).toBe(true);
		});

		it('should handle IP addresses', () => {
			expect(
				isDomainAllowed('https://192.168.1.1', {
					allowedDomains: '192.168.1.1',
				}),
			).toBe(true);
		});

		it('should handle empty URLs', () => {
			expect(
				isDomainAllowed('', {
					allowedDomains: 'example.com',
				}),
			).toBe(false);
		});
	});
});



================================================
FILE: packages/workflow/test/workflow-data-proxy-env-provider.test.ts
================================================
import { ExpressionError } from '../src/errors/expression.error';
import { createEnvProvider, createEnvProviderState } from '../src/workflow-data-proxy-env-provider';

describe('createEnvProviderState', () => {
	afterEach(() => {
		delete process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE;
	});

	it('should return the state with process available and env access allowed', () => {
		expect(createEnvProviderState()).toEqual({
			isProcessAvailable: true,
			isEnvAccessBlocked: false,
			env: process.env,
		});
	});

	it('should block env access when N8N_BLOCK_ENV_ACCESS_IN_NODE is set to "true"', () => {
		process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE = 'true';

		expect(createEnvProviderState()).toEqual({
			isProcessAvailable: true,
			isEnvAccessBlocked: true,
			env: {},
		});
	});

	it('should handle process not being available', () => {
		const originalProcess = global.process;
		try {
			// @ts-expect-error process is read-only
			global.process = undefined;

			expect(createEnvProviderState()).toEqual({
				isProcessAvailable: false,
				isEnvAccessBlocked: false,
				env: {},
			});
		} finally {
			global.process = originalProcess;
		}
	});
});

describe('createEnvProvider', () => {
	it('should return true when checking for a property using "has"', () => {
		const proxy = createEnvProvider(0, 0, createEnvProviderState());
		expect('someProperty' in proxy).toBe(true);
	});

	it('should return the value from process.env if access is allowed', () => {
		process.env.TEST_ENV_VAR = 'test_value';
		const proxy = createEnvProvider(0, 0, createEnvProviderState());
		expect(proxy.TEST_ENV_VAR).toBe('test_value');
	});

	it('should throw ExpressionError when process is unavailable', () => {
		vi.useFakeTimers({ now: new Date() });

		const originalProcess = global.process;
		// @ts-expect-error process is read-only
		global.process = undefined;
		try {
			const proxy = createEnvProvider(1, 1, createEnvProviderState());

			expect(() => proxy.someEnvVar).toThrowError(
				new ExpressionError('not accessible via UI, please run node', {
					runIndex: 1,
					itemIndex: 1,
				}),
			);
		} finally {
			global.process = originalProcess;
		}

		vi.useRealTimers();
	});

	it('should throw ExpressionError when env access is blocked', () => {
		process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE = 'true';
		const proxy = createEnvProvider(1, 1, createEnvProviderState());

		expect(() => proxy.someEnvVar).toThrowError(
			new ExpressionError('access to env vars denied', {
				causeDetailed:
					'If you need access please contact the administrator to remove the environment variable ‘N8N_BLOCK_ENV_ACCESS_IN_NODE‘',
				runIndex: 1,
				itemIndex: 1,
			}),
		);
	});
});



================================================
FILE: packages/workflow/test/workflow-data-proxy.test.ts
================================================
import { DateTime, Duration, Interval } from 'luxon';

import * as Helpers from './helpers';
import { ensureError } from '../src/errors/ensure-error';
import { ExpressionError } from '../src/errors/expression.error';
import {
	NodeConnectionTypes,
	type NodeConnectionType,
	type IExecuteData,
	type INode,
	type IPinData,
	type IRun,
	type IWorkflowBase,
	type WorkflowExecuteMode,
} from '../src/interfaces';
import { Workflow } from '../src/workflow';
import { WorkflowDataProxy } from '../src/workflow-data-proxy';

const loadFixture = (fixture: string) => {
	const workflow = Helpers.readJsonFileSync<IWorkflowBase>(
		`test/fixtures/WorkflowDataProxy/${fixture}_workflow.json`,
	);
	const run = Helpers.readJsonFileSync<IRun>(`test/fixtures/WorkflowDataProxy/${fixture}_run.json`);

	return { workflow, run };
};

const getProxyFromFixture = (
	workflow: IWorkflowBase,
	run: IRun | null,
	activeNode: string,
	mode?: WorkflowExecuteMode,
	opts?: {
		throwOnMissingExecutionData: boolean;
		connectionType?: NodeConnectionType;
		runIndex?: number;
	},
) => {
	const taskData = run?.data.resultData.runData[activeNode]?.[opts?.runIndex ?? 0];
	const lastNodeConnectionInputData =
		taskData?.data?.[opts?.connectionType ?? NodeConnectionTypes.Main]?.[0];

	let executeData: IExecuteData | undefined;

	if (taskData) {
		executeData = {
			data: taskData.data!,
			node: workflow.nodes.find((node) => node.name === activeNode) as INode,
			source: {
				[opts?.connectionType ?? NodeConnectionTypes.Main]: taskData.source,
			},
		};
	}

	let pinData: IPinData = {};
	if (workflow.pinData) {
		// json key is stored as part of workflow
		// but dropped when copy/pasting
		// so adding here to keep updating tests simple
		for (let nodeName in workflow.pinData) {
			pinData[nodeName] = workflow.pinData[nodeName].map((item) => ({ json: item }));
		}
	}

	const dataProxy = new WorkflowDataProxy(
		new Workflow({
			id: '123',
			name: 'test workflow',
			nodes: workflow.nodes,
			connections: workflow.connections,
			active: false,
			nodeTypes: Helpers.NodeTypes(),
			pinData,
		}),
		run?.data ?? null,
		opts?.runIndex ?? 0,
		0,
		activeNode,
		lastNodeConnectionInputData ?? [],
		{},
		mode ?? 'integrated',
		{},
		executeData,
	);

	return dataProxy.getDataProxy(opts);
};

describe('WorkflowDataProxy', () => {
	describe('$(If))', () => {
		const fixture = loadFixture('multiple_outputs');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Edit Fields');

		test('last() should use the output the node is connected to by default', () => {
			expect(proxy.$('If').last().json.code).toEqual(2);
		});

		test('last(0) should use the first output', () => {
			expect(proxy.$('If').last(0)).toBeUndefined();
		});

		test('last(1) should use the second output', () => {
			expect(proxy.$('If').last(1).json.code).toEqual(2);
		});

		test('first() should use the output the node is connected to by default', () => {
			expect(proxy.$('If').first().json.code).toEqual(1);
		});
		test('first(0) should use the output the node is connected to by default', () => {
			expect(proxy.$('If').first(0)).toBeUndefined();
		});
		test('first(1) should use the output the node is connected to by default', () => {
			expect(proxy.$('If').first(1).json.code).toEqual(1);
		});

		test('all() should use the output the node is connected to by default', () => {
			expect(proxy.$('If').all()[0].json.code).toEqual(1);
			expect(proxy.$('If').all()[1].json.code).toEqual(2);
		});
		test('all(0) should use the output the node is connected to by default', () => {
			expect(proxy.$('If').all(0)[0]).toBeUndefined();
			expect(proxy.$('If').all(0)[1]).toBeUndefined();
		});
		test('all(1) should use the output the node is connected to by default', () => {
			expect(proxy.$('If').all(1)[0].json.code).toEqual(1);
			expect(proxy.$('If').all(1)[1].json.code).toEqual(2);
		});
	});

	describe('Base', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

		test('$("NodeName").all()', () => {
			expect(proxy.$('Rename').all()[1].json.data).toEqual(160);
		});
		test('$("NodeName").all() length', () => {
			expect(proxy.$('Rename').all().length).toEqual(5);
		});
		test('$("NodeName").item', () => {
			expect(proxy.$('Rename').item).toEqual({ json: { data: 105 }, pairedItem: { item: 0 } });
		});
		test('$("NodeNameEarlier").item', () => {
			expect(proxy.$('Function').item).toEqual({
				json: { initialName: 105 },
				pairedItem: { item: 0 },
			});
		});
		test('$("NodeName").itemMatching(2)', () => {
			expect(proxy.$('Rename').itemMatching(2).json.data).toEqual(121);
		});
		test('$("NodeName").first()', () => {
			expect(proxy.$('Rename').first().json.data).toEqual(105);
		});
		test('$("NodeName").last()', () => {
			expect(proxy.$('Rename').last().json.data).toEqual(950);
		});

		test('$("NodeName").params', () => {
			expect(proxy.$('Rename').params).toEqual({ value1: 'data', value2: 'initialName' });
		});

		test('$("NodeName").context', () => {
			expect(proxy.$('Rename').context).toBeDefined();
		});

		test('$("NodeName") not in workflow should throw', () => {
			expect(() => proxy.$('doNotExist')).toThrowError(ExpressionError);
		});

		test('$("NodeName").item on Node that has not executed', () => {
			expect(() => proxy.$('Set').item).toThrowError(ExpressionError);
		});

		test('$("NodeName").isExecuted', () => {
			expect(proxy.$('Function').isExecuted).toEqual(true);
			expect(proxy.$('Set').isExecuted).toEqual(false);
		});

		test('$input.all()', () => {
			expect(proxy.$input.all()[1].json.data).toEqual(160);
		});
		test('$input.all() length', () => {
			expect(proxy.$input.all().length).toEqual(5);
		});
		test('$input.first()', () => {
			expect(proxy.$input.first()?.json?.data).toEqual(105);
		});
		test('$input.last()', () => {
			expect(proxy.$input.last()?.json?.data).toEqual(950);
		});
		test('$input.item', () => {
			expect(proxy.$input.item?.json?.data).toEqual(105);
		});
		test('$input.context', () => {
			expect(proxy.$input.context).toBeDefined();
		});
		test('$input.params', () => {
			expect(proxy.$input.params).toBeDefined();
		});
		test('$thisItem', () => {
			expect(proxy.$thisItem.json.data).toEqual(105);
		});

		test('$binary', () => {
			expect(proxy.$binary).toEqual({});
		});

		test('$json', () => {
			expect(proxy.$json).toEqual({ data: 105 });
		});

		test('$itemIndex', () => {
			expect(proxy.$itemIndex).toEqual(0);
		});

		test('$prevNode', () => {
			expect(proxy.$prevNode).toEqual({ name: 'Rename', outputIndex: 0, runIndex: 0 });
		});

		test('$runIndex', () => {
			expect(proxy.$runIndex).toEqual(0);
		});

		test('$workflow', () => {
			expect(proxy.$workflow).toEqual({
				active: false,
				id: '123',
				name: 'test workflow',
			});
		});
	});

	describe('Errors', () => {
		const fixture = loadFixture('errors');

		test('$("NodeName").item, Node does not exist', () => {
			const proxy = getProxyFromFixture(
				fixture.workflow,
				fixture.run,
				'Reference non-existent node',
			);
			try {
				proxy.$('does not exist').item;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual("Referenced node doesn't exist");
			}
		});

		test('$("NodeName").item, node has no connection to referenced node', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'NoPathBack');
			try {
				proxy.$('Customer Datastore (n8n training)').item;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual('Invalid expression');
				expect(exprError.context.type).toEqual('paired_item_no_connection');
			}
		});

		test('$("NodeName").first(), node has no connection to referenced node', () => {
			const proxy = getProxyFromFixture(
				fixture.workflow,
				fixture.run,
				'Reference impossible with .first()',
			);
			try {
				proxy.$('Impossible').first().json.name;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual("Node 'Impossible' hasn't been executed");
				expect(exprError.context.type).toEqual('no_execution_data');
			}
		});

		test('$json, Node has no connections', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'NoInputConnection');
			try {
				proxy.$json.email;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual("Node 'NoInputConnection' hasn't been executed");
				expect(exprError.context.type).toEqual('no_execution_data');
			}
		});

		test('$("NodeName").item, Node has not run', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Impossible');
			try {
				proxy.$('Impossible if').item;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual("Node 'Impossible if' hasn't been executed");
				expect(exprError.context.type).toEqual('no_execution_data');
			}
		});

		test('$json, Node has not run', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Impossible');
			try {
				proxy.$json.email;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual("Node 'Impossible' hasn't been executed");
				expect(exprError.context.type).toEqual('no_execution_data');
			}
		});

		test('$("NodeName").item, paired item error: more than 1 matching item', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'PairedItemMultipleMatches');
			try {
				proxy.$('Edit Fields').item;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual('Multiple matches found');
				expect(exprError.context.type).toEqual('paired_item_multiple_matches');
			}
		});

		test('$("NodeName").item, paired item error: missing paired item', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'PairedItemInfoMissing');
			try {
				proxy.$('Edit Fields').item;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual(
					"Paired item data for item from node 'Break pairedItem chain' is unavailable. Ensure 'Break pairedItem chain' is providing the required output.",
				);
				expect(exprError.context.type).toEqual('paired_item_no_info');
			}
		});

		test('$("NodeName").item, paired item error: invalid paired item', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'IncorrectPairedItem');
			try {
				proxy.$('Edit Fields').item;
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionError);
				const exprError = error as ExpressionError;
				expect(exprError.message).toEqual("Can't get data for expression");
				expect(exprError.context.type).toEqual('paired_item_invalid_info');
			}
		});
	});

	describe('Pinned data with manual execution', () => {
		const fixture = loadFixture('pindata');
		const proxy = getProxyFromFixture(fixture.workflow, null, 'NotPinnedSet1', 'manual');

		test('$(PinnedSet).item.json', () => {
			expect(proxy.$('PinnedSet').item.json).toEqual({ firstName: 'Joe', lastName: 'Smith' });
		});

		test('$(PinnedSet).item.json.firstName', () => {
			expect(proxy.$('PinnedSet').item.json.firstName).toBe('Joe');
		});

		test('$(PinnedSet).pairedItem().json.firstName', () => {
			expect(proxy.$('PinnedSet').pairedItem().json.firstName).toBe('Joe');
		});

		test('$(PinnedSet).first().json.firstName', () => {
			expect(proxy.$('PinnedSet').first().json.firstName).toBe('Joe');
		});

		test('$(PinnedSet).first().json.firstName', () => {
			expect(proxy.$('PinnedSet').first().json.firstName).toBe('Joe');
		});

		test('$(PinnedSet).last().json.firstName', () => {
			expect(proxy.$('PinnedSet').last().json.firstName).toBe('Joan');
		});

		test('$(PinnedSet).all()[0].json.firstName', () => {
			expect(proxy.$('PinnedSet').all()[0].json.firstName).toBe('Joe');
		});

		test('$(PinnedSet).all()[1].json.firstName', () => {
			expect(proxy.$('PinnedSet').all()[1].json.firstName).toBe('Joan');
		});

		test('$(PinnedSet).all()[2]', () => {
			expect(proxy.$('PinnedSet').all()[2]).toBeUndefined();
		});

		test('$(PinnedSet).itemMatching(0).json.firstName', () => {
			expect(proxy.$('PinnedSet').itemMatching(0).json.firstName).toBe('Joe');
		});

		test('$(PinnedSet).itemMatching(1).json.firstName', () => {
			expect(proxy.$('PinnedSet').itemMatching(1).json.firstName).toBe('Joan');
		});

		test('$(PinnedSet).itemMatching(2)', () => {
			expect(proxy.$('PinnedSet').itemMatching(2)).toBeUndefined();
		});

		test('$node[PinnedSet].json.firstName', () => {
			expect(proxy.$node.PinnedSet.json.firstName).toBe('Joe');
		});
	});

	describe('Pinned data with paired items', () => {
		const fixture = loadFixture('pindata_paireditem');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Set', 'manual', {
			runIndex: 0,
			throwOnMissingExecutionData: false,
		});

		test.each([{ methodName: 'itemMatching' }, { methodName: 'pairedItem' }])(
			'$methodName should throw when it cannot find a paired item',
			async ({ methodName }) => {
				try {
					proxy.$('DebugHelper')[methodName](0);
					throw new Error('should throw');
				} catch (e) {
					const error = ensureError(e);
					expect(error.message).toEqual(
						`Using the ${methodName} method doesn't work with pinned data in this scenario. Please unpin 'Edit Fields' and try again.`,
					);

					expect(error).toMatchObject({
						functionality: 'pairedItem',
						context: {
							runIndex: 0,
							itemIndex: 0,
							type: 'paired_item_no_info',
							descriptionKey: 'pairedItemNoInfo',
							nodeCause: 'Edit Fields',
							causeDetailed:
								"Missing pairedItem data (node 'Edit Fields' probably didn't supply it)",
						},
					});
				}
			},
		);

		test('item should throw when it cannot find a paired item', async () => {
			try {
				proxy.$('DebugHelper').item;
				throw new Error('should throw');
			} catch (e) {
				const error = ensureError(e);
				expect(error.message).toEqual(
					"Using the item method doesn't work with pinned data in this scenario. Please unpin 'Edit Fields' and try again.",
				);

				expect(error).toMatchObject({
					functionality: 'pairedItem',
					context: {
						runIndex: 0,
						itemIndex: 0,
						type: 'paired_item_no_info',
						descriptionKey: 'pairedItemNoInfo',
						nodeCause: 'Edit Fields',
						causeDetailed: "Missing pairedItem data (node 'Edit Fields' probably didn't supply it)",
					},
				});
			}
		});
	});

	describe('Partial data', () => {
		const fixture = loadFixture('partial_data');

		describe('Default behaviour (throw on missing execution data)', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

			test('$binary', () => {
				expect(() => proxy.$binary).toThrowError(ExpressionError);
			});

			test('$json', () => {
				expect(() => proxy.$json).toThrowError(ExpressionError);
			});

			test('$data', () => {
				expect(() => proxy.$data).toThrowError(ExpressionError);
			});
		});

		describe("Don't throw on missing execution data)", () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End', undefined, {
				throwOnMissingExecutionData: false,
			});

			test('$binary', () => {
				expect(proxy.$binary).toBeUndefined();
			});

			test('$json', () => {
				expect(proxy.$json).toBeUndefined();
			});

			test('$data', () => {
				expect(proxy.$data).toBeUndefined();
			});
		});
	});

	describe('$fromAI', () => {
		const fixture = loadFixture('from_ai_multiple_items');
		const getFromAIProxy = (runIndex = 0) =>
			getProxyFromFixture(fixture.workflow, fixture.run, 'Google Sheets1', 'manual', {
				connectionType: NodeConnectionTypes.AiTool,
				throwOnMissingExecutionData: false,
				runIndex,
			});

		test('Retrieves values for first item', () => {
			expect(getFromAIProxy().$fromAI('full_name')).toEqual('Mr. Input 1');
			expect(getFromAIProxy().$fromAI('email')).toEqual('input1@n8n.io');
		});

		test('Retrieves values for second item', () => {
			expect(getFromAIProxy(1).$fromAI('full_name')).toEqual('Mr. Input 2');
			expect(getFromAIProxy(1).$fromAI('email')).toEqual('input2@n8n.io');
		});

		test('Case variants: $fromAi and $fromai', () => {
			expect(getFromAIProxy().$fromAi('full_name')).toEqual('Mr. Input 1');
			expect(getFromAIProxy().$fromai('email')).toEqual('input1@n8n.io');
		});

		test('Returns default value when key not found', () => {
			expect(
				getFromAIProxy().$fromAI('non_existent_key', 'description', 'string', 'default_value'),
			).toEqual('default_value');
		});

		test('Throws an error when a key is invalid (e.g. empty string)', () => {
			expect(() => getFromAIProxy().$fromAI('')).toThrow(ExpressionError);
			expect(() => getFromAIProxy().$fromAI('invalid key')).toThrow(ExpressionError);
			expect(() => getFromAIProxy().$fromAI('invalid!')).toThrow(ExpressionError);
		});
	});

	describe('$rawParameter', () => {
		const fixture = loadFixture('rawParameter');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Execute Workflow', 'manual', {
			connectionType: NodeConnectionTypes.Main,
			throwOnMissingExecutionData: false,
			runIndex: 0,
		});

		test('returns simple raw parameter value', () => {
			expect(proxy.$rawParameter.options).toEqual({
				waitForSubWorkflow: '={{ true }}',
			});
		});

		test('returns raw parameter value for resource locator values', () => {
			expect(proxy.$rawParameter.workflowId).toEqual('={{ $json.foo }}');
		});

		test('returns raw parameter value when there is no run data', () => {
			const noRunDataProxy = getProxyFromFixture(
				fixture.workflow,
				{
					data: { resultData: { runData: {} } },
					mode: 'manual',
					startedAt: new Date(),
					status: 'success',
				},
				'Execute Workflow',
				'manual',
				{
					connectionType: NodeConnectionTypes.Main,
					throwOnMissingExecutionData: false,
					runIndex: 0,
				},
			);
			expect(noRunDataProxy.$rawParameter.options).toEqual({
				waitForSubWorkflow: '={{ true }}',
			});
		});
	});

	describe('DateTime and Time-related functions', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

		test('$now should return current datetime', () => {
			expect(proxy.$now).toBeInstanceOf(DateTime);
		});

		test('$today should return datetime at start of day', () => {
			const today = proxy.$today;
			expect(today).toBeInstanceOf(DateTime);
			expect(today.hour).toBe(0);
			expect(today.minute).toBe(0);
			expect(today.second).toBe(0);
			expect(today.millisecond).toBe(0);
		});

		test('should expose DateTime, Interval, and Duration', () => {
			expect(proxy.DateTime).toBe(DateTime);
			expect(proxy.Interval).toBe(Interval);
			expect(proxy.Duration).toBe(Duration);
		});

		test('$now should be configurable with timezone', () => {
			const timezoneProxy = getProxyFromFixture(
				{ ...fixture.workflow, settings: { timezone: 'America/New_York' } },
				fixture.run,
				'End',
			);

			expect(timezoneProxy.$now.zoneName).toBe('America/New_York');
		});
	});

	describe('Node version and ID', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

		test('$nodeVersion should return node type version', () => {
			expect(proxy.$nodeVersion).toBe(1);
		});

		test('$nodeId should return node ID', () => {
			expect(proxy.$nodeId).toBe('uuid-5');
		});

		test('$webhookId should be optional', () => {
			expect(proxy.$webhookId).toBeUndefined();
		});
	});

	describe('$jmesPath', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

		test('should query simple object', () => {
			const data = { name: 'John', age: 30 };
			expect(proxy.$jmesPath(data, 'name')).toBe('John');
		});

		test('should query nested object', () => {
			const data = {
				user: {
					name: 'John',
					details: { age: 30 },
				},
			};
			expect(proxy.$jmesPath(data, 'user.details.age')).toBe(30);
		});

		test('should query array', () => {
			const data = [
				{ name: 'John', age: 30 },
				{ name: 'Jane', age: 25 },
			];
			expect(proxy.$jmesPath(data, '[*].name')).toEqual(['John', 'Jane']);
		});

		test('should throw error for invalid arguments', () => {
			expect(() => proxy.$jmesPath('not an object', 'test')).toThrow(ExpressionError);
			expect(() => proxy.$jmesPath({}, 123 as unknown as string)).toThrow(ExpressionError);
		});

		test('$jmespath should alias $jmesPath', () => {
			const data = { name: 'John' };
			expect(proxy.$jmespath(data, 'name')).toBe(proxy.$jmesPath(data, 'name'));
		});
	});

	describe('$mode', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End', 'manual');

		test('should return execution mode', () => {
			expect(proxy.$mode).toBe('manual');
		});
	});

	describe('$item', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

		test('should return data proxy for specific item', () => {
			const itemProxy = proxy.$item(1);
			expect(itemProxy.$json.data).toBe(160);
		});

		test('should allow specifying run index', () => {
			const itemProxy = proxy.$item(1, 0);
			expect(itemProxy.$json.data).toBe(160);
		});
	});

	describe('$items', () => {
		const fixture = loadFixture('base');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'End');

		describe('Default behavior (no arguments)', () => {
			test('should return input items from previous node', () => {
				const items = proxy.$items();
				expect(items.length).toBe(5);
				expect(items[0].json.data).toBe(105);
				expect(items[1].json.data).toBe(160);
			});

			test('should limit items for nodes with executeOnce=true', () => {
				// Mock a node with executeOnce=true
				const mockWorkflow = {
					...fixture.workflow,
					nodes: fixture.workflow.nodes.map((node) =>
						node.name === 'Rename' ? { ...node, executeOnce: true } : node,
					),
				};

				const mockProxy = getProxyFromFixture(mockWorkflow, fixture.run, 'End');
				const items = mockProxy.$items();

				expect(items.length).toBe(1);
				expect(items[0].json.data).toBe(105);
			});
		});

		describe('With node name argument', () => {
			test('should return items for specified node', () => {
				const items = proxy.$items('Rename');
				expect(items.length).toBe(5);
				expect(items[0].json.data).toBe(105);
				expect(items[1].json.data).toBe(160);
			});

			test('should throw error for non-existent node', () => {
				expect(() => proxy.$items('NonExistentNode')).toThrowError(ExpressionError);
			});
		});

		describe('With node name and output index', () => {
			const switchWorkflow = loadFixture('multiple_outputs');
			const switchProxy = getProxyFromFixture(
				switchWorkflow.workflow,
				switchWorkflow.run,
				'Edit Fields',
			);

			test('should return items from specific output', () => {
				const items = switchProxy.$items('If', 1);
				expect(items[0].json.code).toBe(1);
			});
		});

		describe('With node name, output index, and run index', () => {
			test('should handle negative run index', () => {
				const items = proxy.$items('Rename', 0, -1);
				expect(items.length).toBe(5);
				expect(items[0].json.data).toBe(105);
			});
		});

		describe('Error handling', () => {
			test('should throw error for invalid run index', () => {
				expect(() => proxy.$items('Rename', 0, 999)).toThrowError(ExpressionError);
			});

			test('should handle nodes with no execution data', () => {
				const noDataWorkflow = {
					...fixture.workflow,
					nodes: fixture.workflow.nodes.filter((node) => node.name !== 'Rename'),
				};
				const noDataProxy = getProxyFromFixture(noDataWorkflow, null, 'End');

				expect(() => noDataProxy.$items('Rename')).toThrowError(ExpressionError);
			});
		});
	});

	describe('$agentInfo', () => {
		const fixture = loadFixture('agentInfo');
		const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'AI Agent');

		test('$agentInfo should return undefined for non-agent nodes', () => {
			const nonAgentProxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Calculator');
			expect(nonAgentProxy.$agentInfo).toBeUndefined();
		});

		test('$agentInfo should return memoryConnectedToAgent as true if memory is connected', () => {
			expect(proxy.$agentInfo.memoryConnectedToAgent).toBe(true);
		});

		test('$agentInfo should return memoryConnectedToAgent as false if no memory is connected', () => {
			const noMemoryProxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Another Agent');
			expect(noMemoryProxy.$agentInfo.memoryConnectedToAgent).toBe(false);
		});

		test('$agentInfo.tools should include connected tools with correct details', () => {
			const tools = proxy.$agentInfo.tools;
			// don't show tool connected to other agent
			expect(tools.length).toEqual(2);
			expect(tools[0]).toMatchObject({
				connected: true,
				name: 'Google Calendar',
				type: 'Google Calendar',
				resource: 'Event',
				operation: 'Create',
				hasCredentials: false,
			});
			expect(tools[1]).toMatchObject({
				connected: false,
				name: 'Calculator',
				type: 'Calculator',
				resource: null,
				operation: null,
				hasCredentials: false,
			});
		});

		test('$agentInfo.tools should correctly identify AI-defined fields', () => {
			const tools = proxy.$agentInfo.tools;
			expect(tools[0].name).toBe('Google Calendar');
			expect(tools[0].aiDefinedFields.length).toBe(1);
			expect(tools[0].aiDefinedFields).toEqual(['Start']);
		});
	});

	describe('multiple inputs', () => {
		const fixture = loadFixture('multiple_inputs');

		it('should correctly resolve expressions with multiple inputs (using paired item)', () => {
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Output');
			expect(proxy.$('Set variable_3').item.json.variable_3).toEqual('3456');
			expect(proxy.$('Set main variable').item.json.main_variable).toEqual(2);
		});
	});

	describe('Improved error messages for missing execution data', () => {
		test('should show helpful error message when accessing node without execution data', () => {
			// Create a simple workflow with two connected nodes
			const workflow: IWorkflowBase = {
				id: '1',
				name: 'test-workflow',
				nodes: [
					{
						id: '1',
						name: 'Telegram Trigger',
						type: 'n8n-nodes-base.telegramTrigger',
						typeVersion: 1.2,
						position: [0, 0],
						parameters: {},
					},
					{
						id: '2',
						name: 'Send a text message',
						type: 'n8n-nodes-base.telegram',
						typeVersion: 1.2,
						position: [576, 0],
						parameters: {
							chatId: "={{ $('Telegram Trigger').item.json.message.chat.id }}",
							text: 'Test message',
						},
					},
				],
				connections: {
					'Telegram Trigger': {
						main: [[{ node: 'Send a text message', type: NodeConnectionTypes.Main, index: 0 }]],
					},
				},
				active: false,
				isArchived: false,
				createdAt: new Date(),
				updatedAt: new Date(),
			};

			// Create run data without execution data for Telegram Trigger
			const run = {
				data: {
					resultData: {
						runData: {}, // Empty - no nodes have executed
					},
				},
				mode: 'manual' as const,
				startedAt: new Date(),
				status: 'success' as const,
			};

			const proxy = getProxyFromFixture(workflow, run, 'Send a text message');

			// Should throw helpful error when trying to access Telegram Trigger data
			let error: ExpressionError | undefined;
			try {
				proxy.$('Telegram Trigger').item;
			} catch (e) {
				error = e as ExpressionError;
			}

			expect(error).toBeDefined();
			expect(error).toBeInstanceOf(ExpressionError);
			expect(error!.message).toBe("Node 'Telegram Trigger' hasn't been executed");
			expect(error!.context.type).toBe('no_execution_data');
			expect(error!.context.messageTemplate).toBe(
				'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
			);
		});

		test('should show helpful error message for different node names', () => {
			const workflow: IWorkflowBase = {
				id: '1',
				name: 'test-workflow',
				nodes: [
					{
						id: '1',
						name: 'HTTP Request',
						type: 'n8n-nodes-base.httpRequest',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: '2',
						name: 'Process Data',
						type: 'n8n-nodes-base.code',
						typeVersion: 2,
						position: [300, 0],
						parameters: {
							jsCode: "return $('HTTP Request').all();",
						},
					},
				],
				connections: {
					'HTTP Request': {
						main: [[{ node: 'Process Data', type: NodeConnectionTypes.Main, index: 0 }]],
					},
				},
				active: false,
				isArchived: false,
				createdAt: new Date(),
				updatedAt: new Date(),
			};

			const run = {
				data: {
					resultData: {
						runData: {}, // Empty - no nodes have executed
					},
				},
				mode: 'manual' as const,
				startedAt: new Date(),
				status: 'success' as const,
			};

			const proxy = getProxyFromFixture(workflow, run, 'Process Data');

			let error: ExpressionError | undefined;
			try {
				proxy.$('HTTP Request').item;
			} catch (e) {
				error = e as ExpressionError;
			}

			expect(error).toBeDefined();
			expect(error!.message).toBe("Node 'HTTP Request' hasn't been executed");
			expect(error!.context.type).toBe('no_execution_data');
			expect(error!.context.messageTemplate).toBe(
				'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
			);
		});

		test('should use improved error for first(), last(), and all() methods', () => {
			const workflow: IWorkflowBase = {
				id: '1',
				name: 'test-workflow',
				nodes: [
					{
						id: '1',
						name: 'Start Node',
						type: 'n8n-nodes-base.manualTrigger',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: '2',
						name: 'End Node',
						type: 'n8n-nodes-base.noOp',
						typeVersion: 1,
						position: [300, 0],
						parameters: {},
					},
				],
				connections: {
					'Start Node': {
						main: [[{ node: 'End Node', type: NodeConnectionTypes.Main, index: 0 }]],
					},
				},
				active: false,
				isArchived: false,
				createdAt: new Date(),
				updatedAt: new Date(),
			};

			const run = {
				data: {
					resultData: {
						runData: {}, // Empty - no nodes have executed
					},
				},
				mode: 'manual' as const,
				startedAt: new Date(),
				status: 'success' as const,
			};

			const proxy = getProxyFromFixture(workflow, run, 'End Node');

			// Test first() method
			let error: ExpressionError | undefined;
			try {
				proxy.$('Start Node').first();
			} catch (e) {
				error = e as ExpressionError;
			}
			expect(error).toBeDefined();
			expect(error!.message).toBe("Node 'Start Node' hasn't been executed");
			expect(error!.context.messageTemplate).toBe(
				'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
			);

			// Test last() method
			error = undefined;
			try {
				proxy.$('Start Node').last();
			} catch (e) {
				error = e as ExpressionError;
			}
			expect(error).toBeDefined();
			expect(error!.message).toBe("Node 'Start Node' hasn't been executed");
			expect(error!.context.messageTemplate).toBe(
				'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
			);

			// Test all() method
			error = undefined;
			try {
				proxy.$('Start Node').all();
			} catch (e) {
				error = e as ExpressionError;
			}
			expect(error).toBeDefined();
			expect(error!.message).toBe("Node 'Start Node' hasn't been executed");
			expect(error!.context.messageTemplate).toBe(
				'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
			);
		});

		test('should show helpful error message when accessing non-existent node', () => {
			const workflow: IWorkflowBase = {
				id: '1',
				name: 'test-workflow',
				nodes: [
					{
						id: '1',
						name: 'Real Node',
						type: 'n8n-nodes-base.manualTrigger',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
				],
				connections: {},
				active: false,
				isArchived: false,
				createdAt: new Date(),
				updatedAt: new Date(),
			};

			const run = {
				data: {
					resultData: {
						runData: {
							'Real Node': [
								{
									data: {
										main: [[{ json: { test: 'data' } }]],
									},
									source: [null],
									startTime: 123,
									executionTime: 456,
									executionIndex: 0,
								},
							],
						},
					},
				},
				mode: 'manual' as const,
				startedAt: new Date(),
				status: 'success' as const,
			};

			const proxy = getProxyFromFixture(workflow, run, 'Real Node');

			// Should throw helpful error when trying to access a non-existent node
			let error: ExpressionError | undefined;
			try {
				proxy.$('NonExistentNode').item;
			} catch (e) {
				error = e as ExpressionError;
			}

			expect(error).toBeDefined();
			expect(error).toBeInstanceOf(ExpressionError);
			expect(error!.message).toBe("Referenced node doesn't exist");
			expect(error!.context.descriptionKey).toBe('nodeNotFound');
			expect(error!.context.nodeCause).toBe('NonExistentNode');
		});

		test('should show error when accessing item with invalid index via direct proxy access', () => {
			// Use existing fixture data to test the item index validation path
			const fixture = loadFixture('base');

			// Create a proxy with itemIndex that exceeds available items for a node
			const proxy = getProxyFromFixture(fixture.workflow, fixture.run, 'Set Node', 'manual', {
				throwOnMissingExecutionData: true,
				runIndex: 10, // itemIndex way too high
			});

			let error: ExpressionError | undefined;
			try {
				// This should trigger the error path for invalid item index
				proxy.$('Set Node').item;
			} catch (e) {
				error = e as ExpressionError;
			}

			expect(error).toBeDefined();
			expect(error).toBeInstanceOf(ExpressionError);
		});
	});
});



================================================
FILE: packages/workflow/test/workflow.test.ts
================================================
/* eslint-disable import/order */
import { mock } from 'vitest-mock-extended';

import { UserError } from '../src/errors';
import { NodeConnectionTypes } from '../src/interfaces';
import type {
	IBinaryKeyData,
	IConnections,
	IDataObject,
	INode,
	INodeExecutionData,
	INodeParameters,
	IRunExecutionData,
	NodeParameterValueType,
} from '../src/interfaces';
import { Workflow } from '../src/workflow';

process.env.TEST_VARIABLE_1 = 'valueEnvVariable1';

// eslint-disable-next-line import/order
import * as Helpers from './helpers';

interface StubNode {
	name: string;
	parameters: INodeParameters;
	type?: string;
}

describe('Workflow', () => {
	const nodeTypes = Helpers.NodeTypes();

	const SIMPLE_WORKFLOW = new Workflow({
		nodeTypes,
		nodes: [
			{
				parameters: {},
				name: 'Start',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-1',
				position: [240, 300],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-2',
				position: [460, 300],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set1',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-3',
				position: [680, 300],
			},
		],
		connections: {
			Start: {
				main: [
					[
						{
							node: 'Set',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
			Set: {
				main: [
					[
						{
							node: 'Set1',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
		},
		active: false,
	});

	const WORKFLOW_WITH_SWITCH = new Workflow({
		active: false,
		nodeTypes,
		nodes: [
			{
				parameters: {},
				name: 'Switch',
				type: 'test.switch',
				typeVersion: 1,
				id: 'uuid-1',
				position: [460, 300],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-2',
				position: [740, 300],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set1',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-3',
				position: [780, 100],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set2',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-4',
				position: [1040, 260],
			},
		],
		connections: {
			Switch: {
				main: [
					[
						{
							node: 'Set1',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
					[
						{
							node: 'Set',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
					[
						{
							node: 'Set',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
			Set: {
				main: [
					[
						{
							node: 'Set2',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
			Set1: {
				main: [
					[
						{
							node: 'Set2',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
		},
	});

	const WORKFLOW_WITH_LOOPS = new Workflow({
		nodeTypes,
		active: false,
		nodes: [
			{
				parameters: {},
				name: 'Switch',
				type: 'test.switch',
				typeVersion: 1,
				id: 'uuid-1',
				position: [920, 340],
			},
			{
				parameters: {},
				name: 'Start',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-2',
				position: [240, 300],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set1',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-3',
				position: [700, 340],
			},
			{
				parameters: {
					options: {},
				},
				name: 'Set',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-4',
				position: [1220, 300],
			},
			{
				parameters: {},
				name: 'Switch',
				type: 'test.switch',
				typeVersion: 1,
				id: 'uuid-5',
				position: [920, 340],
			},
		],
		connections: {
			Switch: {
				main: [
					[
						{
							node: 'Set',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
					[], // todo why is null not accepted
					[
						{
							node: 'Switch',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
			Start: {
				main: [
					[
						{
							node: 'Set1',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
			Set1: {
				main: [
					[
						{
							node: 'Set1',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
						{
							node: 'Switch',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
			Set: {
				main: [
					[
						{
							node: 'Set1',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
		},
	});

	const WORKFLOW_WITH_MIXED_CONNECTIONS = new Workflow({
		nodeTypes,
		nodes: [
			{
				parameters: {},
				name: 'Start',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-1',
				position: [240, 300],
			},
			{
				parameters: {},
				name: 'AINode',
				type: 'test.ai',
				typeVersion: 1,
				id: 'uuid-2',
				position: [460, 300],
			},
			{
				parameters: {},
				name: 'Set1',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-3',
				position: [680, 300],
			},
		],
		connections: {
			Start: {
				main: [
					[
						{
							node: 'AINode',
							type: NodeConnectionTypes.AiAgent,
							index: 0,
						},
					],
				],
			},
			AINode: {
				ai: [
					[
						{
							node: 'Set1',
							type: NodeConnectionTypes.Main,
							index: 0,
						},
					],
				],
			},
		},
		active: false,
	});

	beforeEach(() => {
		vi.restoreAllMocks();
	});

	describe('renameNodeInParameterValue', () => {
		describe('for expressions', () => {
			const tests = [
				{
					description: 'do nothing if there is no expression',
					input: {
						currentName: 'Node1',
						newName: 'Node1New',
						parameters: {
							value1: 'value1Node1',
							value2: 'value2Node1',
						},
					},
					output: {
						value1: 'value1Node1',
						value2: 'value2Node1',
					},
				},
				{
					description: 'should work with dot notation',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: "={{$node.Node1.data.value1 + 'Node1'}}",
							value2: "={{$node.Node1.data.value2 + ' - ' + $node.Node1.data.value2}}",
						},
					},
					output: {
						value1: "={{$node.NewName.data.value1 + 'Node1'}}",
						value2: "={{$node.NewName.data.value2 + ' - ' + $node.NewName.data.value2}}",
					},
				},
				{
					description: 'should work with ["nodeName"]',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: '={{$node["Node1"]["data"]["value1"] + \'Node1\'}}',
							value2:
								'={{$node["Node1"]["data"]["value2"] + \' - \' + $node["Node1"]["data"]["value2"]}}',
						},
					},
					output: {
						value1: '={{$node["NewName"]["data"]["value1"] + \'Node1\'}}',
						value2:
							'={{$node["NewName"]["data"]["value2"] + \' - \' + $node["NewName"]["data"]["value2"]}}',
					},
				},
				{
					description: 'should work with $("Node1")',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: '={{$("Node1")["data"]["value1"] + \'Node1\'}}',
							value2: '={{$("Node1")["data"]["value2"] + \' - \' + $("Node1")["data"]["value2"]}}',
						},
					},
					output: {
						value1: '={{$("NewName")["data"]["value1"] + \'Node1\'}}',
						value2:
							'={{$("NewName")["data"]["value2"] + \' - \' + $("NewName")["data"]["value2"]}}',
					},
				},
				{
					description: 'should work with $items("Node1")',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: '={{$items("Node1")["data"]["value1"] + \'Node1\'}}',
							value2:
								'={{$items("Node1")["data"]["value2"] + \' - \' + $items("Node1")["data"]["value2"]}}',
						},
					},
					output: {
						value1: '={{$items("NewName")["data"]["value1"] + \'Node1\'}}',
						value2:
							'={{$items("NewName")["data"]["value2"] + \' - \' + $items("NewName")["data"]["value2"]}}',
					},
				},
				{
					description: 'should work with $items("Node1", 0, 1)',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: '={{$items("Node1", 0, 1)["data"]["value1"] + \'Node1\'}}',
							value2:
								'={{$items("Node1", 0, 1)["data"]["value2"] + \' - \' + $items("Node1", 0, 1)["data"]["value2"]}}',
						},
					},
					output: {
						value1: '={{$items("NewName", 0, 1)["data"]["value1"] + \'Node1\'}}',
						value2:
							'={{$items("NewName", 0, 1)["data"]["value2"] + \' - \' + $items("NewName", 0, 1)["data"]["value2"]}}',
					},
				},
				{
					description: 'should work with dot notation that contains space and special character',
					input: {
						currentName: 'Node1',
						newName: 'New $ Name',
						parameters: {
							value1: "={{$node.Node1.data.value1 + 'Node1'}}",
							value2: "={{$node.Node1.data.value2 + ' - ' + $node.Node1.data.value2}}",
						},
					},
					output: {
						value1: '={{$node["New $ Name"].data.value1 + \'Node1\'}}',
						value2:
							'={{$node["New $ Name"].data.value2 + \' - \' + $node["New $ Name"].data.value2}}',
					},
				},
				{
					description: 'should work with dot notation that contains space and trailing $',
					input: {
						currentName: 'Node1',
						newName: 'NewName$',
						parameters: {
							value1: "={{$node.Node1.data.value1 + 'Node1'}}",
							value2: "={{$node.Node1.data.value2 + ' - ' + $node.Node1.data.value2}}",
						},
					},
					output: {
						value1: '={{$node["NewName$"].data.value1 + \'Node1\'}}',
						value2: '={{$node["NewName$"].data.value2 + \' - \' + $node["NewName$"].data.value2}}',
					},
				},
				{
					description: 'should work with dot notation that contains space and special character',
					input: {
						currentName: 'Node1',
						newName: 'NewName $ $& $` $$$',
						parameters: {
							value1: "={{$node.Node1.data.value1 + 'Node1'}}",
							value2: "={{$node.Node1.data.value2 + ' - ' + $node.Node1.data.value2}}",
						},
					},
					output: {
						value1: '={{$node["NewName $ $& $` $$$"].data.value1 + \'Node1\'}}',
						value2:
							'={{$node["NewName $ $& $` $$$"].data.value2 + \' - \' + $node["NewName $ $& $` $$$"].data.value2}}',
					},
				},
				{
					description: 'should work with dot notation without trailing dot',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: "={{$node.Node1 + 'Node1'}}",
							value2: "={{$node.Node1 + ' - ' + $node.Node1}}",
						},
					},
					output: {
						value1: "={{$node.NewName + 'Node1'}}",
						value2: "={{$node.NewName + ' - ' + $node.NewName}}",
					},
				},
				{
					description: "should work with ['nodeName']",
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							value1: "={{$node['Node1']['data']['value1'] + 'Node1'}}",
							value2:
								"={{$node['Node1']['data']['value2'] + ' - ' + $node['Node1']['data']['value2']}}",
						},
					},
					output: {
						value1: "={{$node['NewName']['data']['value1'] + 'Node1'}}",
						value2:
							"={{$node['NewName']['data']['value2'] + ' - ' + $node['NewName']['data']['value2']}}",
					},
				},
				{
					description: 'should work on lower levels',
					input: {
						currentName: 'Node1',
						newName: 'NewName',
						parameters: {
							level1a: "={{$node.Node1.data.value1 + 'Node1'}}",
							level1b: [
								{
									value2a: "={{$node.Node1.data.value1 + 'Node1'}}",
									value2b: "={{$node.Node1.data.value1 + 'Node1'}}",
								},
							],
							level1c: {
								value2a: {
									value3a: "={{$node.Node1.data.value1 + 'Node1'}}",
									value3b: [
										{
											value4a: "={{$node.Node1.data.value1 + 'Node1'}}",
											value4b: {
												value5a: "={{$node.Node1.data.value1 + 'Node1'}}",
												value5b: "={{$node.Node1.data.value1 + 'Node1'}}",
											},
										},
									],
								},
							},
						} as INodeParameters,
					},
					output: {
						level1a: "={{$node.NewName.data.value1 + 'Node1'}}",
						level1b: [
							{
								value2a: "={{$node.NewName.data.value1 + 'Node1'}}",
								value2b: "={{$node.NewName.data.value1 + 'Node1'}}",
							},
						],
						level1c: {
							value2a: {
								value3a: "={{$node.NewName.data.value1 + 'Node1'}}",
								value3b: [
									{
										value4a: "={{$node.NewName.data.value1 + 'Node1'}}",
										value4b: {
											value5a: "={{$node.NewName.data.value1 + 'Node1'}}",
											value5b: "={{$node.NewName.data.value1 + 'Node1'}}",
										},
									},
								],
							},
						},
					},
				},
			];

			const workflow = new Workflow({ nodes: [], connections: {}, active: false, nodeTypes });

			for (const testData of tests) {
				test(testData.description, () => {
					const result = workflow.renameNodeInParameterValue(
						testData.input.parameters,
						testData.input.currentName,
						testData.input.newName,
					);
					expect(result).toEqual(testData.output);
				});
			}
		});

		describe('for node with renamable content', () => {
			const tests = [
				{
					description: "should work with $('name')",
					input: {
						currentName: 'Old',
						newName: 'New',
						parameters: { jsCode: "$('Old').first();" },
					},
					output: { jsCode: "$('New').first();" },
				},
				{
					description: "should work with $node['name'] and $node.name",
					input: {
						currentName: 'Old',
						newName: 'New',
						parameters: { jsCode: "$node['Old'].first(); $node.Old.first();" },
					},
					output: { jsCode: "$node['New'].first(); $node.New.first();" },
				},
				{
					description: 'should work with $items()',
					input: {
						currentName: 'Old',
						newName: 'New',
						parameters: { jsCode: "$items('Old').first();" },
					},
					output: { jsCode: "$items('New').first();" },
				},
			];

			const workflow = new Workflow({
				nodes: [],
				connections: {},
				active: false,
				nodeTypes,
			});

			for (const t of tests) {
				test(t.description, () => {
					expect(
						workflow.renameNodeInParameterValue(
							t.input.parameters,
							t.input.currentName,
							t.input.newName,
							{ hasRenamableContent: true },
						),
					).toEqual(t.output);
				});
			}
		});
	});

	describe('renameNode', () => {
		const tests = [
			{
				description: 'rename node without connections',
				input: {
					currentName: 'Node1',
					newName: 'Node1New',
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
					],
					connections: {},
				},
				output: {
					nodes: [
						{
							name: 'Node1New',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
					],
					connections: {},
				},
			},
			{
				description: 'rename node with one output connection',
				input: {
					currentName: 'Node1',
					newName: 'Node1New',
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: 'value1Node2',
								value2: 'value2Node2',
							},
						},
					],
					connections: {
						Node1: {
							main: [
								[
									{
										node: 'Node2',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
					},
				},
				output: {
					nodes: [
						{
							name: 'Node1New',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: 'value1Node2',
								value2: 'value2Node2',
							},
						},
					],
					connections: {
						Node1New: {
							main: [
								[
									{
										node: 'Node2',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
					},
				},
			},
			{
				description: 'rename node with one input connection',
				input: {
					currentName: 'Node2',
					newName: 'Node2New',
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: 'value1Node2',
								value2: 'value2Node2',
							},
						},
					],
					connections: {
						Node1: {
							main: [
								[
									{
										node: 'Node2',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
					},
				},
				output: {
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2New',
							parameters: {
								value1: 'value1Node2',
								value2: 'value2Node2',
							},
						},
					],
					connections: {
						Node1: {
							main: [
								[
									{
										node: 'Node2New',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
					},
				},
			},
			{
				description: 'rename node with multiple input and output connection',
				input: {
					currentName: 'Node3',
					newName: 'Node3New',
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: 'value1Node2',
								value2: 'value2Node2',
							},
						},
						{
							name: 'Node3',
							parameters: {
								value1: 'value1Node3',
								value2: 'value2Node3',
							},
						},
						{
							name: 'Node4',
							parameters: {
								value1: 'value1Node4',
								value2: 'value2Node4',
							},
						},
						{
							name: 'Node5',
							parameters: {
								value1: 'value1Node5',
								value2: 'value2Node5',
							},
						},
					],
					connections: {
						Node1: {
							main: [
								[
									{
										node: 'Node3',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
						Node2: {
							main: [
								[
									{
										node: 'Node3',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
									{
										node: 'Node5',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
						Node3: {
							main: [
								[
									{
										node: 'Node4',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
									{
										node: 'Node5',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
					},
				},
				output: {
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: 'value1Node2',
								value2: 'value2Node2',
							},
						},
						{
							name: 'Node3New',
							parameters: {
								value1: 'value1Node3',
								value2: 'value2Node3',
							},
						},
						{
							name: 'Node4',
							parameters: {
								value1: 'value1Node4',
								value2: 'value2Node4',
							},
						},
						{
							name: 'Node5',
							parameters: {
								value1: 'value1Node5',
								value2: 'value2Node5',
							},
						},
					],
					connections: {
						Node1: {
							main: [
								[
									{
										node: 'Node3New',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
						Node2: {
							main: [
								[
									{
										node: 'Node3New',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
									{
										node: 'Node5',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
						Node3New: {
							main: [
								[
									{
										node: 'Node4',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
									{
										node: 'Node5',
										type: NodeConnectionTypes.Main,
										index: 0,
									},
								],
							],
						},
					},
				},
			},
			{
				description: 'rename node with jsCode parameter',
				input: {
					currentName: 'Node1',
					newName: 'Node1New',
					nodes: [
						{
							name: 'Node1',
							type: 'n8n-nodes-base.code',
							parameters: {
								jsCode: '$("Node1").params',
							},
						},
					],
					connections: {},
				},
				output: {
					nodes: [
						{
							name: 'Node1New',
							type: 'n8n-nodes-base.code',
							parameters: {
								jsCode: '$("Node1New").params',
							},
						},
					],
					connections: {},
				},
			},
			{
				description: 'rename node with html parameter',
				input: {
					currentName: 'Node1',
					newName: 'Node1New',
					nodes: [
						{
							name: 'Node1',
							type: 'n8n-nodes-base.html',
							parameters: {
								html: '$("Node1").params',
							},
						},
					],
					connections: {},
				},
				output: {
					nodes: [
						{
							name: 'Node1New',
							type: 'n8n-nodes-base.html',
							parameters: {
								html: '$("Node1New").params',
							},
						},
					],
					connections: {},
				},
			},
			{
				description: 'rename form node with html parameter',
				input: {
					currentName: 'Node1',
					newName: 'Node1New',
					nodes: [
						{
							name: 'Node1',
							type: 'n8n-nodes-base.form',
							parameters: {
								formFields: {
									values: [
										{
											fieldType: 'html',
											html: '$("Node1").params',
											elementName: '$("Node1").params',
										},
									],
								},
							},
						},
					],
					connections: {},
				},
				output: {
					nodes: [
						{
							name: 'Node1New',
							type: 'n8n-nodes-base.form',
							parameters: {
								formFields: {
									values: [
										{
											fieldType: 'html',
											html: '$("Node1New").params',
											elementName: '$("Node1").params',
										},
									],
								},
							},
						},
					],
					connections: {},
				},
			},
			// This does just a basic test if "renameNodeInParameterValue" gets used. More complex
			// tests with different formats and levels are in the separate tests for the function
			// "renameNodeInParameterValue"
			{
				description: 'change name also in expressions which use node-name (dot notation)',
				input: {
					currentName: 'Node1',
					newName: 'Node1New',
					nodes: [
						{
							name: 'Node1',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: "={{$node.Node1.data.value1 + 'Node1'}}",
								value2: "={{$node.Node1.data.value2 + ' - ' + $node.Node1.data.value2}}",
							},
						},
					],
					connections: {},
				},
				output: {
					nodes: [
						{
							name: 'Node1New',
							parameters: {
								value1: 'value1Node1',
								value2: 'value2Node1',
							},
						},
						{
							name: 'Node2',
							parameters: {
								value1: "={{$node.Node1New.data.value1 + 'Node1'}}",
								value2: "={{$node.Node1New.data.value2 + ' - ' + $node.Node1New.data.value2}}",
							},
						},
					],
					connections: {},
				},
			},
		];

		let workflow: Workflow;

		function createNodeData(stubData: StubNode): INode {
			return {
				name: stubData.name,
				parameters: stubData.parameters,
				type: stubData.type ?? 'test.set',
				typeVersion: 1,
				id: 'uuid-1234',
				position: [100, 100],
			};
		}

		let executeNodes: INode[];
		let resultNodes: {
			[key: string]: INode;
		};

		for (const testData of tests) {
			test(testData.description, () => {
				executeNodes = [];
				for (const node of testData.input.nodes) {
					executeNodes.push(createNodeData(node));
				}

				workflow = new Workflow({
					nodes: executeNodes,
					connections: testData.input.connections as IConnections,
					active: false,
					nodeTypes,
				});
				workflow.renameNode(testData.input.currentName, testData.input.newName);

				resultNodes = {};
				for (const node of testData.output.nodes) {
					resultNodes[node.name] = createNodeData(node);
				}

				expect(workflow.nodes).toEqual(resultNodes);
				expect(workflow.connectionsBySourceNode).toEqual(testData.output.connections);
			});
		}

		describe('with restricted node names', () => {
			const restrictedNames = [
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'toLocaleString',
				'toString',
				'valueOf',
				'constructor',
				'prototype',
				'__proto__',
				'__defineGetter__',
				'__defineSetter__',
				'__lookupGetter__',
				'__lookupSetter__',
			];

			test.each(restrictedNames)(
				'should throw error when renaming node to %s',
				(restrictedName) => {
					const workflow = new Workflow({
						nodes: [
							{
								name: 'Node1',
								parameters: {},
								type: 'test.set',
								typeVersion: 1,
								id: 'uuid-1',
								position: [100, 100],
							},
						],
						connections: {},
						active: false,
						nodeTypes,
					});

					expect(() => workflow.renameNode('Node1', restrictedName)).toThrow(
						`Node name "${restrictedName}" is a restricted name.`,
					);
				},
			);

			test.each(restrictedNames)(
				'should throw error when renaming node to %s with different case',
				(restrictedName) => {
					const workflow = new Workflow({
						nodes: [
							{
								name: 'Node1',
								parameters: {},
								type: 'test.set',
								typeVersion: 1,
								id: 'uuid-1',
								position: [100, 100],
							},
						],
						connections: {},
						active: false,
						nodeTypes,
					});

					const upperCaseName = restrictedName.toUpperCase();
					expect(() => workflow.renameNode('Node1', upperCaseName)).toThrow(
						`Node name "${upperCaseName}" is a restricted name.`,
					);
				},
			);

			test('should throw error with proper description', () => {
				const workflow = new Workflow({
					nodes: [
						{
							name: 'Node1',
							parameters: {},
							type: 'test.set',
							typeVersion: 1,
							id: 'uuid-1',
							position: [100, 100],
						},
					],
					connections: {},
					active: false,
					nodeTypes,
				});

				try {
					workflow.renameNode('Node1', 'toString');
				} catch (error) {
					if (!(error instanceof UserError)) {
						throw new Error('Expected error to be an instance of UserError');
					}
					expect(error).toBeInstanceOf(UserError);
					expect(error.message).toBe('Node name "toString" is a restricted name.');
					expect(error.description).toBe(
						'Node names cannot be any of the following: hasOwnProperty, isPrototypeOf, propertyIsEnumerable, toLocaleString, toString, valueOf, constructor, prototype, __proto__, __defineGetter__, __defineSetter__, __lookupGetter__, __lookupSetter__',
					);
				}
			});

			test('should allow renaming to names that contain restricted names as substring', () => {
				const workflow = new Workflow({
					nodes: [
						{
							name: 'Node1',
							parameters: {},
							type: 'test.set',
							typeVersion: 1,
							id: 'uuid-1',
							position: [100, 100],
						},
					],
					connections: {},
					active: false,
					nodeTypes,
				});

				// These should not throw as they're not exact matches
				expect(() => workflow.renameNode('Node1', 'myToString')).not.toThrow();
				expect(() => workflow.renameNode('Node1', 'toStringNode')).not.toThrow();
				expect(() => workflow.renameNode('Node1', 'hasOwnPropertyChecker')).not.toThrow();
			});
		});
	});

	describe('getParameterValue', () => {
		const tests: Array<{
			description: string;
			input: {
				[nodeName: string]: {
					parameters: Record<string, NodeParameterValueType>;
					outputJson?: IDataObject;
					outputBinary?: IBinaryKeyData;
				};
			};
			output: Record<string, unknown>;
		}> = [
			{
				description: 'read simple not expression value',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: 'valueNode2',
						},
					},
				},
				output: {
					value1: 'valueNode2',
				},
			},
			{
				description: 'read simple math expression',
				input: {
					Node1: {
						parameters: {
							value1: '',
						},
					},
					Node2: {
						parameters: {
							value1: '={{1+2}}',
						},
					},
				},
				output: {
					value1: 3,
				},
			},
			{
				description: 'read data from node-output-data with with long "$node.{NODE}.data" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node.Node1.data.value1}}',
						},
					},
				},
				output: {
					value1: 'valueNode1',
				},
			},
			{
				description:
					'read data from node-output-data with with long "$node.{NODE}.data" syntax add value and append text',
				input: {
					Node1: {
						parameters: {
							value1: 1,
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node.Node1.data.value1 + 2}} asdf',
						},
					},
				},
				output: {
					value1: '3 asdf',
				},
			},
			{
				description:
					'read deep-data from node-output-data with with long "$node.{NODE}.data" syntax with JavaScript Code',
				input: {
					Node1: {
						parameters: {
							value1: 'whatever',
						},
						// Overwrite the output data
						outputJson: {
							value1: {
								a: 1,
								b: 2,
								c: 3,
							},
						},
					},
					Node2: {
						parameters: {
							value1: '={{Object.keys($node.Node1.data.value1).join(", ")}}',
						},
					},
				},
				output: {
					value1: 'a, b, c',
				},
			},
			{
				description: 'read data from incoming-node-data with with short "data" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$data.value1}}',
						},
					},
				},
				output: {
					value1: 'valueNode1',
				},
			},
			{
				description: 'read deep-data from incoming-node-data with with short "data" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'whatever',
						},
						// Overwrite the output data
						outputJson: {
							value1: {
								a: {
									b: 'deepDataNode1',
								},
							},
						},
					},
					Node2: {
						parameters: {
							value1: '={{$data.value1.a.b}}',
						},
					},
				},
				output: {
					value1: 'deepDataNode1',
				},
			},
			{
				description:
					'read deep-data from node-output-data with with long "$node.{NODE}.data" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'whatever',
						},
						// Overwrite the output data
						outputJson: {
							value1: {
								a: {
									b: 'deepDataNode1',
								},
							},
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node.Node1.data.value1.a.b}}',
						},
					},
				},
				output: {
					value1: 'deepDataNode1',
				},
			},
			{
				description:
					'read binary-string-data from incoming-node-data with with short "$binary" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'whatever',
						},
						// Overwrite the output data
						outputBinary: {
							binaryKey: {
								data: '',
								type: '',
								mimeType: 'test',
								fileName: 'test-file1.jpg',
							},
						},
					},
					Node2: {
						parameters: {
							value1: '={{$binary.binaryKey.fileName}}',
						},
					},
				},
				output: {
					value1: 'test-file1.jpg',
				},
			},
			{
				description:
					'read binary-string-data from node-output-data with with long "$node.{NODE}.binary" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'whatever',
						},
						// Overwrite the output data
						outputBinary: {
							binaryKey: {
								data: '',
								type: '',
								mimeType: 'test',
								fileName: 'test-file1.jpg',
							},
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node.Node1.binary.binaryKey.fileName}}',
						},
					},
				},
				output: {
					value1: 'test-file1.jpg',
				},
			},
			{
				description: 'read parameter from other node with with long "$node.parameter" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node.Node1.parameter.value1}}',
						},
					},
				},
				output: {
					value1: 'valueNode1',
				},
			},
			{
				description: 'read environment data "$env" syntax which exists',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$env.TEST_VARIABLE_1}}',
						},
					},
				},
				output: {
					value1: 'valueEnvVariable1',
				},
			},
			{
				description: 'read environment data "$env" syntax which does not exists',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$env.DOES_NOT_EXIST}}',
						},
					},
				},
				output: {
					value1: undefined,
				},
			},
			{
				description: 'read parameter from current node with short "$parameter" syntax',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: 'valueNode2',
							value2: '={{$parameter.value1}}',
						},
					},
				},
				output: {
					value1: 'valueNode2',
					value2: 'valueNode2',
				},
			},
			{
				description:
					'return resolved value when referencing another property with expression (long "$node.{NODE}.data" syntax)',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node.Node1.data.value1}}',
							value2: '={{$parameter.value1}}',
						},
					},
				},
				output: {
					value1: 'valueNode1',
					value2: 'valueNode1',
				},
			},
			{
				description:
					'return resolved value when referencing another property with expression (short "data" syntax)',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$data.value1}}',
							value2: '={{$parameter.value1}}',
						},
					},
				},
				output: {
					value1: 'valueNode1',
					value2: 'valueNode1',
				},
			},
			{
				description:
					'return resolved value when referencing another property with expression when a node has spaces (long "$node["{NODE}"].parameter" syntax)',
				input: {
					'Node 4 with spaces': {
						parameters: {
							value1: '',
						},
					},
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node["Node 4 with spaces"].parameter.value1}}',
						},
					},
				},
				output: {
					value1: 'default-value1',
				},
			},
			{
				description:
					'return resolved value when referencing another property with expression on another node (long "$node["{NODE}"].parameter" syntax)',
				input: {
					Node1: {
						parameters: {
							value1: 'valueNode1',
						},
					},
					Node2: {
						parameters: {
							value1: '={{$node["Node1"].parameter.value1}}a',
						},
					},
					Node3: {
						parameters: {
							value1: '={{$node["Node2"].parameter.value1}}b',
						},
					},
				},
				output: {
					value1: 'valueNode1ab',
				},
			},
			// TODO: Make that this test does not fail!
			// {
			//     description: 'return resolved value when short "data" syntax got used in expression on parameter of not active node which got referenced by active one',
			//     input: {
			//         Node1: {
			//             parameters: {
			//                 value1: 'valueNode1',
			//             }
			//         },
			//         Node2: {
			//             parameters: {
			//                 value1: '={{$data.value1}}-Node2',
			//             },
			//         },
			//         Node3: {
			//             parameters: {
			//                 value1: '={{$data.value1}}-Node3+1',
			//                 value2: '={{node.Node2.data.value1}}-Node3+2',
			//             },
			//         }
			//     },
			//     output: {
			//         value1: 'valueNode1-Node2-Node3+1',
			//         value2: 'valueNode1-Node2-Node3+2',
			//     },
			// },
		];

		const nodeTypes = Helpers.NodeTypes();

		for (const testData of tests) {
			test(testData.description, () => {
				const nodes: INode[] = [
					{
						name: 'Node1',
						parameters: testData.input.Node1.parameters,
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
					},
					{
						name: 'Node2',
						parameters: testData.input.Node2.parameters,
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-2',
						position: [100, 200],
					},
					{
						name: 'Node3',
						parameters: testData.input.hasOwnProperty('Node3')
							? testData.input.Node3?.parameters
							: {},
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-3',
						position: [100, 300],
					},
					{
						name: 'Node 4 with spaces',
						parameters: testData.input.hasOwnProperty('Node4')
							? testData.input.Node4.parameters
							: {},
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-4',
						position: [100, 400],
					},
				];
				const connections: IConnections = {
					Node1: {
						main: [
							[
								{
									node: 'Node2',
									type: NodeConnectionTypes.Main,
									index: 0,
								},
							],
						],
					},
					Node2: {
						main: [
							[
								{
									node: 'Node3',
									type: NodeConnectionTypes.Main,
									index: 0,
								},
							],
						],
					},
					'Node 4 with spaces': {
						main: [
							[
								{
									node: 'Node2',
									type: NodeConnectionTypes.Main,
									index: 0,
								},
							],
						],
					},
				};

				const workflow = new Workflow({ nodes, connections, active: false, nodeTypes });
				const activeNodeName = testData.input.hasOwnProperty('Node3') ? 'Node3' : 'Node2';

				const runExecutionData: IRunExecutionData = {
					resultData: {
						runData: {
							Node1: [
								{
									source: [
										{
											previousNode: 'test',
										},
									],
									startTime: 1,
									executionTime: 1,
									executionIndex: 0,
									data: {
										main: [
											[
												{
													json: testData.input.Node1.outputJson || testData.input.Node1.parameters,
													binary: testData.input.Node1.outputBinary,
												},
											],
										],
									},
								},
							],
							Node2: [],
							'Node 4 with spaces': [],
						},
					},
				};

				const itemIndex = 0;
				const runIndex = 0;
				const connectionInputData: INodeExecutionData[] =
					runExecutionData.resultData.runData.Node1[0].data!.main[0]!;

				for (const parameterName of Object.keys(testData.output)) {
					const parameterValue = nodes.find((node) => node.name === activeNodeName)!.parameters[
						parameterName
					];
					const result = workflow.expression.getParameterValue(
						parameterValue,
						runExecutionData,
						runIndex,
						itemIndex,
						activeNodeName,
						connectionInputData,
						'manual',
						{},
					);
					expect(result).toEqual(testData.output[parameterName]);
				}
			});
		}

		test('should also resolve all child parameters when the parent get requested', () => {
			const nodes: INode[] = [
				{
					name: 'Node1',
					parameters: {
						values: {
							string: [
								{
									name: 'name1',
									value: 'value1',
								},
								{
									name: 'name2',
									value: '={{$parameter.values.string[0].value}}A',
								},
							],
						},
					},
					type: 'test.setMulti',
					typeVersion: 1,
					id: 'uuid-1234',
					position: [100, 100],
				},
			];
			const connections: IConnections = {};

			const workflow = new Workflow({ nodes, connections, active: false, nodeTypes });
			const activeNodeName = 'Node1';

			const runExecutionData: IRunExecutionData = {
				resultData: {
					runData: {
						Node1: [
							{
								startTime: 1,
								executionTime: 1,
								executionIndex: 0,
								data: {
									main: [
										[
											{
												json: {},
											},
										],
									],
								},
								source: [],
							},
						],
					},
				},
			};

			const itemIndex = 0;
			const runIndex = 0;
			const connectionInputData: INodeExecutionData[] =
				runExecutionData.resultData.runData.Node1[0].data!.main[0]!;
			const parameterName = 'values';

			const parameterValue = nodes.find((node) => node.name === activeNodeName)!.parameters[
				parameterName
			];
			const result = workflow.expression.getParameterValue(
				parameterValue,
				runExecutionData,
				runIndex,
				itemIndex,
				activeNodeName,
				connectionInputData,
				'manual',
				{},
			);

			expect(result).toEqual({
				string: [
					{
						name: 'name1',
						value: 'value1',
					},
					{
						name: 'name2',
						value: 'value1A',
					},
				],
			});
		});
	});

	describe('getParentNodesByDepth', () => {
		test('Should return parent nodes of nodes', () => {
			expect(SIMPLE_WORKFLOW.getParentNodesByDepth('Start')).toEqual([]);
			expect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set')).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Start',
				},
			]);
			expect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1')).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Set',
				},
				{
					depth: 2,
					indicies: [0],
					name: 'Start',
				},
			]);
		});

		test('Should return parent up to depth', () => {
			expect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 0)).toEqual([]);
			expect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 1)).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Set',
				},
			]);
		});

		test('Should return all parents with depth of -1', () => {
			expect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', -1)).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Set',
				},
				{
					depth: 2,
					indicies: [0],
					name: 'Start',
				},
			]);
		});

		test('Should return parents of nodes with all connected output indicies', () => {
			expect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Switch')).toEqual([]);
			expect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set1')).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Switch',
				},
			]);
			expect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set')).toEqual([
				{
					depth: 1,
					indicies: [1, 2],
					name: 'Switch',
				},
			]);

			expect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set2')).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Set',
				},
				{
					depth: 1,
					indicies: [0],
					name: 'Set1',
				},
				{
					depth: 2,
					indicies: [1, 2, 0],
					name: 'Switch',
				},
			]);
		});

		test('Should handle loops within workflows', () => {
			expect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Start')).toEqual([]);
			expect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set')).toEqual([
				{
					depth: 1,
					indicies: [0, 2],
					name: 'Switch',
				},
				{
					depth: 2,
					indicies: [0],
					name: 'Set1',
				},
				{
					depth: 3,
					indicies: [0],
					name: 'Start',
				},
			]);
			expect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Switch')).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Set1',
				},
				{
					depth: 2,
					indicies: [0],
					name: 'Start',
				},
				{
					depth: 2,
					indicies: [0],
					name: 'Set',
				},
			]);
			expect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set1')).toEqual([
				{
					depth: 1,
					indicies: [0],
					name: 'Start',
				},
				{
					depth: 1,
					indicies: [0],
					name: 'Set',
				},
				{
					depth: 2,
					indicies: [0, 2],
					name: 'Switch',
				},
			]);
		});
	});

	describe('getHighestNode', () => {
		const createNode = (name: string, disabled = false) =>
			({
				name,
				type: 'test.set',
				typeVersion: 1,
				disabled,
				position: [0, 0],
				parameters: {},
			}) as INode;

		test('should return node name if node is not disabled', () => {
			const node = createNode('Node1');
			const workflow = new Workflow({
				id: 'test',
				nodes: [node],
				connections: {},
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(node.name);
			expect(result).toEqual([node.name]);
		});

		test('should return empty array if node is disabled', () => {
			const node = createNode('Node1', true);
			const workflow = new Workflow({
				id: 'test',
				nodes: [node],
				connections: {},
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(node.name);
			expect(result).toEqual([]);
		});

		test('should return highest nodes when multiple parent nodes exist', () => {
			const node1 = createNode('Node1');
			const node2 = createNode('Node2');
			const node3 = createNode('Node3');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node1: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				Node2: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, node2, node3, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(targetNode.name);
			expect(result).toEqual([node1.name, node2.name]);
		});

		test('should ignore disabled parent nodes', () => {
			const node1 = createNode('Node1', true);
			const node2 = createNode('Node2');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node1: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				Node2: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, node2, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(targetNode.name);
			expect(result).toEqual([node2.name]);
		});

		test('should handle nested connections', () => {
			const node1 = createNode('Node1');
			const node2 = createNode('Node2');
			const node3 = createNode('Node3');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node3: {
					main: [
						[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 }],
						[{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 }],
					],
				},
				TargetNode: {
					main: [[{ node: 'Node3', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, node2, node3, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(targetNode.name);
			expect(result).toEqual([targetNode.name]);
		});

		test('should handle specified connection index', () => {
			const node1 = createNode('Node1');
			const node2 = createNode('Node2');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node1: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				Node2: {
					main: [[], [{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 1 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, node2, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const resultFirstIndex = workflow.getHighestNode(targetNode.name, 0);
			const resultSecondIndex = workflow.getHighestNode(targetNode.name, 1);

			expect(resultFirstIndex).toEqual([node1.name]);
			expect(resultSecondIndex).toEqual([node2.name]);
		});

		test('should prevent infinite loops with cyclic connections', () => {
			const node1 = createNode('Node1');
			const node2 = createNode('Node2');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node1: {
					main: [[{ node: 'Node2', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				Node2: {
					main: [[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				TargetNode: {
					main: [[{ node: 'Node1', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, node2, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(targetNode.name);
			expect(result).toEqual([targetNode.name]);
		});

		test('should handle connections to nodes that are not defined in the workflow', () => {
			const node1 = createNode('Node1');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node1: {
					main: [[{ node: 'NonExistentNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				TargetNode: {
					main: [[{ node: 'NonExistentNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(targetNode.name);

			expect(result).toEqual([targetNode.name]);
		});

		test('should handle connections from nodes that are not defined in the workflow', () => {
			const node1 = createNode('Node1');
			const targetNode = createNode('TargetNode');

			const connections = {
				Node1: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				NonExistentNode: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [node1, targetNode],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getHighestNode(targetNode.name);
			expect(result).toEqual([node1.name]);
		});
	});

	describe('getParentMainInputNode', () => {
		test('should return the node itself if no parent connections exist', () => {
			const startNode = SIMPLE_WORKFLOW.getNode('Start')!;
			const result = SIMPLE_WORKFLOW.getParentMainInputNode(startNode);
			expect(result).toBe(startNode);
		});

		test('should return direct main input parent node', () => {
			const set1Node = SIMPLE_WORKFLOW.getNode('Set1')!;
			const result = SIMPLE_WORKFLOW.getParentMainInputNode(set1Node);
			expect(result).toBe(set1Node);
		});

		test('should traverse through non-main connections to find main input', () => {
			const set1Node = WORKFLOW_WITH_MIXED_CONNECTIONS.getNode('Set1')!;
			const result = WORKFLOW_WITH_MIXED_CONNECTIONS.getParentMainInputNode(set1Node);
			expect(result).toBe(set1Node);
		});

		test('should handle nested non-main connections', () => {
			const set1Node = WORKFLOW_WITH_LOOPS.getNode('Set1')!;
			const result = WORKFLOW_WITH_LOOPS.getParentMainInputNode(set1Node);
			expect(result).toBe(set1Node);
		});
	});

	describe('getNodeConnectionIndexes', () => {
		test('should return undefined for non-existent parent node', () => {
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes('Set', 'NonExistentNode');
			expect(result).toBeUndefined();
		});

		test('should return undefined for nodes without connections', () => {
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes('Start', 'Set1');
			expect(result).toBeUndefined();
		});

		test('should return correct connection indexes for direct connections', () => {
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes('Set', 'Start');
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should return correct connection indexes for multi-step connections', () => {
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes('Set1', 'Start');
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should return undefined when no connection exists', () => {
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes(
				'Start',
				'Set',
				NodeConnectionTypes.Main,
			);
			expect(result).toBeUndefined();
		});

		test('should handle workflows with multiple connection indexes', () => {
			const result = WORKFLOW_WITH_SWITCH.getNodeConnectionIndexes('Set', 'Switch');
			expect(result).toEqual({
				sourceIndex: 1,
				destinationIndex: 0,
			});
		});

		test('should find connection through multiple intermediate nodes', () => {
			const result = WORKFLOW_WITH_SWITCH.getNodeConnectionIndexes('Set2', 'Switch');
			expect(result).toEqual({
				sourceIndex: 1,
				destinationIndex: 0,
			});
		});

		test('should return first found connection when multiple paths exist', () => {
			// Set2 can be reached from Switch via two paths: Switch->Set->Set2 and Switch->Set1->Set2
			// Should return the first one found (via Set at index 1)
			const result = WORKFLOW_WITH_SWITCH.getNodeConnectionIndexes('Set2', 'Switch');
			expect(result).toEqual({
				sourceIndex: 1,
				destinationIndex: 0,
			});
		});

		test('should handle same source connecting to multiple outputs of destination', () => {
			// Switch connects to Set via both output 1 and 2, should find first connection
			const result = WORKFLOW_WITH_SWITCH.getNodeConnectionIndexes('Set', 'Switch');
			expect(result).toEqual({
				sourceIndex: 1,
				destinationIndex: 0,
			});
		});

		test('should handle cyclic connections without infinite loops', () => {
			// Test with WORKFLOW_WITH_LOOPS which has cycles
			const result = WORKFLOW_WITH_LOOPS.getNodeConnectionIndexes('Set', 'Start');
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should return undefined for reverse connection lookup', () => {
			// Try to find Start from Set1 - should be undefined as Start doesn't connect to Set1
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes('Set1', 'Start');
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should handle disconnected subgraphs', () => {
			// Create a workflow with disconnected nodes
			const disconnectedWorkflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						name: 'Node1',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
						parameters: {},
					},
					{
						name: 'Node2',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-2',
						position: [200, 100],
						parameters: {},
					},
				],
				connections: {}, // No connections
				active: false,
			});

			const result = disconnectedWorkflow.getNodeConnectionIndexes('Node2', 'Node1');
			expect(result).toBeUndefined();
		});

		test('should handle empty workflow', () => {
			const emptyWorkflow = new Workflow({
				nodeTypes,
				nodes: [],
				connections: {},
				active: false,
			});

			const result = emptyWorkflow.getNodeConnectionIndexes('NonExistent1', 'NonExistent2');
			expect(result).toBeUndefined();
		});

		test('should handle single node workflow', () => {
			const singleNodeWorkflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						name: 'OnlyNode',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
						parameters: {},
					},
				],
				connections: {},
				active: false,
			});

			const result = singleNodeWorkflow.getNodeConnectionIndexes('OnlyNode', 'OnlyNode');
			expect(result).toBeUndefined();
		});

		test('should handle nodes with same names as method parameters', () => {
			// Test edge case where node names might conflict with internal variables
			const edgeCaseWorkflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						name: 'queue',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
						parameters: {},
					},
					{
						name: 'visitedNodes',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-2',
						position: [200, 100],
						parameters: {},
					},
				],
				connections: {
					queue: {
						main: [
							[
								{
									node: 'visitedNodes',
									type: NodeConnectionTypes.Main,
									index: 0,
								},
							],
						],
					},
				},
				active: false,
			});

			const result = edgeCaseWorkflow.getNodeConnectionIndexes('visitedNodes', 'queue');
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should handle complex branching and merging patterns', () => {
			// Create a diamond pattern: A -> B, A -> C, B -> D, C -> D
			const diamondWorkflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						name: 'A',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
						parameters: {},
					},
					{
						name: 'B',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-2',
						position: [200, 50],
						parameters: {},
					},
					{
						name: 'C',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-3',
						position: [200, 150],
						parameters: {},
					},
					{
						name: 'D',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-4',
						position: [300, 100],
						parameters: {},
					},
				],
				connections: {
					A: {
						main: [
							[
								{ node: 'B', type: NodeConnectionTypes.Main, index: 0 },
								{ node: 'C', type: NodeConnectionTypes.Main, index: 0 },
							],
						],
					},
					B: {
						main: [[{ node: 'D', type: NodeConnectionTypes.Main, index: 0 }]],
					},
					C: {
						main: [[{ node: 'D', type: NodeConnectionTypes.Main, index: 1 }]],
					},
				},
				active: false,
			});

			// Should find connection A -> B -> D
			const result = diamondWorkflow.getNodeConnectionIndexes('D', 'A');
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should handle multiple input indexes correctly', () => {
			// Test a node that receives inputs at different indexes
			const multiInputWorkflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						name: 'Source1',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
						parameters: {},
					},
					{
						name: 'Source2',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-2',
						position: [100, 200],
						parameters: {},
					},
					{
						name: 'Target',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-3',
						position: [300, 150],
						parameters: {},
					},
				],
				connections: {
					Source1: {
						main: [[{ node: 'Target', type: NodeConnectionTypes.Main, index: 0 }]],
					},
					Source2: {
						main: [[{ node: 'Target', type: NodeConnectionTypes.Main, index: 1 }]],
					},
				},
				active: false,
			});

			// Check connection from Source1 to Target (should be at input index 0)
			const result1 = multiInputWorkflow.getNodeConnectionIndexes('Target', 'Source1');
			expect(result1).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});

			// Check connection from Source2 to Target (should be at input index 1)
			const result2 = multiInputWorkflow.getNodeConnectionIndexes('Target', 'Source2');
			expect(result2).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});
		});

		test('should respect connection type parameter', () => {
			// Test with different connection types if available
			const result = SIMPLE_WORKFLOW.getNodeConnectionIndexes(
				'Set',
				'Start',
				NodeConnectionTypes.Main,
			);
			expect(result).toEqual({
				sourceIndex: 0,
				destinationIndex: 0,
			});

			// Test with non-existent connection type (should return undefined)
			const resultNonExistent = SIMPLE_WORKFLOW.getNodeConnectionIndexes(
				'Set',
				'Start',
				'nonexistent' as any,
			);
			expect(resultNonExistent).toBeUndefined();
		});

		test('should handle nodes with null or undefined connections gracefully', () => {
			// Test workflow with sparse connection arrays
			const sparseWorkflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						name: 'Start',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-1',
						position: [100, 100],
						parameters: {},
					},
					{
						name: 'End',
						type: 'test.set',
						typeVersion: 1,
						id: 'uuid-2',
						position: [200, 100],
						parameters: {},
					},
				],
				connections: {
					Start: {
						main: [
							null, // Null connection at index 0
							[{ node: 'End', type: NodeConnectionTypes.Main, index: 0 }], // Connection at index 1
						],
					},
				},
				active: false,
			});

			const result = sparseWorkflow.getNodeConnectionIndexes('End', 'Start');
			expect(result).toEqual({
				sourceIndex: 1,
				destinationIndex: 0,
			});
		});
	});

	describe('getStartNode', () => {
		const manualTriggerNode = mock<INode>({
			name: 'ManualTrigger',
			type: 'n8n-nodes-base.manualTrigger',
		});
		const scheduleTriggerNode = mock<INode>({
			name: 'ScheduleTrigger',
			type: 'n8n-nodes-base.scheduleTrigger',
		});
		const httpRequestNode = mock<INode>({
			name: 'HTTP Request',
			type: 'n8n-nodes-base.httpRequest',
		});
		const set1Node = mock<INode>({
			name: 'Set1',
			type: 'n8n-nodes-base.set',
		});
		const disabledSetNode = mock<INode>({
			name: 'Set Disabled',
			type: 'n8n-nodes-base.set',
			disabled: true,
		});

		test('returns first trigger node when multiple start nodes exist', () => {
			const workflow = new Workflow({
				nodes: [manualTriggerNode, scheduleTriggerNode],
				connections: {},
				active: false,
				nodeTypes,
			});

			expect(workflow.getStartNode()).toBe(scheduleTriggerNode);
		});

		test('returns first starting node type when no trigger nodes are present', () => {
			const workflow = new Workflow({
				nodes: [httpRequestNode, set1Node],
				connections: {},
				active: false,
				nodeTypes,
			});

			expect(workflow.getStartNode()).toBe(httpRequestNode);
		});

		test('returns undefined when all nodes are disabled', () => {
			const workflow = new Workflow({
				nodes: [disabledSetNode],
				connections: {},
				active: false,
				nodeTypes,
			});

			expect(workflow.getStartNode()).toBeUndefined();
		});

		test('returns the single node when only one non-disabled node exists', () => {
			const singleNode = {
				name: 'SingleNode',
				type: 'test.set',
				typeVersion: 1,
				id: 'uuid-single',
				position: [0, 0],
				parameters: {},
			} as INode;
			const workflow = new Workflow({
				nodes: [singleNode],
				connections: {},
				active: false,
				nodeTypes,
			});

			expect(workflow.getStartNode()).toBe(singleNode);
		});
	});

	describe('getNode', () => {
		test('should return the node with the given name if it exists', () => {
			const workflow = SIMPLE_WORKFLOW;
			const node = workflow.getNode('Start');
			expect(node).not.toBeNull();
			expect(node?.name).toBe('Start');
			expect(node?.type).toBe('test.set');
			expect(node?.id).toBe('uuid-1');
		});

		test('should return null if the node does not exist', () => {
			const nonExistentNode = SIMPLE_WORKFLOW.getNode('NonExistentNode');
			expect(nonExistentNode).toBeNull();
		});
	});

	describe('getNodes', () => {
		test('should return all requested nodes that exist', () => {
			const nodes = SIMPLE_WORKFLOW.getNodes(['Start', 'Set', 'Set1']);
			expect(nodes).toHaveLength(3);
			expect(nodes[0].name).toBe('Start');
			expect(nodes[1].name).toBe('Set');
			expect(nodes[2].name).toBe('Set1');
		});

		test('should return nodes in the order they were requested', () => {
			const nodes = SIMPLE_WORKFLOW.getNodes(['Set1', 'Start', 'Set']);
			expect(nodes).toHaveLength(3);
			expect(nodes[0].name).toBe('Set1');
			expect(nodes[1].name).toBe('Start');
			expect(nodes[2].name).toBe('Set');
		});

		test('should skip nodes that do not exist and log a warning', () => {
			// Spy on console.warn
			const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

			const nodes = SIMPLE_WORKFLOW.getNodes(['Start', 'NonExistentNode', 'Set1']);
			expect(nodes).toHaveLength(2);
			expect(nodes[0].name).toBe('Start');
			expect(nodes[1].name).toBe('Set1');
			expect(consoleWarnSpy).toHaveBeenCalledWith(
				expect.stringContaining('Could not find a node with the name NonExistentNode'),
			);
		});

		test('should return an empty array if none of the requested nodes exist', () => {
			// Spy on console.warn
			const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

			const nodes = SIMPLE_WORKFLOW.getNodes(['NonExistentNode1', 'NonExistentNode2']);
			expect(nodes).toHaveLength(0);
			expect(consoleWarnSpy).toHaveBeenCalledTimes(2);
		});

		test('should handle an empty array of node names', () => {
			const nodes = SIMPLE_WORKFLOW.getNodes([]);
			expect(nodes).toHaveLength(0);
		});
	});
	describe('getConnectionsBetweenNodes', () => {
		test('should return empty array if no connections exist between sources and targets', () => {
			const result = SIMPLE_WORKFLOW.getConnectionsBetweenNodes(['Start'], ['Set1']);
			expect(result).toEqual([]);
		});

		test('should return connections between a single source and target', () => {
			const result = SIMPLE_WORKFLOW.getConnectionsBetweenNodes(['Start'], ['Set']);
			expect(result).toEqual([
				[
					{ node: 'Start', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'Set', type: NodeConnectionTypes.Main, index: 0 },
				],
			]);
		});

		test('should return connections between multiple sources and a single target', () => {
			const connections: IConnections = {
				Node1: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
				Node2: {
					main: [[{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 }]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [
					{
						id: 'Node1',
						name: 'Node1',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'Node2',
						name: 'Node2',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'TargetNode',
						name: 'TargetNode',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
				],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getConnectionsBetweenNodes(['Node1', 'Node2'], ['TargetNode']);
			expect(result).toEqual([
				[
					{ node: 'Node1', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 },
				],
				[
					{ node: 'Node2', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 },
				],
			]);
		});

		test('should return connections between a single source and multiple targets', () => {
			const connections: IConnections = {
				Node1: {
					main: [
						[
							{ node: 'TargetNode1', type: NodeConnectionTypes.Main, index: 0 },
							{ node: 'TargetNode2', type: NodeConnectionTypes.Main, index: 0 },
						],
					],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [
					{
						id: 'Node1',
						name: 'Node1',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'TargetNode1',
						name: 'TargetNode1',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'TargetNode2',
						name: 'TargetNode2',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
				],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getConnectionsBetweenNodes(['Node1'], ['TargetNode1', 'TargetNode2']);
			expect(result).toEqual([
				[
					{ node: 'Node1', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'TargetNode1', type: NodeConnectionTypes.Main, index: 0 },
				],
				[
					{ node: 'Node1', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'TargetNode2', type: NodeConnectionTypes.Main, index: 0 },
				],
			]);
		});

		test('should handle workflows with multiple connection types', () => {
			const connections: IConnections = {
				Node1: {
					main: [
						[
							{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 },
							{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 1 },
						],
					],
					[NodeConnectionTypes.AiAgent]: [
						[{ node: 'TargetNode', type: NodeConnectionTypes.AiAgent, index: 0 }],
					],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [
					{
						id: 'Node1',
						name: 'Node1',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'TargetNode',
						name: 'TargetNode',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
				],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getConnectionsBetweenNodes(['Node1'], ['TargetNode']);
			expect(result).toEqual([
				[
					{ node: 'Node1', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 0 },
				],
				[
					{ node: 'Node1', index: 0, type: NodeConnectionTypes.Main },
					{ node: 'TargetNode', type: NodeConnectionTypes.Main, index: 1 },
				],
				[
					{ node: 'Node1', index: 0, type: NodeConnectionTypes.AiAgent },
					{ node: 'TargetNode', type: NodeConnectionTypes.AiAgent, index: 0 },
				],
			]);
		});

		test('should handle nodes with no connections', () => {
			const connections: IConnections = {
				Node1: {
					main: [[]],
				},
			};

			const workflow = new Workflow({
				id: 'test',
				nodes: [
					{
						id: 'Node1',
						name: 'Node1',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'TargetNode',
						name: 'TargetNode',
						type: 'test.set',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
				],
				connections,
				active: false,
				nodeTypes,
			});

			const result = workflow.getConnectionsBetweenNodes(['Node1'], ['TargetNode']);
			expect(result).toEqual([]);
		});
	});

	describe('Error handling', () => {
		test('should handle unknown node type in constructor', () => {
			// Create a workflow with a node that has an unknown type
			const workflow = new Workflow({
				nodeTypes: {
					getByNameAndVersion: () => undefined, // Always return undefined to simulate unknown node type
					getAll: () => [],
				} as any,
				nodes: [
					{
						id: 'unknown-node',
						name: 'UnknownNode',
						type: 'unknown.type',
						typeVersion: 1,
						position: [0, 0],
						parameters: {},
					},
				],
				connections: {},
				active: false,
			});

			// Should not throw error, just continue processing
			expect(workflow).toBeDefined();
			expect(workflow.getNode('UnknownNode')).toBeDefined();
		});

		test('should throw error for unknown context type', () => {
			expect(() => {
				SIMPLE_WORKFLOW.getStaticData('invalid' as any);
			}).toThrow('Unknown context type. Only `global` and `node` are supported.');
		});

		test('should throw error when node parameter is undefined for node context', () => {
			expect(() => {
				SIMPLE_WORKFLOW.getStaticData('node', undefined);
			}).toThrow('The request data of context type "node" the node parameter has to be set!');
		});

		test('should return deterministic results for AI agent nodes', () => {
			// Test that deterministic sorting works for AI agent scenarios
			const workflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						id: 'aiAgent1',
						name: 'AI Agent',
						type: '@n8n/n8n-nodes-langchain.agent',
						typeVersion: 1.8,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'tool1',
						name: 'Tool1',
						type: '@n8n/n8n-nodes-langchain.toolWikipedia',
						typeVersion: 1,
						position: [100, 0],
						parameters: {},
					},
					{
						id: 'tool2',
						name: 'Tool2',
						type: '@n8n/n8n-nodes-langchain.toolCalculator',
						typeVersion: 1,
						position: [200, 0],
						parameters: {},
					},
				],
				connections: {
					Tool1: {
						[NodeConnectionTypes.AiTool]: [
							[{ node: 'AI Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
						],
					},
					Tool2: {
						[NodeConnectionTypes.AiTool]: [
							[{ node: 'AI Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
						],
					},
				},
				active: false,
			});

			const aiAgent = workflow.getNode('AI Agent')!;
			const result1 = workflow.getParentMainInputNode(aiAgent);
			const result2 = workflow.getParentMainInputNode(aiAgent);

			// Results should be consistent across multiple calls
			expect(result1.name).toBe(result2.name);
		});

		test('should handle multiple non-main connection types deterministically', () => {
			// This test demonstrates why alphabetical sorting is crucial:
			// Without sorting, Object.keys() could return different orders across JavaScript engines/runs
			// We test that the same input always produces the same output

			const createTestWorkflow = () => {
				const workflow = new Workflow({
					nodeTypes,
					nodes: [
						{
							id: 'aiAgent1',
							name: 'AI Agent',
							type: '@n8n/n8n-nodes-langchain.agent',
							typeVersion: 1.8,
							position: [0, 0],
							parameters: {},
						},
						{
							id: 'tool1',
							name: 'Tool1',
							type: '@n8n/n8n-nodes-langchain.toolCalculator',
							typeVersion: 1,
							position: [100, 0],
							parameters: {},
						},
						{
							id: 'tool2',
							name: 'Tool2',
							type: '@n8n/n8n-nodes-langchain.toolWikipedia',
							typeVersion: 1,
							position: [200, 0],
							parameters: {},
						},
					],
					connections: {
						Tool1: {
							[NodeConnectionTypes.AiTool]: [
								[{ node: 'AI Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
							],
						},
						Tool2: {
							[NodeConnectionTypes.AiTool]: [
								[{ node: 'AI Agent', type: NodeConnectionTypes.AiTool, index: 1 }],
							],
						},
					},
					active: false,
				});
				return workflow;
			};

			// Create multiple identical workflows
			const workflow1 = createTestWorkflow();
			const workflow2 = createTestWorkflow();
			const workflow3 = createTestWorkflow();

			const aiAgent1 = workflow1.getNode('AI Agent')!;
			const aiAgent2 = workflow2.getNode('AI Agent')!;
			const aiAgent3 = workflow3.getNode('AI Agent')!;

			const result1 = workflow1.getParentMainInputNode(aiAgent1);
			const result2 = workflow2.getParentMainInputNode(aiAgent2);
			const result3 = workflow3.getParentMainInputNode(aiAgent3);

			// All results should be identical (demonstrates deterministic behavior)
			expect(result1.name).toBe(result2.name);
			expect(result2.name).toBe(result3.name);
			expect(result1.name).toBe(result3.name);
		});

		test('should demonstrate the problem that deterministic sorting solves', () => {
			// This test verifies that alphabetical sorting ensures consistent results
			// regardless of the order in which connection types are processed

			// Create a workflow with multiple AI connection types in a specific structure
			// that would trigger the non-deterministic behavior without sorting
			const workflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						id: 'aiAgent1',
						name: 'AI Agent',
						type: '@n8n/n8n-nodes-langchain.agent',
						typeVersion: 1.8,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'tool1',
						name: 'ZZZ Tool', // Intentionally named to come last alphabetically
						type: '@n8n/n8n-nodes-langchain.toolCalculator',
						typeVersion: 1,
						position: [100, 0],
						parameters: {},
					},
					{
						id: 'tool2',
						name: 'AAA Tool', // Intentionally named to come first alphabetically
						type: '@n8n/n8n-nodes-langchain.toolWikipedia',
						typeVersion: 1,
						position: [200, 0],
						parameters: {},
					},
				],
				connections: {
					'ZZZ Tool': {
						[NodeConnectionTypes.AiTool]: [
							[{ node: 'AI Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
						],
					},
					'AAA Tool': {
						[NodeConnectionTypes.AiTool]: [
							[{ node: 'AI Agent', type: NodeConnectionTypes.AiTool, index: 1 }],
						],
					},
				},
				active: false,
			});

			const aiAgent = workflow.getNode('AI Agent')!;

			// Test multiple times to ensure consistent behavior
			// Without proper sorting, the result could vary based on internal iteration order
			const results: string[] = [];
			for (let i = 0; i < 20; i++) {
				const result = workflow.getParentMainInputNode(aiAgent);
				results.push(result.name);
			}

			// All results should be identical (proving deterministic sorting works)
			const uniqueResults = new Set(results);
			expect(uniqueResults.size).toBe(1);

			// The result should be consistent across all calls
			const firstResult = results[0];
			results.forEach((result) => {
				expect(result).toBe(firstResult);
			});
		});

		test('should explain why sorting is needed with real-world AI agent scenarios', () => {
			// Simulates a complex AI agent workflow - the exact type that was experiencing
			// non-deterministic behavior before the fix
			// This test documents the business value of the deterministic sorting fix

			const workflow = new Workflow({
				nodeTypes,
				nodes: [
					{
						id: 'aiAgent1',
						name: 'ChatGPT Agent',
						type: '@n8n/n8n-nodes-langchain.agent',
						typeVersion: 1.8,
						position: [0, 0],
						parameters: {},
					},
					{
						id: 'calculatorTool',
						name: 'Calculator Tool',
						type: '@n8n/n8n-nodes-langchain.toolCalculator',
						typeVersion: 1,
						position: [100, 0],
						parameters: {},
					},
					{
						id: 'wikipediaTool',
						name: 'Wikipedia Tool',
						type: '@n8n/n8n-nodes-langchain.toolWikipedia',
						typeVersion: 1,
						position: [100, 100],
						parameters: {},
					},
				],
				connections: {
					'Calculator Tool': {
						[NodeConnectionTypes.AiTool]: [
							[{ node: 'ChatGPT Agent', type: NodeConnectionTypes.AiTool, index: 0 }],
						],
					},
					'Wikipedia Tool': {
						[NodeConnectionTypes.AiTool]: [
							[{ node: 'ChatGPT Agent', type: NodeConnectionTypes.AiTool, index: 1 }],
						],
					},
				},
				active: false,
			});

			const chatGPTAgent = workflow.getNode('ChatGPT Agent')!;

			// Test what the original bug report described:
			// "AI agent node problem" with non-deterministic behavior
			const results = Array.from(
				{ length: 100 },
				() => workflow.getParentMainInputNode(chatGPTAgent).name,
			);

			// The fix ensures all results are identical (deterministic)
			// Previously, this could return different tool nodes across runs
			expect(new Set(results).size).toBe(1);

			// Additionally, verify that consecutive calls return the same result
			const result1 = workflow.getParentMainInputNode(chatGPTAgent);
			const result2 = workflow.getParentMainInputNode(chatGPTAgent);
			const result3 = workflow.getParentMainInputNode(chatGPTAgent);

			expect(result1.name).toBe(result2.name);
			expect(result2.name).toBe(result3.name);
		});
	});
});



================================================
FILE: packages/workflow/test/errors/node.error.test.ts
================================================
import { mock } from 'vitest-mock-extended';

import { NodeApiError } from '../../src/errors/node-api.error';
import { NodeOperationError } from '../../src/errors/node-operation.error';
import type { INode } from '../../src/interfaces';

describe('NodeError', () => {
	const node = mock<INode>();

	it('should update re-wrapped error level and message', () => {
		vi.useFakeTimers({ now: new Date() });

		const apiError = new NodeApiError(node, { message: 'Some error happened', code: 500 });
		const opsError = new NodeOperationError(node, mock(), { message: 'Some operation failed' });
		const wrapped1 = new NodeOperationError(node, apiError);
		const wrapped2 = new NodeOperationError(node, opsError);

		expect(wrapped1.level).toEqual(apiError.level);
		expect(wrapped1.message).toEqual(apiError.message);
		expect(wrapped2).toEqual(opsError);

		vi.useRealTimers();
	});
});



================================================
FILE: packages/workflow/test/errors/workflow-activation.error.test.ts
================================================
import { WorkflowActivationError } from '../../src/errors';

describe('WorkflowActivationError', () => {
	it('should default to `error` level', () => {
		const error = new WorkflowActivationError('message');
		expect(error.level).toBe('error');
	});

	const cause = new Error('Some error message');

	it('should set `level` based on arg', () => {
		const firstError = new WorkflowActivationError('message', { level: 'warning', cause });

		expect(firstError.level).toBe('warning');

		const secondError = new WorkflowActivationError('message', { level: 'error', cause });

		expect(secondError.level).toBe('error');
	});

	test.each([
		'ETIMEDOUT',
		'ECONNREFUSED',
		'EAUTH',
		'Temporary authentication failure',
		'Invalid credentials',
	])('should set `level` to `warning` for `%s`', (code) => {
		const error = new WorkflowActivationError(code, { cause });

		expect(error.level).toBe('warning');
	});
});



================================================
FILE: packages/workflow/test/errors/base/operational.error.test.ts
================================================
import { BaseError } from '../../../src/errors/base/base.error';
import { OperationalError } from '../../../src/errors/base/operational.error';

describe('OperationalError', () => {
	it('should be an instance of OperationalError', () => {
		const error = new OperationalError('test');
		expect(error).toBeInstanceOf(OperationalError);
	});

	it('should be an instance of BaseError', () => {
		const error = new OperationalError('test');
		expect(error).toBeInstanceOf(BaseError);
	});

	it('should have correct defaults', () => {
		const error = new OperationalError('test');
		expect(error.level).toBe('warning');
		expect(error.shouldReport).toBe(false);
	});

	it('should allow overriding the default level and shouldReport', () => {
		const error = new OperationalError('test', { level: 'error', shouldReport: true });
		expect(error.level).toBe('error');
		expect(error.shouldReport).toBe(true);
	});
});



================================================
FILE: packages/workflow/test/errors/base/unexpected.error.test.ts
================================================
import { BaseError } from '../../../src/errors/base/base.error';
import { UnexpectedError } from '../../../src/errors/base/unexpected.error';

describe('UnexpectedError', () => {
	it('should be an instance of UnexpectedError', () => {
		const error = new UnexpectedError('test');
		expect(error).toBeInstanceOf(UnexpectedError);
	});

	it('should be an instance of BaseError', () => {
		const error = new UnexpectedError('test');
		expect(error).toBeInstanceOf(BaseError);
	});

	it('should have correct defaults', () => {
		const error = new UnexpectedError('test');
		expect(error.level).toBe('error');
		expect(error.shouldReport).toBe(true);
	});

	it('should allow overriding the default level and shouldReport', () => {
		const error = new UnexpectedError('test', { level: 'fatal', shouldReport: false });
		expect(error.level).toBe('fatal');
		expect(error.shouldReport).toBe(false);
	});
});



================================================
FILE: packages/workflow/test/errors/base/user.error.test.ts
================================================
import { BaseError } from '../../../src/errors/base/base.error';
import { UserError } from '../../../src/errors/base/user.error';

describe('UserError', () => {
	it('should be an instance of UserError', () => {
		const error = new UserError('test');
		expect(error).toBeInstanceOf(UserError);
	});

	it('should be an instance of BaseError', () => {
		const error = new UserError('test');
		expect(error).toBeInstanceOf(BaseError);
	});

	it('should have correct defaults', () => {
		const error = new UserError('test');
		expect(error.level).toBe('info');
		expect(error.shouldReport).toBe(false);
	});

	it('should allow overriding the default level and shouldReport', () => {
		const error = new UserError('test', { level: 'warning', shouldReport: true });
		expect(error.level).toBe('warning');
		expect(error.shouldReport).toBe(true);
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/array-extensions.test.ts
================================================
// @vitest-environment jsdom

import { evaluate } from './helpers';
import { arrayExtensions } from '../../src/extensions/array-extensions';

describe('Data Transformation Functions', () => {
	describe('Array Data Transformation Functions', () => {
		test('.randomItem() should work correctly on an array', () => {
			expect(evaluate('={{ [1,2,3].randomItem() }}')).not.toBeUndefined();
		});

		test('.isNotEmpty() should work correctly on an array', () => {
			expect(evaluate('={{ [1,2,3, "imhere"].isNotEmpty() }}')).toEqual(true);
		});

		test('.pluck() should work correctly on an array', () => {
			expect(
				evaluate(`={{ [
				{ value: 1, string: '1' },
				{ value: 2, string: '2' },
				{ value: 3, string: '3' },
				{ value: 4, string: '4' },
				{ value: 5, string: '5' },
				{ value: 6, string: '6' },
				{ value: { something: 'else' } }
			].pluck("value") }}`),
			).toEqual(expect.arrayContaining([1, 2, 3, 4, 5, 6, { something: 'else' }]));
		});

		test('.pluck() should work correctly for multiple values', () => {
			expect(
				evaluate(`={{ [
					{
						firstName: 'John',
						lastName: 'Doe',
						phone: {
							home: '111-222',
							office: '333-444'
						}
					},
					{
						firstName: 'Jane',
						lastName: 'Doe',
						phone: {
							office: '555-666'
						}
					}
			].pluck("firstName", "lastName") }}`),
			).toEqual(
				expect.arrayContaining([
					['John', 'Doe'],
					['Jane', 'Doe'],
				]),
			);
		});

		test('.pluck() should work return everything with no args', () => {
			expect(
				evaluate(`={{ [
				{ value: 1, string: '1' },
				{ value: 2, string: '2' },
				{ value: 3, string: '3' },
				{ value: 4, string: '4' },
				{ value: 5, string: '5' },
				{ value: 6, string: '6' },
				{ value: { something: 'else' } }
			].pluck() }}`),
			).toEqual(
				expect.arrayContaining([
					{ value: 1, string: '1' },
					{ value: 2, string: '2' },
					{ value: 3, string: '3' },
					{ value: 4, string: '4' },
					{ value: 5, string: '5' },
					{ value: 6, string: '6' },
					{ value: { something: 'else' } },
				]),
			);
		});

		test('.unique() should work correctly on an array', () => {
			expect(evaluate('={{ ["repeat","repeat","a","b","c"].unique() }}')).toEqual(
				expect.arrayContaining(['repeat', 'repeat', 'a', 'b', 'c']),
			);
		});

		test('.unique() should work on an arrays containing nulls, objects and arrays', () => {
			expect(
				evaluate('={{ [1, 2, 3, "as", {}, {}, 1, 2, [1,2], "[sad]", "[sad]", null].unique() }}'),
			).toEqual([1, 2, 3, 'as', {}, [1, 2], '[sad]', null]);
		});

		test('.unique() should work on an arrays of objects', () => {
			expect(
				evaluate(
					"={{ [{'name':'Nathan', age:42}, {'name':'Jan', age:16}, {'name':'Nathan', age:21}].unique('name') }}",
				),
			).toEqual([
				{ name: 'Nathan', age: 42 },
				{ name: 'Jan', age: 16 },
			]);
		});

		test('.isEmpty() should work correctly on an array', () => {
			expect(evaluate('={{ [].isEmpty() }}')).toEqual(true);
		});

		test('.isEmpty() should work correctly on an array', () => {
			expect(evaluate('={{ [1].isEmpty() }}')).toEqual(false);
		});

		test('.last() should work correctly on an array', () => {
			expect(evaluate('={{ ["repeat","repeat","a","b","c"].last() }}')).toEqual('c');
		});

		test('.first() should work correctly on an array', () => {
			expect(evaluate('={{ ["repeat","repeat","a","b","c"].first() }}')).toEqual('repeat');
		});

		test('.merge() should work correctly on an array', () => {
			expect(
				evaluate(
					'={{ [{ test1: 1, test2: 2 }, { test1: 1, test3: 3 }].merge([{ test1: 2, test3: 3 }, { test4: 4 }]) }}',
				),
			).toEqual({ test1: 1, test2: 2, test3: 3, test4: 4 });
		});

		test('.merge() should work correctly without arguments', () => {
			expect(
				evaluate(
					'={{ [{ a: 1, some: null }, { a: 2, c: "something" }, 2, "asds", { b: 23 }, null, [1, 2]].merge() }}',
				),
			).toEqual({ a: 1, some: null, c: 'something', b: 23 });
		});

		test('.smartJoin() should work correctly on an array of objects', () => {
			expect(
				evaluate(
					'={{ [{ name: "test1", value: "value1" }, { name: "test2", value: null }].smartJoin("name", "value") }}',
				),
			).toEqual({
				test1: 'value1',
				test2: null,
			});
		});

		test('.renameKeys() should work correctly on an array of objects', () => {
			expect(
				evaluate(
					'={{ [{ test1: 1, test2: 2 }, { test1: 1, test3: 3 }].renameKeys("test1", "rename1", "test3", "rename3") }}',
				),
			).toEqual([
				{ rename1: 1, test2: 2 },
				{ rename1: 1, rename3: 3 },
			]);
		});

		test('.sum() should work on an array of numbers', () => {
			expect(evaluate('={{ [1, 2, 3, 4, 5, 6].sum() }}')).toEqual(21);
			expect(() => evaluate('={{ ["1", 2, 3, 4, 5, "bad"].sum() }}')).toThrow();
		});

		test('.average() should work on an array of numbers', () => {
			expect(evaluate('={{ [1, 2, 3, 4, 5, 6].average() }}')).toEqual(3.5);
			expect(() => evaluate('={{ ["1", 2, 3, 4, 5, "bad"].average() }}')).toThrow();
		});

		test('.min() should work on an array of numbers', () => {
			expect(evaluate('={{ [1, 2, 3, 4, 5, 6].min() }}')).toEqual(1);
			expect(() => evaluate('={{ ["1", 2, 3, 4, 5, "bad"].min() }}')).toThrow();
		});

		test('.max() should work on an array of numbers', () => {
			expect(evaluate('={{ [1, 2, 3, 4, 5, 6].max() }}')).toEqual(6);
			expect(() => evaluate('={{ ["1", 2, 3, 4, 5, "bad"].max() }}')).toThrow();
		});

		test('.union() should work on an array of objects', () => {
			expect(
				evaluate(
					'={{ [{ test1: 1 }, { test2: 2 }].union([{ test1: 1, test3: 3 }, { test2: 2 }, { test4: 4 }]) }}',
				),
			).toEqual([{ test1: 1 }, { test2: 2 }, { test1: 1, test3: 3 }, { test4: 4 }]);
		});

		test('.union() should work on an arrays containing nulls, objects and arrays', () => {
			expect(evaluate('={{ [1, 2, "dd", {}, null].union([1, {}, null, 3]) }}')).toEqual([
				1,
				2,
				'dd',
				{},
				null,
				3,
			]);
		});

		test('.intersection() should work on an array of objects', () => {
			expect(
				evaluate(
					'={{ [{ test1: 1 }, { test2: 2 }].intersection([{ test1: 1, test3: 3 }, { test2: 2 }, { test4: 4 }]) }}',
				),
			).toEqual([{ test2: 2 }]);
		});

		test('.intersection() should work on an arrays containing nulls, objects and arrays', () => {
			expect(evaluate('={{ [1, 2, "dd", {}, null].intersection([1, {}, null]) }}')).toEqual([
				1,
				{},
				null,
			]);
		});

		test('.difference() should work on an array of objects', () => {
			expect(
				evaluate(
					'={{ [{ test1: 1 }, { test2: 2 }].difference([{ test1: 1, test3: 3 }, { test2: 2 }, { test4: 4 }]) }}',
				),
			).toEqual([{ test1: 1 }]);

			expect(
				evaluate('={{ [{ test1: 1 }, { test2: 2 }].difference([{ test1: 1 }, { test2: 2 }]) }}'),
			).toEqual([]);
		});

		test('.difference() should work on an arrays containing nulls, objects and arrays', () => {
			expect(
				evaluate('={{ [1, 2, "dd", {}, null, ["a", 1]].difference([1, {}, null, ["a", 1]]) }}'),
			).toEqual([2, 'dd']);
		});

		test('.compact() should work on an array', () => {
			expect(
				evaluate(
					'={{ [{ test1: 1, test2: undefined, test3: null }, null, undefined, 1, 2, 0, { test: "asdf" }].compact() }}',
				),
			).toEqual([{ test1: 1 }, 1, 2, 0, { test: 'asdf' }]);
		});

		test('.chunk() should work on an array', () => {
			expect(evaluate('={{ numberList(1, 20).chunk(5) }}')).toEqual([
				[1, 2, 3, 4, 5],
				[6, 7, 8, 9, 10],
				[11, 12, 13, 14, 15],
				[16, 17, 18, 19, 20],
			]);
		});

		test('.toJsonString() should work on an array', () => {
			expect(evaluate('={{ [true, 1, "one", {foo: "bar"}].toJsonString() }}')).toEqual(
				'[true,1,"one",{"foo":"bar"}]',
			);
		});

		test('.append() should work on an array', () => {
			expect(evaluate('={{ [1,2,3].append(4,5,"done") }}')).toEqual([1, 2, 3, 4, 5, 'done']);
		});

		describe('Conversion methods', () => {
			test('should exist but return undefined (to not break expressions with mixed data)', () => {
				expect(evaluate('={{ numberList(1, 20).toInt() }}')).toBeUndefined();
				expect(evaluate('={{ numberList(1, 20).toFloat() }}')).toBeUndefined();
				expect(evaluate('={{ numberList(1, 20).toBoolean() }}')).toBeUndefined();
				expect(evaluate('={{ numberList(1, 20).toDateTime() }}')).toBeUndefined();
			});

			test('should not have a doc (hidden from autocomplete)', () => {
				expect(arrayExtensions.functions.toInt.doc).toBeUndefined();
				expect(arrayExtensions.functions.toFloat.doc).toBeUndefined();
				expect(arrayExtensions.functions.toBoolean.doc).toBeUndefined();
				expect(arrayExtensions.functions.toDateTime.doc).toBeUndefined();
			});
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/boolean-extensions.test.ts
================================================
// @vitest-environment jsdom

import { evaluate } from './helpers';
import { booleanExtensions } from '../../src/extensions/boolean-extensions';

describe('Data Transformation Functions', () => {
	describe('Boolean Data Transformation Functions', () => {
		describe('Conversion methods', () => {
			describe('toInt/toFloat', () => {
				test('should return 1 for true, 0 for false', () => {
					expect(evaluate('={{ (true).toInt() }}')).toEqual(1);
					expect(evaluate('={{ (true).toFloat() }}')).toEqual(1);
					expect(evaluate('={{ (false).toInt() }}')).toEqual(0);
					expect(evaluate('={{ (false).toFloat() }}')).toEqual(0);
				});
			});

			describe('toDateTime', () => {
				test('should return undefined', () => {
					expect(evaluate('={{ (true).toDateTime() }}')).toBeUndefined();
				});
			});

			describe('toBoolean', () => {
				test('should return itself', () => {
					expect(evaluate('={{ (true).toDateTime() }}')).toBeUndefined();
				});
			});

			test('should not have a doc (hidden from autocomplete)', () => {
				expect(booleanExtensions.functions.toFloat.doc).toBeUndefined();
				expect(booleanExtensions.functions.toBoolean.doc).toBeUndefined();
				expect(booleanExtensions.functions.toDateTime.doc).toBeUndefined();
			});
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/date-extensions.test.ts
================================================
// @vitest-environment jsdom

import { DateTime } from 'luxon';

import { evaluate, getLocalISOString } from './helpers';
import { dateExtensions } from '../../src/extensions/date-extensions';
import { getGlobalState } from '../../src/global-state';

const { defaultTimezone } = getGlobalState();

describe('Data Transformation Functions', () => {
	describe('Date Data Transformation Functions', () => {
		test('.isWeekend() should work correctly on a date', () => {
			expect(evaluate('={{ DateTime.local(2023, 1, 20).isWeekend() }}')).toBe(false);
			expect(evaluate('={{ DateTime.local(2023, 1, 21).isWeekend() }}')).toBe(true);
			expect(evaluate('={{ DateTime.local(2023, 1, 22).isWeekend() }}')).toBe(true);
			expect(evaluate('={{ DateTime.local(2023, 1, 23).isWeekend() }}')).toBe(false);
		});

		describe('.beginningOf', () => {
			test('.beginningOf("week") should work correctly on a date', () => {
				expect(evaluate('={{ DateTime.local(2023, 1, 20).beginningOf("week") }}')).toEqual(
					DateTime.local(2023, 1, 16, { zone: defaultTimezone }),
				);

				expect(evaluate('={{ new Date(2023, 0, 20).beginningOf("week") }}')).toEqual(
					DateTime.local(2023, 1, 16, { zone: defaultTimezone }).toJSDate(),
				);
			});

			test('.beginningOf("week") should work correctly on a string', () => {
				const evaluatedDate = evaluate('={{ "2023-01-30".toDate().beginningOf("week") }}');
				const expectedDate = DateTime.local(2023, 1, 23, { zone: defaultTimezone }).toJSDate();

				if (evaluatedDate && evaluatedDate instanceof Date) {
					expect(evaluatedDate.toDateString()).toEqual(expectedDate.toDateString());
				}
			});

			test('.beginningOf("month") should work correctly on a string', () => {
				const evaluatedDate = evaluate('={{ "2023-06-16".toDate().beginningOf("month") }}');
				const expectedDate = DateTime.local(2023, 6, 1, { zone: defaultTimezone }).toJSDate();

				if (evaluatedDate && evaluatedDate instanceof Date) {
					expect(evaluatedDate.toDateString()).toEqual(expectedDate.toDateString());
				}
			});

			test('.beginningOf("year") should work correctly on a string', () => {
				const evaluatedDate = evaluate('={{ "2023-01-30".toDate().beginningOf("year") }}');
				const expectedDate = DateTime.local(2023, 1, 1, { zone: defaultTimezone }).toJSDate();

				if (evaluatedDate && evaluatedDate instanceof Date) {
					expect(evaluatedDate.toDateString()).toEqual(expectedDate.toDateString());
				}
			});
		});

		test('.endOfMonth() should work correctly on a date', () => {
			expect(evaluate('={{ DateTime.local(2023, 1, 16).endOfMonth() }}')).toEqual(
				DateTime.local(2023, 1, 31, 23, 59, 59, 999, { zone: defaultTimezone }),
			);
			expect(evaluate('={{ new Date(2023, 0, 16).endOfMonth() }}')).toEqual(
				DateTime.local(2023, 1, 31, 23, 59, 59, 999, { zone: defaultTimezone }).toJSDate(),
			);
		});

		describe('.extract', () => {
			test('.extract("day") should work correctly on a date', () => {
				expect(evaluate('={{ DateTime.local(2023, 1, 20).extract("day") }}')).toEqual(20);
			});

			test('should extract year from a date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49").extract("year") }}')).toEqual(2024);
			});

			test('should extract yearDayNumber from a date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49").extract("yearDayNumber") }}')).toEqual(
					90,
				);
			});

			test('should extract month from a date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49").extract("month") }}')).toEqual(3);
			});

			test('should extract week from a date', () => {
				expect(evaluate('={{ DateTime.local(2023, 1, 20).extract() }}')).toEqual(3);
				expect(evaluate('={{ DateTime.local(2023, 1, 20).extract("week") }}')).toEqual(3);
			});

			test('should extract day from a date', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-03-30T18:49").extract("day") }}')).toEqual(30);
			});

			test('should extract hour from a date', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-03-30T18:49").extract("hour") }}')).toEqual(18);
			});

			test('should extract minute from a date', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-03-30T18:49").extract("minute") }}')).toEqual(
					49,
				);
			});

			test('should extract second from a date', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-03-30T18:49").extract("second") }}')).toEqual(
					0,
				);
			});

			test('should extract millisecond from a date', () => {
				expect(
					evaluate('={{ DateTime.fromISO("2024-03-30T18:49:00.123Z").extract("millisecond") }}'),
				).toEqual(123);
			});

			test('should return undefined for invalid unit', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-03-30T18:49").extract("invalid") }}')).toBe(
					null,
				);
			});
		});

		describe('.format', () => {
			test('should format date with custom format', () => {
				expect(
					evaluate('={{ DateTime.fromISO("2024-03-30T18:49").format("yyyy LLL dd") }}'),
				).toEqual('2024 Mar 30');
			});

			test('should format date with ISO format', () => {
				expect(
					evaluate('={{ DateTime.fromISO("2024-03-30T18:49").format("yyyy-MM-dd\'T\'HH:mm:ss") }}'),
				).toEqual('2024-03-30T18:49:00');
			});
		});

		test('.toDate() should work on a string', () => {
			const date = new Date(2022, 0, 3);
			expect(evaluate(`={{ "${getLocalISOString(date)}".toDate() }}`)).toEqual(date);
		});

		describe('.inBetween', () => {
			test('should work on string and Date', () => {
				expect(
					evaluate("={{ $now.isBetween('2023-06-23'.toDate(), '2023-06-23') }}"),
				).toBeDefined();
			});

			test('should work on string and DateTime', () => {
				expect(evaluate("={{ $now.isBetween($now, '2023-06-23') }}")).toBeDefined();
			});

			test('should not work for invalid strings', () => {
				expect(evaluate("={{ $now.isBetween($now, 'invalid') }}")).toBeUndefined();
			});

			test('should not work for numbers', () => {
				expect(evaluate('={{ $now.isBetween($now, 1) }}')).toBeUndefined();
			});

			test('should not work for a single argument', () => {
				expect(() => evaluate('={{ $now.isBetween($now) }}')).toThrow();
			});

			test('should not work for a more than two arguments', () => {
				expect(() =>
					evaluate("={{ $now.isBetween($now, '2023-06-23', '2023-09-21'.toDate()) }}"),
				).toThrow();
			});
		});

		describe('.diffTo', () => {
			test('should work with a single unit', () => {
				expect(
					evaluate(
						"={{ '2025-01-01'.toDateTime().diffTo('2024-03-30T18:49:07.234', 'days').floor() }}",
					),
				).toEqual(276);
			});

			test('should work with an array of units', () => {
				expect(
					evaluate(
						"={{ '2025-01-01T00:00:00.000'.toDateTime().diffTo('2024-03-30T18:49:07.234', ['months', 'days']) }}",
					),
				).toEqual({ months: 9, days: 1.2158884953703704 });
			});

			test('should return difference in days', () => {
				expect(
					evaluate(
						'={{ DateTime.fromISO("2024-03-30T18:49:00Z").diffTo("2024-03-25T18:49:00Z", "days") }}',
					),
				).toEqual(5);
			});

			test('should return difference in hours', () => {
				expect(
					evaluate(
						'={{ DateTime.fromISO("2024-03-30T18:49:00Z").diffTo("2024-03-30T12:49:00Z", "hours") }}',
					),
				).toEqual(6);
			});

			test('should return difference in minutes', () => {
				expect(
					evaluate(
						'={{ DateTime.fromISO("2024-03-30T18:49:00Z").diffTo("2024-03-30T18:44:00Z", "minutes") }}',
					),
				).toEqual(5);
			});

			test('should return difference in seconds', () => {
				expect(
					evaluate(
						'={{ DateTime.fromISO("2024-03-30T18:49:00Z").diffTo("2024-03-30T18:48:55Z", "seconds") }}',
					),
				).toEqual(5);
			});

			test('should return difference in milliseconds', () => {
				expect(
					evaluate(
						'={{ DateTime.fromISO("2024-03-30T18:49:00.500Z").diffTo("2024-03-30T18:49:00.000Z", "milliseconds") }}',
					),
				).toEqual(500);
			});

			test('should throw for invalid unit', () => {
				expect(() =>
					evaluate(
						'={{ DateTime.fromISO("2024-03-30T18:49:00Z").diffTo("2024-03-30T18:49:00Z", "invalid") }}',
					),
				).toThrow('Unsupported unit');
			});
		});

		describe('.toDateTime', () => {
			test('should return itself for DateTime', () => {
				const result = evaluate(
					"={{ DateTime.fromFormat('01-01-2024', 'dd-MM-yyyy').toDateTime() }}",
				) as unknown as DateTime;
				expect(result).toBeInstanceOf(DateTime);
				expect(result.day).toEqual(1);
				expect(result.month).toEqual(1);
				expect(result.year).toEqual(2024);
			});

			test('should return a DateTime for JS Date', () => {
				const result = evaluate(
					'={{ new Date(2024, 0, 1, 12).toDateTime() }}',
				) as unknown as DateTime;
				expect(result).toBeInstanceOf(DateTime);
				expect(result.day).toEqual(1);
				expect(result.month).toEqual(1);
				expect(result.year).toEqual(2024);
			});
		});

		describe('.toInt/.toFloat', () => {
			test('should return milliseconds for DateTime', () => {
				expect(evaluate("={{ DateTime.fromISO('2024-01-01T00:00:00.000Z').toInt() }}")).toEqual(
					1704067200000,
				);
			});

			test('should return milliseconds for JS Date', () => {
				expect(evaluate('={{ new Date("2024-01-01T00:00:00.000Z").toFloat() }}')).toEqual(
					1704067200000,
				);
			});

			test('should not have a doc (hidden from autocomplete)', () => {
				expect(dateExtensions.functions.toInt.doc).toBeUndefined();
				expect(dateExtensions.functions.toFloat.doc).toBeUndefined();
			});
		});

		describe('.toBoolean', () => {
			test('should return undefined', () => {
				expect(evaluate('={{ new Date("2024-01-01T00:00:00.000Z").toBoolean() }}')).toBeUndefined();
			});

			test('should not have a doc (hidden from autocomplete)', () => {
				expect(dateExtensions.functions.toBoolean.doc).toBeUndefined();
			});
		});

		describe('.isInLast', () => {
			it('should return true if the date is within the last n minutes', () => {
				expect(
					evaluate(
						`={{ new Date("${DateTime.now().minus({ minutes: 5 }).toISO()}").isInLast(10, "minutes") }}`,
					),
				).toBe(true);
			});

			it('should return false if the date is not within the last n minutes', () => {
				expect(
					evaluate(
						`={{ new Date("${DateTime.now().minus({ minutes: 15 }).toISO()}").isInLast(10, "minutes") }}`,
					),
				).toBe(false);
			});

			it('should handle default unit as minutes', () => {
				expect(
					evaluate(
						`={{ new Date("${DateTime.now().minus({ minutes: 5 }).toISO()}").isInLast(10) }}`,
					),
				).toBe(true);
			});
		});

		describe('.minus', () => {
			it('should subtract days from the date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49:00Z").minus(7, "days") }}')).toEqual(
					new Date('2024-03-23T18:49:00.000Z'),
				);
			});

			it('should subtract years from the date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49:00Z").minus(4, "years") }}')).toEqual(
					new Date('2020-03-30T18:49:00.000Z'),
				);
			});

			it('should handle default unit as milliseconds', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49:00Z").minus(1000) }}')).toEqual(
					new Date('2024-03-30T18:48:59.000Z'),
				);
			});

			it('should handle DateTime instances', () => {
				expect(
					evaluate('={{ DateTime.fromISO("2024-03-30T18:49:00Z").minus(1, "day").toJSDate() }}'),
				).toEqual(new Date('2024-03-29T18:49:00.000Z'));
			});
		});

		describe('.plus', () => {
			it('should subtract days from the date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49:00Z").plus(7, "days") }}')).toEqual(
					new Date('2024-04-06T18:49:00.000Z'),
				);
			});

			it('should subtract years from the date', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49:00Z").plus(4, "years") }}')).toEqual(
					new Date('2028-03-30T18:49:00.000Z'),
				);
			});

			it('should handle default unit as milliseconds', () => {
				expect(evaluate('={{ new Date("2024-03-30T18:49:00Z").plus(1000) }}')).toEqual(
					new Date('2024-03-30T18:49:01.000Z'),
				);
			});

			it('should handle DateTime instances', () => {
				expect(
					evaluate('={{ DateTime.fromISO("2024-03-30T18:49:00Z").plus(1, "day").toJSDate() }}'),
				).toEqual(new Date('2024-03-31T18:49:00.000Z'));
			});
		});

		describe('.isDst', () => {
			test('should return true for a date in DST', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-06-30T18:49:00Z").isDst() }}')).toBe(true);
			});

			test('should return false for a date not in DST', () => {
				expect(evaluate('={{ DateTime.fromISO("2024-01-30T18:49:00Z").isDst() }}')).toBe(false);
			});
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/expression-extension.test.ts
================================================
// @vitest-environment jsdom

/* eslint-disable n8n-local-rules/no-interpolation-in-regular-string */

import { evaluate } from './helpers';
import { ExpressionExtensionError } from '../../src/errors/expression-extension.error';
import { extendTransform, extend } from '../../src/extensions';
import { joinExpression, splitExpression } from '../../src/extensions/expression-parser';

describe('Expression Extension Transforms', () => {
	describe('extend() transform', () => {
		test('Basic transform with .isEmpty', () => {
			expect(extendTransform('"".isEmpty()')!.code).toEqual('extend("", "isEmpty", [])');
		});

		test('Chained transform with .toSnakeCase.toSentenceCase', () => {
			expect(extendTransform('"".toSnakeCase().toSentenceCase(2)')!.code).toEqual(
				'extend(extend("", "toSnakeCase", []), "toSentenceCase", [2])',
			);
		});

		test('Chained transform with native functions .toSnakeCase.trim.toSentenceCase', () => {
			expect(extendTransform('"aaa ".toSnakeCase().trim().toSentenceCase(2)')!.code).toEqual(
				'extend(extend("aaa ", "toSnakeCase", []).trim(), "toSentenceCase", [2])',
			);
		});
	});
});

describe('Expression Parser', () => {
	describe('Compatible splitting', () => {
		test('Lone expression', () => {
			expect(splitExpression('{{ "" }}')).toEqual([
				{ type: 'text', text: '' },
				{ type: 'code', text: ' "" ', hasClosingBrackets: true },
			]);
		});

		test('Multiple expression', () => {
			expect(splitExpression('{{ "test".toSnakeCase() }} you have ${{ (100).format() }}.')).toEqual(
				[
					{ type: 'text', text: '' },
					{ type: 'code', text: ' "test".toSnakeCase() ', hasClosingBrackets: true },
					{ type: 'text', text: ' you have $' },
					{ type: 'code', text: ' (100).format() ', hasClosingBrackets: true },
					{ type: 'text', text: '.' },
				],
			);
		});

		test('Unclosed expression', () => {
			expect(splitExpression('{{ "test".toSnakeCase() }} you have ${{ (100).format()')).toEqual([
				{ type: 'text', text: '' },
				{ type: 'code', text: ' "test".toSnakeCase() ', hasClosingBrackets: true },
				{ type: 'text', text: ' you have $' },
				{ type: 'code', text: ' (100).format()', hasClosingBrackets: false },
			]);
		});

		test('Escaped opening bracket', () => {
			expect(splitExpression('test \\{{ no code }}')).toEqual([
				{ type: 'text', text: 'test \\{{ no code }}' },
			]);
		});

		test('Escaped closinging bracket', () => {
			expect(splitExpression('test {{ code.test("\\}}") }}')).toEqual([
				{ type: 'text', text: 'test ' },
				{ type: 'code', text: ' code.test("}}") ', hasClosingBrackets: true },
			]);
		});
	});

	describe('Compatible joining', () => {
		test('Lone expression', () => {
			expect(joinExpression(splitExpression('{{ "" }}'))).toEqual('{{ "" }}');
		});

		test('Multiple expression', () => {
			expect(
				joinExpression(
					splitExpression('{{ "test".toSnakeCase() }} you have ${{ (100).format() }}.'),
				),
			).toEqual('{{ "test".toSnakeCase() }} you have ${{ (100).format() }}.');
		});

		test('Unclosed expression', () => {
			expect(
				joinExpression(splitExpression('{{ "test".toSnakeCase() }} you have ${{ (100).format()')),
			).toEqual('{{ "test".toSnakeCase() }} you have ${{ (100).format()');
		});

		test('Escaped opening bracket', () => {
			expect(joinExpression(splitExpression('test \\{{ no code }}'))).toEqual(
				'test \\{{ no code }}',
			);
		});

		test('Escaped closing bracket', () => {
			expect(joinExpression(splitExpression('test {{ code.test("\\}}") }}'))).toEqual(
				'test {{ code.test("\\}}") }}',
			);
		});
	});

	describe('Edge cases', () => {
		test("Nested member access with name of function inside a function doesn't result in function call", () => {
			expect(evaluate('={{ Math.floor([1, 2, 3, 4].length + 10) }}')).toEqual(14);

			expect(extendTransform('Math.floor([1, 2, 3, 4].length + 10)')?.code).toBe(
				'extend(Math, "floor", [[1, 2, 3, 4].length + 10])',
			);
		});
	});

	describe('Test newer ES syntax', () => {
		test('Optional chaining transforms', () => {
			expect(extendTransform('$json.something?.test.funcCall()')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.test.funcCall();',
			);

			expect(extendTransform('$json.something?.test.funcCall()?.somethingElse')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.test.funcCall()) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.somethingElse;',
			);

			expect(extendTransform('$json.something?.test.funcCall().somethingElse')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.test.funcCall().somethingElse;',
			);

			expect(
				extendTransform('$json.something?.test.funcCall()?.somethingElse.otherCall()')?.code,
			).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = $json.something) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.test.funcCall()) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.somethingElse.otherCall();',
			);

			expect(evaluate('={{ [1, 2, 3, 4]?.sum() }}')).toBe(10);
		});

		test('Optional chaining transforms on calls', () => {
			expect(extendTransform('Math.min?.(1)')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = extendOptional(Math, "min")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1(1);',
			);
			expect(extendTransform('Math?.min?.(1)')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = Math) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = extendOptional(window.chainValue1, "min")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1(1);',
			);

			expect(extendTransform('$json.test.test2?.sum()')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = $json.test.test2) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : extend(window.chainValue1, "sum", []);',
			);
			expect(extendTransform('$json.test.test2?.sum?.()')?.code).toBe(
				'window.chainCancelToken1 = ((window.chainValue1 = $json.test.test2) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = extendOptional(window.chainValue1, "sum")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1();',
			);

			expect(evaluate('={{ [1, 2, 3, 4].sum?.() }}')).toBe(10);
		});

		test('Multiple optional chains in an expression', () => {
			expect(extendTransform('$json.test?.test2($json.test?.test2)')?.code).toBe(`window.chainCancelToken2 = ((window.chainValue2 = $json.test) ?? undefined) === undefined, window.chainCancelToken2 === true ? undefined : window.chainValue2.test2(
  (window.chainCancelToken1 = ((window.chainValue1 = $json.test) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.test2)
);`);

			expect(extendTransform('$json.test?.test2($json.test.sum?.())')?.code).toBe(`window.chainCancelToken2 = ((window.chainValue2 = $json.test) ?? undefined) === undefined, window.chainCancelToken2 === true ? undefined : window.chainValue2.test2(
  (window.chainCancelToken1 = ((window.chainValue1 = extendOptional($json.test, "sum")) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1())
);`);
		});

		expect(evaluate('={{ [1, 2, 3, 4]?.sum((undefined)?.test) }}')).toBe(10);
	});

	describe('Non dot extensions', () => {
		test('min', () => {
			expect(evaluate('={{ min(1, 2, 3, 4, 5, 6) }}')).toEqual(1);
			expect(evaluate('={{ min(1, NaN, 3, 4, 5, 6) }}')).toBeNaN();
		});

		test('max', () => {
			expect(evaluate('={{ max(1, 2, 3, 4, 5, 6) }}')).toEqual(6);
			expect(evaluate('={{ max(1, NaN, 3, 4, 5, 6) }}')).toBeNaN();
		});

		test('average', () => {
			expect(evaluate('={{ average(1, 2, 3, 4, 5, 6) }}')).toEqual(3.5);
			expect(evaluate('={{ average(1, NaN, 3, 4, 5, 6) }}')).toBeNaN();
		});

		test('numberList', () => {
			expect(evaluate('={{ numberList(1, 10) }}')).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
			expect(evaluate('={{ numberList(1, -10) }}')).toEqual([
				1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10,
			]);
		});

		test('zip', () => {
			expect(evaluate('={{ zip(["test1", "test2", "test3"], [1, 2, 3]) }}')).toEqual({
				test1: 1,
				test2: 2,
				test3: 3,
			});
		});

		test('$if', () => {
			expect(evaluate('={{ $if("a"==="a", 1, 2) }}')).toEqual(1);
			expect(evaluate('={{ $if("a"==="b", 1, 2) }}')).toEqual(2);
			expect(evaluate('={{ $if("a"==="a", 1) }}')).toEqual(1);
			expect(evaluate('={{ $if("a"==="b", 1) }}')).toEqual(false);

			// This will likely break when sandboxing is implemented but it works for now.
			// If you're implementing sandboxing maybe provide a way to add functions to
			// sandbox we can check instead?
			const mockCallback = vi.fn(() => false);
			evaluate('={{ $if("a"==="a", true, $data.cb()) }}', [{ cb: mockCallback }]);
			expect(mockCallback.mock.calls.length).toEqual(0);

			evaluate('={{ $if("a"==="b", true, $data.cb()) }}', [{ cb: mockCallback }]);
			expect(mockCallback.mock.calls.length).toEqual(1);
		});

		test('$not', () => {
			expect(evaluate('={{ $not(1) }}')).toEqual(false);
			expect(evaluate('={{ $not(0) }}')).toEqual(true);
			expect(evaluate('={{ $not(true) }}')).toEqual(false);
			expect(evaluate('={{ $not(false) }}')).toEqual(true);
			expect(evaluate('={{ $not(undefined) }}')).toEqual(true);
			expect(evaluate('={{ $not(null) }}')).toEqual(true);
			expect(evaluate('={{ $not("") }}')).toEqual(true);
			expect(evaluate('={{ $not("a") }}')).toEqual(false);
		});
		test('$ifEmpty', () => {
			expect(evaluate('={{ $ifEmpty(1, "default") }}')).toEqual(1);
			expect(evaluate('={{ $ifEmpty(0, "default") }}')).toEqual(0);
			expect(evaluate('={{ $ifEmpty(false, "default") }}')).toEqual(false);
			expect(evaluate('={{ $ifEmpty(true, "default") }}')).toEqual(true);
			expect(evaluate('={{ $ifEmpty("", "default") }}')).toEqual('default');
			expect(evaluate('={{ $ifEmpty(null, "default") }}')).toEqual('default');
			expect(evaluate('={{ $ifEmpty(undefined, "default") }}')).toEqual('default');
			expect(evaluate('={{ $ifEmpty([], "default") }}')).toEqual('default');
			expect(evaluate('={{ $ifEmpty({}, "default") }}')).toEqual('default');
			expect(evaluate('={{ $ifEmpty([1], "default") }}')).toEqual([1]);
			expect(evaluate('={{ $ifEmpty({a: 1}, "default") }}')).toEqual({ a: 1 });
		});
	});

	describe('Test extend with undefined', () => {
		test('input is undefined', () => {
			try {
				extend(undefined, 'toDateTime', []);
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionExtensionError);
				expect(error).toHaveProperty('message', "toDateTime can't be used on undefined value");
			}
		});
		test('input is null', () => {
			try {
				extend(null, 'startsWith', []);
			} catch (error) {
				expect(error).toBeInstanceOf(ExpressionExtensionError);
				expect(error).toHaveProperty('message', "startsWith can't be used on null value");
			}
		});
		test('input should be converted to upper case', () => {
			const result = extend('TEST', 'toUpperCase', []);

			expect(result).toEqual('TEST');
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/generic-extensions.test.ts
================================================
import { evaluate } from './helpers';

describe('Data Transformation Functions', () => {
	describe('Genric Data Transformation Functions', () => {
		test('.isEmpty() should work correctly on undefined', () => {
			expect(evaluate('={{(undefined).isEmpty()}}')).toEqual(true);
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/helpers.ts
================================================
import type { IDataObject } from '../../src/interfaces';
import { Workflow } from '../../src/workflow';
import * as Helpers from '../helpers';

export const nodeTypes = Helpers.NodeTypes();
export const workflow = new Workflow({
	nodes: [
		{
			name: 'node',
			typeVersion: 1,
			type: 'test.set',
			id: 'uuid-1234',
			position: [0, 0],
			parameters: {},
		},
	],
	connections: {},
	active: false,
	nodeTypes,
});
export const expression = workflow.expression;

export const evaluate = (value: string, values?: IDataObject[]) =>
	expression.getParameterValue(
		value,
		null,
		0,
		0,
		'node',
		values?.map((v) => ({ json: v })) ?? [],
		'manual',
		{},
	);

export const getLocalISOString = (date: Date) => {
	const offset = date.getTimezoneOffset();
	const offsetAbs = Math.abs(offset);
	const isoString = new Date(date.getTime() - offset * 60 * 1000).toISOString();
	const hours = String(Math.floor(offsetAbs / 60)).padStart(2, '0');
	const minutes = String(offsetAbs % 60).padStart(2, '0');
	return `${isoString.slice(0, -1)}${offset > 0 ? '-' : '+'}${hours}:${minutes}`;
};



================================================
FILE: packages/workflow/test/ExpressionExtensions/number-extensions.test.ts
================================================
// @vitest-environment jsdom

import { evaluate } from './helpers';
import { numberExtensions } from '../../src/extensions/number-extensions';

describe('Data Transformation Functions', () => {
	describe('Number Data Transformation Functions', () => {
		test('.format() should work correctly on a number', () => {
			expect(evaluate('={{ Number(100).format() }}')).toEqual(
				numberExtensions.functions.format(100, []),
			);
		});

		test('.ceil() should work on a number', () => {
			expect(evaluate('={{ (1.2).ceil() }}')).toEqual(2);
			expect(evaluate('={{ (1.9).ceil() }}')).toEqual(2);
			expect(evaluate('={{ (1.0).ceil() }}')).toEqual(1);
			expect(evaluate('={{ (NaN).ceil() }}')).toBeNaN();
		});

		test('.floor() should work on a number', () => {
			expect(evaluate('={{ (1.2).floor() }}')).toEqual(1);
			expect(evaluate('={{ (1.9).floor() }}')).toEqual(1);
			expect(evaluate('={{ (1.0).floor() }}')).toEqual(1);
			expect(evaluate('={{ (NaN).floor() }}')).toBeNaN();
		});

		test('.round() should work on a number', () => {
			expect(evaluate('={{ (1.3333333).round(3) }}')).toEqual(1.333);
			expect(evaluate('={{ (1.3333333).round(0) }}')).toEqual(1);
			expect(evaluate('={{ (1.5001).round(0) }}')).toEqual(2);
			expect(evaluate('={{ (NaN).round(3) }}')).toBeNaN();
		});

		test('.isOdd() should work on a number', () => {
			expect(evaluate('={{ (9).isOdd() }}')).toEqual(true);
			expect(evaluate('={{ (8).isOdd() }}')).toEqual(false);
			expect(evaluate('={{ (0).isOdd() }}')).toEqual(false);
		});

		test('.isOdd() should not work on a float or NaN', () => {
			expect(() => evaluate('={{ (NaN).isOdd() }}')).toThrow();
			expect(() => evaluate('={{ (9.2).isOdd() }}')).toThrow();
		});

		test('.isEven() should work on a number', () => {
			expect(evaluate('={{ (9).isEven() }}')).toEqual(false);
			expect(evaluate('={{ (8).isEven() }}')).toEqual(true);
			expect(evaluate('={{ (0).isEven() }}')).toEqual(true);
		});

		test('.isEven() should not work on a float or NaN', () => {
			expect(() => evaluate('={{ (NaN).isEven() }}')).toThrow();
			expect(() => evaluate('={{ (9.2).isEven() }}')).toThrow();
		});

		describe('toDateTime', () => {
			test('from milliseconds (default)', () => {
				expect(evaluate('={{ (1704085200000).toDateTime().toISO() }}')).toEqual(
					'2024-01-01T00:00:00.000-05:00',
				);
				expect(evaluate('={{ (1704085200000).toDateTime("ms").toISO() }}')).toEqual(
					'2024-01-01T00:00:00.000-05:00',
				);
			});

			test('from seconds', () => {
				expect(evaluate('={{ (1704085200).toDateTime("s").toISO() }}')).toEqual(
					'2024-01-01T00:00:00.000-05:00',
				);
			});

			test('from Excel 1900 format', () => {
				expect(evaluate('={{ (42144).toDateTime("excel").toISO() }}')).toEqual(
					'2015-05-19T20:00:00.000-04:00',
				);
			});

			test('from microseconds', () => {
				expect(evaluate('={{ (1704085200000000).toDateTime("us").toISO() }}')).toEqual(
					'2024-01-01T00:00:00.000-05:00',
				);
			});
		});

		describe('toInt', () => {
			test('should round numbers', () => {
				expect(evaluate('={{ (42144).toInt() }}')).toEqual(42144);
				expect(evaluate('={{ (42144.345).toInt() }}')).toEqual(42144);
				expect(evaluate('={{ (42144.545).toInt() }}')).toEqual(42145);
			});
		});

		describe('toFloat', () => {
			test('should return itself', () => {
				expect(evaluate('={{ (42144).toFloat() }}')).toEqual(42144);
				expect(evaluate('={{ (42144.345).toFloat() }}')).toEqual(42144.345);
			});
		});

		describe('toBoolean', () => {
			test('should return false for 0, 1 for other numbers', () => {
				expect(evaluate('={{ (42144).toBoolean() }}')).toBe(true);
				expect(evaluate('={{ (-1.549).toBoolean() }}')).toBe(true);
				expect(evaluate('={{ (0).toBoolean() }}')).toBe(false);
			});
		});
	});

	describe('Multiple expressions', () => {
		test('Basic multiple expressions', () => {
			// eslint-disable-next-line n8n-local-rules/no-interpolation-in-regular-string
			expect(evaluate('={{ "test abc".toSnakeCase() }} you have ${{ (100).format() }}.')).toEqual(
				'test_abc you have $100.',
			);
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/object-extensions.test.ts
================================================
import { evaluate } from './helpers';
import { ApplicationError } from '../../src/errors';
import { objectExtensions } from '../../src/extensions/object-extensions';

describe('Data Transformation Functions', () => {
	describe('Object Data Transformation Functions', () => {
		describe('.isEmpty', () => {
			test('should return true for an empty object', () => {
				expect(evaluate('={{ ({}).isEmpty() }}')).toBe(true);
			});

			test('should return false for a non-empty object', () => {
				expect(evaluate('={{ ({ test: 1 }).isEmpty() }}')).toBe(false);
			});

			test('should return true for an object with only null/undefined values', () => {
				expect(evaluate('={{ ({ test1: null, test2: undefined }).isEmpty() }}')).toBe(false);
			});
		});

		describe('.hasField', () => {
			test('should return true if the key exists in the object', () => {
				expect(evaluate('={{ ({ test1: 1 }).hasField("test1") }}')).toBe(true);
			});

			test('should return false if the key does not exist in the object', () => {
				expect(evaluate('={{ ({ test1: 1 }).hasField("test2") }}')).toBe(false);
			});
		});

		test('.removeField should work on an object', () => {
			expect(evaluate('={{ ({ test1: 1, test2: 2, test3: 3 }).removeField("test2") }}')).toEqual({
				test1: 1,
				test3: 3,
			});
			expect(
				evaluate('={{ ({ test1: 1, test2: 2, test3: 3 }).removeField("testDoesntExist") }}'),
			).toEqual({
				test1: 1,
				test2: 2,
				test3: 3,
			});
		});

		describe('.removeFieldsContaining', () => {
			test('should work on an object', () => {
				expect(
					evaluate(
						'={{ ({ test1: "i exist", test2: "i should be removed", test3: "i should also be removed" }).removeFieldsContaining("removed") }}',
					),
				).toEqual({
					test1: 'i exist',
				});
			});

			test('should not work for empty string', () => {
				expect(() =>
					evaluate(
						'={{ ({ test1: "i exist", test2: "i should be removed", test3: "i should also be removed" }).removeFieldsContaining("") }}',
					),
				).toThrow();
			});
		});

		describe('.keepFieldsContaining', () => {
			test('.keepFieldsContaining should work on an object', () => {
				expect(
					evaluate(
						'={{ ({ test1: "i exist", test2: "i should be removed", test3: "i should also be removed" }).keepFieldsContaining("exist") }}',
					),
				).toEqual({
					test1: 'i exist',
				});
			});

			test('.keepFieldsContaining should work on a nested object', () => {
				expect(
					evaluate(
						'={{ ({ test1: "i exist", test2: "i should be removed", test3: { test4: "me too" } }).keepFieldsContaining("exist") }}',
					),
				).toEqual({
					test1: 'i exist',
				});
			});

			test('.keepFieldsContaining should not work for empty string', () => {
				expect(() =>
					evaluate(
						'={{ ({ test1: "i exist", test2: "i should be removed", test3: "i should also be removed" }).keepFieldsContaining("") }}',
					),
				).toThrow();
			});
		});

		describe('.compact', () => {
			test('should work on an object', () => {
				expect(
					evaluate('={{ ({ test1: 1, test2: "2", test3: undefined, test4: null }).compact() }}'),
				).toEqual({ test1: 1, test2: '2' });
			});

			test('should remove fields with null, undefined, empty string, or "nil"', () => {
				expect(
					evaluate(
						'={{ ({ test1: 0, test2: false, test3: "", test4: "nil", test5: NaN }).compact() }}',
					),
				).toEqual({ test1: 0, test2: false, test5: NaN });
			});

			test('should work on an empty object', () => {
				expect(evaluate('={{ ({}).compact() }}')).toEqual({});
			});

			test('should work on an object with all null/undefined values', () => {
				expect(evaluate('={{ ({ test1: undefined, test2: null }).compact() }}')).toEqual({});
			});

			test('should work on an object with nested null/undefined values', () => {
				expect(
					evaluate(
						'={{ ({ test1: 1, test2: { nested1: null, nested2: "value" }, test3: undefined }).compact() }}',
					),
				).toEqual({ test1: 1, test2: { nested2: 'value' } });
			});

			test('should not allow prototype pollution', () => {
				['{__proto__: {polluted: true}}', '{constructor: {prototype: {polluted: true}}}'].forEach(
					(testExpression) => {
						expect(() => evaluate(`={{ (${testExpression}).compact() }}`)).toThrow(
							ApplicationError,
						);
						expect(({} as any).polluted).toBeUndefined();
					},
				);
			});
		});

		test('.urlEncode should work on an object', () => {
			expect(evaluate('={{ ({ test1: 1, test2: "2" }).urlEncode() }}')).toEqual('test1=1&test2=2');
		});

		describe('.keys', () => {
			test('should return an array of keys from the object', () => {
				expect(evaluate('={{ ({ test1: 1, test2: 2 }).keys() }}')).toEqual(['test1', 'test2']);
			});

			test('should return an empty array for an empty object', () => {
				expect(evaluate('={{ ({}).keys() }}')).toEqual([]);
			});
		});

		describe('.values', () => {
			test('should return an array of values from the object', () => {
				expect(evaluate('={{ ({ test1: 1, test2: "value" }).values() }}')).toEqual([1, 'value']);
			});

			test('should return an empty array for an empty object', () => {
				expect(evaluate('={{ ({}).values() }}')).toEqual([]);
			});
		});

		test('.toJsonString() should work on an object', () => {
			expect(evaluate('={{ ({ test1: 1, test2: "2" }).toJsonString() }}')).toEqual(
				'{"test1":1,"test2":"2"}',
			);
		});

		describe('Conversion methods', () => {
			test('should exist but return undefined (to not break expressions with mixed data)', () => {
				expect(evaluate('={{ ({ test1: 1, test2: "2" }).toInt() }}')).toBeUndefined();
				expect(evaluate('={{ ({ test1: 1, test2: "2" }).toFloat() }}')).toBeUndefined();
				expect(evaluate('={{ ({ test1: 1, test2: "2" }).toBoolean() }}')).toBeUndefined();
				expect(evaluate('={{ ({ test1: 1, test2: "2" }).toDateTime() }}')).toBeUndefined();
			});

			it('should not have a doc (hidden from autocomplete)', () => {
				expect(objectExtensions.functions.toInt.doc).toBeUndefined();
				expect(objectExtensions.functions.toFloat.doc).toBeUndefined();
				expect(objectExtensions.functions.toBoolean.doc).toBeUndefined();
				expect(objectExtensions.functions.toDateTime.doc).toBeUndefined();
			});
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionExtensions/string-extensions.test.ts
================================================
// @vitest-environment jsdom
import { DateTime } from 'luxon';

import { evaluate } from './helpers';
import { ExpressionExtensionError } from '../../src/errors';

describe('Data Transformation Functions', () => {
	describe('String Data Transformation Functions', () => {
		describe('.isEmpty', () => {
			test('should work correctly on a string that is not empty', () => {
				expect(evaluate('={{"NotBlank".isEmpty()}}')).toEqual(false);
			});

			test('should work correctly on a string that is empty', () => {
				expect(evaluate('={{"".isEmpty()}}')).toEqual(true);
			});
		});

		describe('.isNotEmpty', () => {
			test('should work correctly on a string that is not empty', () => {
				expect(evaluate('={{"NotBlank".isNotEmpty()}}')).toEqual(true);
			});

			test('should work correctly on a string that is empty', () => {
				expect(evaluate('={{"".isNotEmpty()}}')).toEqual(false);
			});
		});

		test('.length should return the string length', () => {
			expect(evaluate('={{"String".length()}}')).toEqual(6);
		});

		describe('.hash()', () => {
			test.each([
				['base64', 'MTIzNDU='],
				['md5', '827ccb0eea8a706c4c34a16891f84e7b'],
				['sha1', '8cb2237d0679ca88db6464eac60da96345513964'],
				['sha224', 'a7470858e79c282bc2f6adfd831b132672dfd1224c1e78cbf5bcd057'],
				['sha256', '5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5'],
				[
					'sha384',
					'0fa76955abfa9dafd83facca8343a92aa09497f98101086611b0bfa95dbc0dcc661d62e9568a5a032ba81960f3e55d4a',
				],
				[
					'sha512',
					'3627909a29c31381a071ec27f7c9ca97726182aed29a7ddd2e54353322cfb30abb9e3a6df2ac2c20fe23436311d678564d0c8d305930575f60e2d3d048184d79',
				],
				[
					'sha3',
					'0a2a1719bf3ce682afdbedf3b23857818d526efbe7fcb372b31347c26239a0f916c398b7ad8dd0ee76e8e388604d0b0f925d5e913ad2d3165b9b35b3844cd5e6',
				],
			])('should work for %p', (hashFn, hashValue) => {
				expect(evaluate(`={{ "12345".hash("${hashFn}") }}`)).toEqual(hashValue);
				expect(evaluate(`={{ "12345".hash("${hashFn.toLowerCase()}") }}`)).toEqual(hashValue);
			});

			test('should throw on invalid algorithm', () => {
				expect(() => evaluate('={{ "12345".hash("invalid") }}')).toThrow('Unknown algorithm');
			});
		});

		test('.urlDecode should work correctly on a string', () => {
			expect(evaluate('={{ "string%20with%20spaces".urlDecode(false) }}')).toEqual(
				'string with spaces',
			);
		});

		test('.urlEncode should work correctly on a string', () => {
			expect(evaluate('={{ "string with spaces".urlEncode(false) }}')).toEqual(
				'string%20with%20spaces',
			);
		});

		test('.removeTags should work correctly on a string', () => {
			expect(evaluate('={{ "<html><head>test</head></html>".removeTags() }}')).toEqual('test');
		});

		test('.removeMarkdown should work correctly on a string', () => {
			expect(evaluate('={{ "<html><head>test</head></html>".removeMarkdown() }}')).toEqual('test');
		});

		test('.toLowerCase should work correctly on a string', () => {
			expect(evaluate('={{ "TEST".toLowerCase() }}')).toEqual('test');
		});

		describe('.toDate', () => {
			test('should work correctly on a date string', () => {
				expect(evaluate('={{ "2022-09-01T19:42:28.164Z".toDate() }}')).toEqual(
					new Date('2022-09-01T19:42:28.164Z'),
				);
			});

			test('should throw on invalid date', () => {
				expect(() => evaluate('={{ "2022-09-32T19:42:28.164Z".toDate() }}')).toThrow(
					'cannot convert to date',
				);
			});
		});

		test('.toFloat should work correctly on a string', () => {
			expect(evaluate('={{ "1.1".toFloat() }}')).toEqual(1.1);
			expect(evaluate('={{ "1.1".toDecimalNumber() }}')).toEqual(1.1);
		});

		test('.toInt should work correctly on a string', () => {
			expect(evaluate('={{ "1.1".toInt() }}')).toEqual(1);
			expect(evaluate('={{ "1.1".toWholeNumber() }}')).toEqual(1);
			expect(evaluate('={{ "1.5".toInt() }}')).toEqual(1);
			expect(evaluate('={{ "1.5".toWholeNumber() }}')).toEqual(1);
		});

		test('.quote should work correctly on a string', () => {
			expect(evaluate('={{ "test".quote() }}')).toEqual('"test"');
			expect(evaluate('={{ "\\"test\\"".quote() }}')).toEqual('"\\"test\\""');
		});

		test('.isNumeric should work correctly on a string', () => {
			expect(evaluate('={{ "".isNumeric() }}')).toEqual(false);
			expect(evaluate('={{ "asdf".isNumeric() }}')).toEqual(false);
			expect(evaluate('={{ "1234".isNumeric() }}')).toEqual(true);
			expect(evaluate('={{ "4e4".isNumeric() }}')).toEqual(true);
			expect(evaluate('={{ "4.4".isNumeric() }}')).toEqual(true);
		});

		test('.isUrl should work on a string', () => {
			expect(evaluate('={{ "https://example.com/".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "http://example.com/".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "ftp://example.com/".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "example.com".isUrl() }}')).toEqual(false);
			expect(evaluate('={{ "www.example.com".isUrl() }}')).toEqual(false);
			expect(evaluate('={{ "https://www.example.com/".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "https://example.com/path".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "https://example.com/path?query=1".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "https://example.com/path#fragment".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "https://example.com:8080".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "https://example.com?query=1".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "https://example.com#fragment".isUrl() }}')).toEqual(true);
			expect(evaluate('={{ "example.com/path".isUrl() }}')).toEqual(false);
			expect(evaluate('={{ "http:///".isUrl() }}')).toEqual(false);
			expect(evaluate('={{ "https://".isUrl() }}')).toEqual(false);
			expect(evaluate('={{ "example".isUrl() }}')).toEqual(false);
			expect(evaluate('={{ "".isUrl() }}')).toEqual(false);
		});

		test('.isDomain should work on a string', () => {
			expect(evaluate('={{ "example.com".isDomain() }}')).toEqual(true);
			expect(evaluate('={{ "asdf".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "https://example.com/".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "www.example.com".isDomain() }}')).toEqual(true);
			expect(evaluate('={{ "subdomain.example.com".isDomain() }}')).toEqual(true);
			expect(evaluate('={{ "example.co.uk".isDomain() }}')).toEqual(true);
			expect(evaluate('={{ "example".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "example.".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ ".com".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "example..com".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "example_com".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "example/com".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "example com".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "www.example..com".isDomain() }}')).toEqual(false);
			expect(evaluate('={{ "123.com".isDomain() }}')).toEqual(true);
			expect(evaluate('={{ "xn--80aswg.xn--p1ai".isDomain() }}')).toEqual(true); // Punycode domain
			expect(evaluate('={{ "example.com:8080".isDomain() }}')).toEqual(true);
			expect(evaluate('={{ "".isDomain() }}')).toEqual(false);
		});

		test('.toSnakeCase should work on a string', () => {
			expect(evaluate('={{ "I am a test!".toSnakeCase() }}')).toEqual('i_am_a_test');
			expect(evaluate('={{ "i_am_a_test".toSnakeCase() }}')).toEqual('i_am_a_test');
		});

		test('.toSentenceCase should work on a string', () => {
			expect(
				evaluate(
					'={{ "i am a test! i have multiple types of Punctuation. or do i?".toSentenceCase() }}',
				),
			).toEqual('I am a test! I have multiple types of punctuation. Or do i?');
			expect(evaluate('={{ "i am a test!".toSentenceCase() }}')).toEqual('I am a test!');
			expect(evaluate('={{ "i am a test".toSentenceCase() }}')).toEqual('I am a test');
		});

		test('.extractUrl should work on a string', () => {
			expect(
				evaluate(
					'={{ "I am a test with a url: https://example.net/ and I am a test with an email: test@example.org".extractUrl() }}',
				),
			).toEqual('https://example.net/');
			expect(
				evaluate(
					'={{ "Check this out: https://subdomain.example.com:3000/path?q=1#hash".extractUrl() }}',
				),
			).toEqual('https://subdomain.example.com:3000/path?q=1#hash');
			expect(evaluate('={{ "Invalid URL: http:///example.com".extractUrl() }}')).toEqual(undefined);
			expect(
				evaluate(
					'={{ "Mixed content: https://www.example.com and http://www.example.org".extractUrl() }}',
				),
			).toEqual('https://www.example.com');
			expect(
				evaluate('={{ "Text without URL: This is just a simple text".extractUrl() }}'),
			).toEqual(undefined);
			expect(
				evaluate('={{ "URL with Unicode: http://www.xn--80aswg.xn--j1amh".extractUrl() }}'),
			).toEqual('http://www.xn--80aswg.xn--j1amh');
			expect(
				evaluate('={{ "Localhost URL: http://localhost:8080/test?x=1".extractUrl() }}'),
			).toEqual('http://localhost:8080/test?x=1');
			expect(
				evaluate('={{ "IP URL: http://192.168.1.1:8000/path?q=value#frag".extractUrl() }}'),
			).toEqual('http://192.168.1.1:8000/path?q=value#frag');
		});

		test('.extractDomain should work on a string', () => {
			expect(evaluate('={{ "test@example.org".extractDomain() }}')).toEqual('example.org');
			expect(evaluate('={{ "https://example.org/".extractDomain() }}')).toEqual('example.org');
			expect(evaluate('={{ "https://www.google.com".extractDomain() }}')).toEqual('www.google.com');
			expect(evaluate('={{ "http://example.org".extractDomain() }}')).toEqual('example.org');
			expect(evaluate('={{ "ftp://ftp.example.com".extractDomain() }}')).toEqual('ftp.example.com');
			expect(evaluate('={{ "google.com".extractDomain() }}')).toEqual('google.com');
			expect(evaluate('={{ "www.example.net".extractDomain() }}')).toEqual('www.example.net');
			expect(evaluate('={{ "//example.com".extractDomain() }}')).toEqual('example.com');
			expect(evaluate('={{ "mailto:john.doe@example.com".extractDomain() }}')).toEqual(
				'example.com',
			);
			expect(evaluate('={{ "tel:+1-555-123-4567".extractDomain() }}')).toEqual(undefined);
			expect(evaluate('={{ "jane.doe@example.org".extractDomain() }}')).toEqual('example.org');
			expect(evaluate('={{ "name+tag@example.com".extractDomain() }}')).toEqual('example.com');
			expect(evaluate('={{ "first.last@example.co.uk".extractDomain() }}')).toEqual(
				'example.co.uk',
			);
			expect(evaluate('={{ "user@subdomain.example.com".extractDomain() }}')).toEqual(
				'subdomain.example.com',
			);
			expect(evaluate('={{ "www.example.net?test=1213".extractDomain() }}')).toEqual(
				'www.example.net',
			);
			expect(evaluate('={{ "www.example.net?test".extractDomain() }}')).toEqual('www.example.net');
			expect(evaluate('={{ "www.example.net#tesdt123".extractDomain() }}')).toEqual(
				'www.example.net',
			);
			expect(evaluate('={{ "https://www.example.net?test=1213".extractDomain() }}')).toEqual(
				'www.example.net',
			);
			expect(evaluate('={{ "https://www.example.net?test".extractDomain() }}')).toEqual(
				'www.example.net',
			);
			expect(evaluate('={{ "https://www.example.net#tesdt123".extractDomain() }}')).toEqual(
				'www.example.net',
			);
			expect(evaluate('={{ "https://192.168.1.1".extractDomain() }}')).toEqual('192.168.1.1');
			expect(evaluate('={{ "http://www.xn--80aswg.xn--j1amh".extractDomain() }}')).toEqual(
				'www.xn--80aswg.xn--j1amh',
			);
			expect(evaluate('={{ "https://localhost".extractDomain() }}')).toEqual('localhost');
			expect(evaluate('={{ "https://localhost?test=123".extractDomain() }}')).toEqual('localhost');
			expect(evaluate('={{ "https://www.example_with_underscore.com".extractDomain() }}')).toEqual(
				'www.example_with_underscore.com',
			);
			expect(evaluate('={{ "https://www.example.com:8080".extractDomain() }}')).toEqual(
				'www.example.com',
			);
			expect(evaluate('={{ "https://example.space".extractDomain() }}')).toEqual('example.space');
		});

		test('.extractEmail should work on a string', () => {
			expect(
				evaluate(
					'={{ "I am a test with a url: https://example.net/ and I am a test with an email: test@example.org".extractEmail() }}',
				),
			).toEqual('test@example.org');
		});

		test('.isEmail should work on a string', () => {
			expect(evaluate('={{ "test@example.com".isEmail() }}')).toEqual(true);
			expect(evaluate('={{ "aaaaaaaa".isEmail() }}')).toEqual(false);
			expect(evaluate('={{ "test @ n8n".isEmail() }}')).toEqual(false);
		});

		test('.toDateTime should work on a variety of formats', () => {
			expect(evaluate('={{ "Wed, 21 Oct 2015 07:28:00 GMT".toDateTime() }}')).toBeInstanceOf(
				DateTime,
			);
			expect(evaluate('={{ "2008-11-11".toDateTime() }}')).toBeInstanceOf(DateTime);
			expect(evaluate('={{ "1-Feb-2024".toDateTime() }}')).toBeInstanceOf(DateTime);
			expect(evaluate('={{ "1713976144063".toDateTime("ms") }}')).toBeInstanceOf(DateTime);
			expect(evaluate('={{ "31-01-2024".toDateTime("dd-MM-yyyy") }}')).toBeInstanceOf(DateTime);

			vi.useFakeTimers({ now: new Date() });
			expect(() => evaluate('={{ "hi".toDateTime() }}')).toThrow(
				new ExpressionExtensionError('cannot convert to Luxon DateTime'),
			);
			vi.useRealTimers();
		});

		test('.extractUrlPath should work on a string', () => {
			expect(
				evaluate('={{ "https://example.com/orders/1/detail#hash?foo=bar".extractUrlPath() }}'),
			).toEqual('/orders/1/detail');
			expect(evaluate('={{ "hi".extractUrlPath() }}')).toBeUndefined();
		});

		test('.parseJson should work on a string', () => {
			expect(evaluate('={{ \'{"test1":1,"test2":"2"}\'.parseJson() }}')).toEqual({
				test1: 1,
				test2: '2',
			});
		});

		test('.parseJson should throw on invalid JSON', () => {
			expect(() => evaluate("={{ \"{'test1':1,'test2':'2'}\".parseJson() }}")).toThrowError(
				"Parsing failed. Check you're using double quotes",
			);
			expect(() => evaluate('={{ "No JSON here".parseJson() }}')).toThrowError('Parsing failed');
		});

		test('.toJsonString should work on a string', () => {
			expect(evaluate('={{ "test".toJsonString() }}')).toEqual(JSON.stringify('test'));
			expect(evaluate('={{ "The \\"best\\" colours: red\\nbrown".toJsonString() }}')).toEqual(
				JSON.stringify('The "best" colours: red\nbrown'),
			);
			expect(evaluate('={{ "".toJsonString() }}')).toEqual(JSON.stringify(''));
		});

		test('.toBoolean should work on a string', () => {
			expect(evaluate('={{ "False".toBoolean() }}')).toBe(false);
			expect(evaluate('={{ "".toBoolean() }}')).toBe(false);
			expect(evaluate('={{ "0".toBoolean() }}')).toBe(false);
			expect(evaluate('={{ "no".toBoolean() }}')).toBe(false);
			expect(evaluate('={{ "TRUE".toBoolean() }}')).toBe(true);
			expect(evaluate('={{ "hello".toBoolean() }}')).toBe(true);
		});

		test('.base64Encode should work on a string', () => {
			expect(evaluate('={{ "n8n test".base64Encode() }}')).toBe('bjhuIHRlc3Q=');
		});

		test('.base64Decode should work on a string', () => {
			expect(evaluate('={{ "bjhuIHRlc3Q=".base64Decode() }}')).toBe('n8n test');
		});
	});
});



================================================
FILE: packages/workflow/test/ExpressionFixtures/base.ts
================================================
import { ExpressionError } from '../../src/errors/expression.error';
import type { GenericValue, IDataObject } from '../../src/interfaces';

interface ExpressionTestBase {
	type: 'evaluation' | 'transform';
}

interface ExpressionTestSuccess extends ExpressionTestBase {
	type: 'evaluation';
	input: Array<IDataObject | GenericValue>;
	output: IDataObject | GenericValue;
}

interface ExpressionTestFailure extends ExpressionTestBase {
	type: 'evaluation';
	input: Array<IDataObject | GenericValue>;
	error: ExpressionError;
}

export interface ExpressionTestTransform extends ExpressionTestBase {
	type: 'transform';
	// If we don't specify a result we expect it to be the same as the input
	result?: string;
	forceTransform?: boolean;
}

export type ExpressionTestEvaluation = ExpressionTestSuccess | ExpressionTestFailure;
export type ExpressionTests = ExpressionTestEvaluation | ExpressionTestTransform;

export interface ExpressionTestFixture {
	expression: string;
	tests: ExpressionTests[];
}

export const baseFixtures: ExpressionTestFixture[] = [
	{
		expression: '={{$json["contact"]["FirstName"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ contact: { FirstName: 'test' } }],
				output: 'test',
			},
			{
				type: 'evaluation',
				input: [{ contact: null }],
				output: undefined,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ $json["test"] }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ test: 'value' }],
				output: 'value',
			},
			{
				type: 'evaluation',
				input: [{ test: 1 }],
				output: 1,
			},
			{
				type: 'evaluation',
				input: [{ test: null }],
				output: null,
			},
			{
				type: 'evaluation',
				input: [{}],
				output: undefined,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json["test"].json["message"]["message_id"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ test: { json: { message: { message_id: 'value' } } } }],
				output: 'value',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json[$json["Set2"].json["apiKey"]]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ Set2: { json: { apiKey: 'testKey' } }, testKey: 'testValue' }],
				output: 'testValue',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json["get"].json["recipes"][0]["image"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ get: { json: { recipes: [{ image: 'test' }] } } }],
				output: 'test',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'=https://example.com/api/v1/workspaces/{{$json["Clockify1"].parameter["workspaceId"]}}/projects/{{$json["Clockify1"].json["id"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ Clockify1: { parameter: { workspaceId: 'test1' }, json: { id: 'test2' } } }],
				output: 'https://example.com/api/v1/workspaces/test1/projects/test2',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '= {{$json["dig check CF"].data["stdout"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ 'dig check CF': { data: { stdout: 'testout' } } }],
				output: ' testout',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$item(0).$json["Set URL"].json["base_domain"]}}{{$json["link"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ 'Set URL': { json: { base_domain: 'left' } }, link: 'right' }],
				output: 'leftright',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$runIndex}}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: 0,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ new String().toString() }}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: '',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={{(Date.parse($json["IF Zoom meeting"].json["end"]["dateTime"])-Date.parse($json["IF Zoom meeting"].json["start"]["dateTime"]))/(60*1000)}}',
		tests: [
			{
				type: 'evaluation',
				input: [
					{
						'IF Zoom meeting': {
							json: {
								end: { dateTime: '2023-02-09T13:32:54.187Z' },
								start: { dateTime: '2023-02-09T13:22:54.187Z' },
							},
						},
					},
				],
				output: 10,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json["GetTicket"].json["tickets"].length}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ GetTicket: { json: { tickets: [1, 2, 3, 4] } } }],
				output: 4,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ $json.toString() }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ test: 1 }],
				output: '[object Object]',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{Math.floor(Math.min(1, 2) * 100);}}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: 100,
			},
			{
				type: 'transform',
				result: '={{extend(Math, "floor", [extend(Math, "min", [1, 2]) * 100])}}',
			},
		],
	},
	{
		expression: '={{$json["\u56fe\u7247\u6570\u91cf\u5224\u65ad"].data["imgList"][0]}}',
		tests: [
			{
				type: 'evaluation',
				input: [
					{
						'\u56fe\u7247\u6570\u91cf\u5224\u65ad': {
							data: { imgList: ['test'] },
						},
					},
				],
				output: 'test',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ $json["phone"] ?? 0}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ phone: 'test' }],
				output: 'test',
			},
			{
				type: 'evaluation',
				input: [{ phone: null }],
				output: 0,
			},
			{
				type: 'evaluation',
				input: [{}],
				output: 0,
			},
			{
				type: 'evaluation',
				input: [],
				error: new ExpressionError("Node 'node' hasn't been executed", {
					runIndex: 0,
					itemIndex: -1,
					type: 'no_execution_data',
					functionality: 'pairedItem',
					messageTemplate:
						'An expression references this node, but the node is unexecuted. Consider re-wiring your nodes or checking for execution first, i.e. {{ $if( $("{{nodeName}}").isExecuted, <action_if_executed>, "") }}',
					descriptionKey: 'pairedItemNoConnection',
					nodeCause: 'node',
				}),
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			"={{$json['Webhook1'].json[\"headers\"][\"x-api-key\"] +'-'+ new String('test').toString()}}",
		tests: [
			{
				type: 'evaluation',
				input: [{ Webhook1: { json: { headers: { 'x-api-key': 'left' } } } }],
				output: 'left-test',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={{$json[\'Webhook1\'].json["headers"]["x-api-key"] +\'-\'+ parseInt($json.test)}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ Webhook1: { json: { headers: { 'x-api-key': 'left' } } }, test: 3 }],
				output: 'left-3',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ [].concat($json["Create or update"].json["vid"]) }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ 'Create or update': { json: { vid: [1, 2, 3] } } }],
				output: [1, 2, 3],
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '=https://example.com/test?id={{$json["Crypto"].json["data"].substr(0,6)}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ Crypto: { json: { data: 'testtest' } } }],
				output: 'https://example.com/test?id=testte',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ $json["body"]["project"]["name"].match(/\\[(\\d+)]/)[1] }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ body: { project: { name: 'test[1234]' } } }],
				output: '1234',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={{(new Date($json["end"]["date"]).getTime() - new Date($json["start"]["date"]).getTime()) / (1000 * 3600 * 24)}}',
		tests: [
			{
				type: 'evaluation',
				input: [
					{
						start: { date: '2023-02-09T13:22:54.187Z' },
						end: { date: '2023-02-13T13:22:54.187Z' },
					},
				],
				output: 4,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={{ $json["projectName"] == "" ? "Project Group " + ($json["projectsCount"] + 1) : $json["projectName"] }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ projectName: '', projectsCount: 3 }],
				output: 'Project Group 4',
			},
			{
				type: 'evaluation',
				input: [{ projectName: 'Project Test', projectsCount: 3 }],
				output: 'Project Test',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{new Date($json["created_at"]).toISOString()}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ created_at: '2023-02-09T13:22:54.187Z' }],
				output: '2023-02-09T13:22:54.187Z',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json["Find by ID1"].json["fields"]["clicks"]+1}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ 'Find by ID1': { json: { fields: { clicks: 8 } } } }],
				output: 9,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={{ (parseFloat($json["Bid"].replace(\',\', \'.\')) * parseFloat($json["Baserow"].json["Count"])).toFixed(2) }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ Bid: '3,80', Baserow: { json: { Count: '10' } } }],
				output: '38.00',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={\n\t"article": {\n\t\t"title": "{{$json["body"]["entry"]["Title"]}}",\n\t\t"published": true,\n\t\t"article_markdown": "{{$json["body"]["entry"]["PostContent"]}}",\n\t\t"tags":["{{$json["body"]["entry"]["Tag"]}}"]\n\t}\n}',
		tests: [
			{
				type: 'evaluation',
				input: [
					{ body: { entry: { Title: 'title', PostContent: 'test contents', Tag: 'testTag' } } },
				],
				output: `{
	"article": {
		"title": "title",
		"published": true,
		"article_markdown": "test contents",
		"tags":["testTag"]
	}
}`,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression:
			'={{$json["Find by ID"].json["id"] != "" && $json["Find by ID"].json["id"] != null && $json["Find by ID"].json["id"] != undefined}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ 'Find by ID': { json: { id: 'test' } } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ 'Find by ID': { json: { id: '' } } }],
				output: false,
			},
			{
				type: 'evaluation',
				input: [{ 'Find by ID': { json: { id: null } } }],
				output: false,
			},
			{
				type: 'evaluation',
				input: [{ 'Find by ID': { json: {} } }],
				output: false,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json["HTTP Request"].json["paging"] ? true : false}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ 'HTTP Request': { json: { paging: 'test' } } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ 'HTTP Request': { json: {} } }],
				output: false,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{Math.min(1, 2);}}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: 1,
			},
			{ type: 'transform', result: '={{extend(Math, "min", [1, 2])}}' },
		],
	},
	{
		expression: '={{new String().toString();}}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: '',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true, result: '={{new String().toString()}}' },
		],
	},
	{
		expression: '={{ !!$json["different"]["name"] || !!$json["different"]["phone"] }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ different: { name: 'test' } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ different: { phone: 'test' } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ different: {} }],
				output: false,
			},
			{
				type: 'evaluation',
				input: [{ different: { phone: 'test', name: 'test2' } }],
				output: true,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{200}}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: 200,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{$json.assetValue * $json.value / 100}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ assetValue: 50, value: 50 }],
				output: 25,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{/^\\d+$/.test($json["search_term"])}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ search_term: '1234' }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ search_term: 'asdf' }],
				output: false,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ `test\nvalue\nmulti\nline` }}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: `test
value
multi
line`,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ { "data": $json.body.choices } }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ body: { choices: 'testValue' } }],
				output: { data: 'testValue' },
			},
			{ type: 'transform' },
			{
				type: 'transform',
				forceTransform: true,
				result: '={{( { "data": $json.body.choices } )}}',
			},
		],
	},
	{
		expression: '={{ $json["data"]["errors"] && $json["data"]["errors"].length > 0 }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ data: { errors: [1, 2, 3, 4] } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ data: { errors: [] } }],
				output: false,
			},
			{
				type: 'evaluation',
				input: [{ data: {} }],
				output: undefined,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{asdas}}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: undefined,
			},
			{
				type: 'evaluation',
				input: [{ asdas: 1 }],
				output: undefined,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{!!$json["data"]["errors"]}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ data: { errors: [] } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ data: {} }],
				output: false,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '=TRUE',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: 'TRUE',
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ !$json?.data?.data?.issues?.pageInfo?.hasNextPage }}',
		tests: [
			{
				type: 'evaluation',
				input: [{ data: { data: { issues: { pageInfo: { hasNextPage: true } } } } }],
				output: false,
			},
			{
				type: 'evaluation',
				input: [{ data: { data: { issues: { pageInfo: { hasNextPage: false } } } } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ data: { data: { issues: { pageInfo: {} } } } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ data: { data: { issues: {} } } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ data: { data: {} } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ data: {} }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{}],
				output: true,
			},
			{ type: 'transform' },
			{
				type: 'transform',
				forceTransform: true,
				result:
					'={{ !(window.chainCancelToken1 = ((window.chainValue1 = $json) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.data) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.data) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.issues) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainCancelToken1 = ((window.chainValue1 = window.chainValue1.pageInfo) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.hasNextPage) }}',
			},
		],
	},
	{
		expression: "={{ [{'name': 'something', 'batch_size':1000, 'ignore_cols':['x']}] }}",
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: [{ name: 'something', batch_size: 1000, ignore_cols: ['x'] }],
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{typeof $json["person"].json["name"] != "undefined"}}',
		tests: [
			{
				type: 'evaluation',
				input: [{ person: { json: { name: 'test' } } }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ person: { json: {} } }],
				output: false,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: "={{ $json?.data == undefined ? '' : $json.data }}",
		tests: [
			{
				type: 'evaluation',
				input: [{ data: 1 }],
				output: 1,
			},
			{
				type: 'evaluation',
				input: [{}],
				output: '',
			},
			{ type: 'transform' },
			{
				type: 'transform',
				forceTransform: true,
				result:
					"={{ (window.chainCancelToken1 = ((window.chainValue1 = $json) ?? undefined) === undefined, window.chainCancelToken1 === true ? undefined : window.chainValue1.data) == undefined ? '' : $json.data }}",
			},
		],
	},
	{
		expression: "={{ 'domain' in $json && $json.domain != null}}",
		tests: [
			{
				type: 'evaluation',
				input: [{ domain: 1 }],
				output: true,
			},
			{
				type: 'evaluation',
				input: [{ domain: null }],
				output: false,
			},
			{
				type: 'evaluation',
				input: [{}],
				output: false,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
	{
		expression: '={{ String("testing").length }}',
		tests: [
			{
				type: 'evaluation',
				input: [],
				output: 7,
			},
			{ type: 'transform' },
			{ type: 'transform', forceTransform: true },
		],
	},
];



================================================
FILE: packages/workflow/test/expressions/expression-helpers.test.ts
================================================
import { isExpression } from '../../src/expressions/expression-helpers';

describe('ExpressionHelpers', () => {
	describe('isExpression', () => {
		describe('should return true for valid expressions', () => {
			test.each([
				['=1', 'simple number expression'],
				['=true', 'boolean expression'],
				['="hello"', 'string expression'],
				['={{ $json.field }}', 'complex expression with spaces'],
			])('"$s" should be an expression', (expr) => {
				expect(isExpression(expr)).toBe(true);
			});
		});

		describe('should return false for invalid expressions', () => {
			test.each([[null], [undefined], [1], [true], [''], ['hello']])(
				'"$s" should not be an expression',
				(expr) => {
					expect(isExpression(expr)).toBe(false);
				},
			);
		});
	});
});



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/agentInfo_run.json
================================================
{
	"data": {
		"resultData": {
			"runData": {}
		}
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/agentInfo_workflow.json
================================================
{
	"nodes": [
		{
			"parameters": {
				"options": {}
			},
			"type": "@n8n/n8n-nodes-langchain.agent",
			"typeVersion": 1.8,
			"position": [280, -160],
			"id": "48d38b5e-d75f-4245-9f6b-c9ab623b1a7a",
			"name": "AI Agent"
		},
		{
			"parameters": {},
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1,
			"position": [0, 0],
			"id": "914a83be-5bd5-46f9-8b39-1456d12f9429",
			"name": "When clicking ‘Execute workflow’"
		},
		{
			"parameters": {},
			"type": "@n8n/n8n-nodes-langchain.toolCalculator",
			"typeVersion": 1,
			"position": [780, 60],
			"id": "d939bfce-6fbd-4f13-8ba2-91d605bdb81b",
			"name": "Calculator"
		},
		{
			"parameters": {},
			"type": "@n8n/n8n-nodes-langchain.toolWikipedia",
			"typeVersion": 1,
			"position": [680, 500],
			"id": "efdb00f3-cf60-4c3a-9b18-2523d2fc3177",
			"name": "Wikipedia"
		},
		{
			"parameters": {
				"calendar": {
					"__rl": true,
					"mode": "list",
					"value": ""
				},
				"start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start', ``, 'string') }}",
				"additionalFields": {}
			},
			"type": "n8n-nodes-base.googleCalendarTool",
			"typeVersion": 1.3,
			"position": [440, 60],
			"id": "a76e6696-1e19-4aa4-b5d4-c43b332c8bc8",
			"name": "Google Calendar"
		},
		{
			"parameters": {
				"options": {}
			},
			"type": "@n8n/n8n-nodes-langchain.agent",
			"typeVersion": 1.8,
			"position": [280, 280],
			"id": "18a77a68-10dc-486d-b179-6d787371878c",
			"name": "Another Agent"
		},
		{
			"parameters": {},
			"type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
			"typeVersion": 1.3,
			"position": [300, 80],
			"id": "a0f31ee2-14b1-4ce7-97eb-a070346db0d3",
			"name": "Simple Memory"
		}
	],
	"connections": {
		"When clicking ‘Execute workflow’": {
			"main": [
				[
					{
						"node": "AI Agent",
						"type": "main",
						"index": 0
					},
					{
						"node": "Another Agent",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Calculator": {
			"ai_tool": [[]]
		},
		"Wikipedia": {
			"ai_tool": [
				[
					{
						"node": "Another Agent",
						"type": "ai_tool",
						"index": 0
					}
				]
			]
		},
		"Google Calendar": {
			"ai_tool": [
				[
					{
						"node": "AI Agent",
						"type": "ai_tool",
						"index": 0
					}
				]
			]
		},
		"Simple Memory": {
			"ai_memory": [
				[
					{
						"node": "AI Agent",
						"type": "ai_memory",
						"index": 0
					}
				]
			]
		}
	},
	"pinData": {},
	"meta": {
		"instanceId": "866ca65bee13401b1e2b632cdf2767d28ec3301d61bdb4ceabc832d1fe22a83e"
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/base_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"Start": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [
								[
									{
										"json": {}
									}
								]
							]
						},
						"source": []
					}
				],
				"Function": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [
								[
									{
										"json": { "initialName": 105 },
										"pairedItem": { "item": 0 }
									},
									{
										"json": { "initialName": 160 },
										"pairedItem": { "item": 0 }
									},
									{
										"json": { "initialName": 121 },
										"pairedItem": { "item": 0 }
									},
									{
										"json": { "initialName": 275 },
										"pairedItem": { "item": 0 }
									},
									{
										"json": { "initialName": 950 },
										"pairedItem": { "item": 0 }
									}
								]
							]
						},
						"source": [
							{
								"previousNode": "Start"
							}
						]
					}
				],
				"Rename": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [
								[
									{
										"json": { "data": 105 },
										"pairedItem": { "item": 0 }
									},
									{
										"json": { "data": 160 },
										"pairedItem": { "item": 1 }
									},
									{
										"json": { "data": 121 },
										"pairedItem": { "item": 2 }
									},
									{
										"json": { "data": 275 },
										"pairedItem": { "item": 3 }
									},
									{
										"json": { "data": 950 },
										"pairedItem": { "item": 4 }
									}
								]
							]
						},
						"source": [
							{
								"previousNode": "Function"
							}
						]
					}
				],
				"End": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [
								[
									{
										"json": { "data": 105 },
										"pairedItem": { "item": 0 }
									},
									{
										"json": { "data": 160 },
										"pairedItem": { "item": 1 }
									},
									{
										"json": { "data": 121 },
										"pairedItem": { "item": 2 }
									},
									{
										"json": { "data": 275 },
										"pairedItem": { "item": 3 }
									},
									{
										"json": { "data": 950 },
										"pairedItem": { "item": 4 }
									}
								]
							]
						},
						"source": [
							{
								"previousNode": "Rename"
							}
						]
					}
				]
			}
		}
	},
	"mode": "manual",
	"startedAt": "2024-02-08T15:45:18.848Z",
	"stoppedAt": "2024-02-08T15:45:18.862Z",
	"status": "running"
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/base_workflow.json
================================================
{
	"name": "",
	"nodes": [
		{
			"name": "Start",
			"type": "test.set",
			"parameters": {},
			"typeVersion": 1,
			"id": "uuid-1",
			"position": [100, 200]
		},
		{
			"name": "Function",
			"type": "test.set",
			"parameters": {
				"functionCode": "// Code here will run only once, no matter how many input items there are.\n// More info and help: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.function/\nconst { DateTime, Duration, Interval } = require(\"luxon\");\n\nconst data = [\n  {\n  \"length\": 105\n  },\n  {\n  \"length\": 160\n  },\n  {\n  \"length\": 121\n  },\n  {\n  \"length\": 275\n  },\n  {\n  \"length\": 950\n  },\n];\n\nreturn data.map(fact => ({json: fact}));"
			},
			"typeVersion": 1,
			"id": "uuid-2",
			"position": [280, 200]
		},
		{
			"name": "Rename",
			"type": "test.set",
			"parameters": {
				"value1": "data",
				"value2": "initialName"
			},
			"typeVersion": 1,
			"id": "uuid-3",
			"position": [460, 200]
		},
		{
			"name": "Set",
			"type": "test.set",
			"parameters": {},
			"typeVersion": 1,
			"id": "uuid-4",
			"position": [640, 200]
		},
		{
			"name": "End",
			"type": "test.set",
			"parameters": {},
			"typeVersion": 1,
			"id": "uuid-5",
			"position": [640, 200]
		}
	],
	"pinData": {},
	"connections": {
		"Start": {
			"main": [
				[
					{
						"node": "Function",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Function": {
			"main": [
				[
					{
						"node": "Rename",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Rename": {
			"main": [
				[
					{
						"node": "End",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/errors_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"When clicking ‘Execute workflow’": [
					{
						"startTime": 1707471743600,
						"executionTime": 1,
						"source": [],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {},
										"pairedItem": {
											"item": 0
										}
									}
								]
							]
						}
					}
				],
				"Customer Datastore (n8n training)": [
					{
						"startTime": 1707471743602,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "When clicking ‘Execute workflow’"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"id": "23423532",
											"name": "Jay Gatsby",
											"email": "gatsby@west-egg.com",
											"notes": "Keeps asking about a green light??",
											"country": "US",
											"created": "1925-04-10"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"id": "23423533",
											"name": "JosÃ© Arcadio BuendÃ­a",
											"email": "jab@macondo.co",
											"notes": "Lots of people named after him. Very confusing",
											"country": "CO",
											"created": "1967-05-05"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"id": "23423534",
											"name": "Max Sendak",
											"email": "info@in-and-out-of-weeks.org",
											"notes": "Keeps rolling his terrible eyes",
											"country": "US",
											"created": "1963-04-09"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"id": "23423535",
											"name": "Zaphod Beeblebrox",
											"email": "captain@heartofgold.com",
											"notes": "Felt like I was talking to more than one person",
											"country": null,
											"created": "1979-10-12"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"id": "23423536",
											"name": "Edmund Pevensie",
											"email": "edmund@narnia.gov",
											"notes": "Passionate sailor",
											"country": "UK",
											"created": "1950-10-16"
										},
										"pairedItem": {
											"item": 0
										}
									}
								]
							]
						}
					}
				],
				"Edit Fields": [
					{
						"startTime": 1707471743604,
						"executionTime": 2,
						"source": [
							{
								"previousNode": "Customer Datastore (n8n training)"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"id": "23423532",
											"name": "Jay Gatsby",
											"email": "gatsby@west-egg.com",
											"notes": "Keeps asking about a green light??",
											"country": "US",
											"created": "1925-04-10"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"id": "23423533",
											"name": "JosÃ© Arcadio BuendÃ­a",
											"email": "jab@macondo.co",
											"notes": "Lots of people named after him. Very confusing",
											"country": "CO",
											"created": "1967-05-05"
										},
										"pairedItem": {
											"item": 1
										}
									},
									{
										"json": {
											"id": "23423534",
											"name": "Max Sendak",
											"email": "info@in-and-out-of-weeks.org",
											"notes": "Keeps rolling his terrible eyes",
											"country": "US",
											"created": "1963-04-09"
										},
										"pairedItem": {
											"item": 2
										}
									},
									{
										"json": {
											"id": "23423535",
											"name": "Zaphod Beeblebrox",
											"email": "captain@heartofgold.com",
											"notes": "Felt like I was talking to more than one person",
											"country": null,
											"created": "1979-10-12"
										},
										"pairedItem": {
											"item": 3
										}
									},
									{
										"json": {
											"id": "23423536",
											"name": "Edmund Pevensie",
											"email": "edmund@narnia.gov",
											"notes": "Passionate sailor",
											"country": "UK",
											"created": "1950-10-16"
										},
										"pairedItem": {
											"item": 4
										}
									}
								]
							]
						}
					}
				],
				"Aggregate": [
					{
						"startTime": 1707471743607,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"name": [
												"Jay Gatsby",
												"JosÃ© Arcadio BuendÃ­a",
												"Max Sendak",
												"Zaphod Beeblebrox",
												"Edmund Pevensie"
											]
										},
										"pairedItem": [
											{
												"item": 0
											},
											{
												"item": 1
											},
											{
												"item": 2
											},
											{
												"item": 3
											},
											{
												"item": 4
											}
										]
									}
								]
							]
						}
					}
				],
				"PairedItemMultipleMatches": [
					{
						"startTime": 1707471743609,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "Aggregate"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "Invalid expression",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Break pairedItem chain": [
					{
						"startTime": 1707471743611,
						"executionTime": 5,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"field": "the same"
										}
									}
								]
							]
						}
					}
				],
				"PairedItemInfoMissing": [
					{
						"startTime": 1707471743617,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "Break pairedItem chain"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "Canât get data for expression",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Break pairedItem chain, pinned": [
					{
						"startTime": 1707471743619,
						"executionTime": 0,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"field": "the same"
										}
									}
								]
							]
						}
					}
				],
				"PairedItemInfoMissingPinned": [
					{
						"startTime": 1707471743620,
						"executionTime": 2,
						"source": [
							{
								"previousNode": "Break pairedItem chain, pinned"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "âNode Break pairedItem chain, pinnedâ must be unpinned to execute",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Incorrect pairedItem info": [
					{
						"startTime": 1707471743623,
						"executionTime": 3,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"field": "the same"
										},
										"pairedItem": 99
									}
								]
							]
						}
					}
				],
				"IncorrectPairedItem": [
					{
						"startTime": 1707471743628,
						"executionTime": 2,
						"source": [
							{
								"previousNode": "Incorrect pairedItem info"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "Canât get data for expression",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Incorrect pairedItem info, pinned1": [
					{
						"startTime": 1707471743631,
						"executionTime": 0,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"field": "the same"
										}
									}
								]
							]
						}
					}
				],
				"IncorrectPairedItemPinned": [
					{
						"startTime": 1707471743632,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "Incorrect pairedItem info, pinned1"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "âNode Incorrect pairedItem info, pinned1â must be unpinned to execute",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Multiple matching items": [
					{
						"startTime": 1707471743634,
						"executionTime": 5,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"field": "the same"
										},
										"pairedItem": [1, 2, 3, 4]
									}
								]
							]
						}
					}
				],
				"PairedItemMultipleMatches2": [
					{
						"startTime": 1707471743640,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "Multiple matching items"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "Invalid expression",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Multiple matching items, pinned": [
					{
						"startTime": 1707471743642,
						"executionTime": 0,
						"source": [
							{
								"previousNode": "Edit Fields"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"field": "the same"
										}
									}
								]
							]
						}
					}
				],
				"IncorrectPairedItemPinned2": [
					{
						"startTime": 1707471743645,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "Multiple matching items, pinned"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"error": "âNode Multiple matching items, pinnedâ must be unpinned to execute",
											"pairedItem": {
												"item": 0
											}
										},
										"pairedItem": {
											"item": 0
										}
									}
								],
								[]
							]
						}
					}
				],
				"Reference impossible with .item": [
					{
						"startTime": 1707471743647,
						"executionTime": 15,
						"source": [
							{
								"previousNode": "Customer Datastore (n8n training)"
							}
						],
						"executionStatus": "error",
						"error": {
							"level": "error",
							"tags": {},
							"context": {
								"itemIndex": 0,
								"messageTemplate": "Invalid expression under â%%PARAMETER%%â",
								"functionality": "pairedItem",
								"nodeCause": "Impossible",
								"type": "paired_item_no_connection",
								"parameter": "fields.values"
							},
							"functionality": "regular",
							"name": "NodeOperationError",
							"timestamp": 1707471743662,
							"node": {
								"parameters": {
									"mode": "manual",
									"duplicateItem": false,
									"fields": {
										"values": [
											{
												"name": "name",
												"type": "stringValue",
												"stringValue": "={{ $('Impossible').item.json.name }}"
											}
										]
									},
									"include": "all",
									"options": {}
								},
								"id": "4cbbee96-dd4c-4625-95b9-c68faef3e9a8",
								"name": "Reference impossible with .item",
								"type": "n8n-nodes-base.set",
								"typeVersion": 3.2,
								"position": [1420, 2000]
							},
							"description": "The expression uses data in the node <strong>âImpossibleâ</strong> but there is no path back to it. Please check this node is connected to it (there can be other nodes in between).",
							"message": "Invalid expression",
							"stack": "NodeOperationError: Invalid expression\n    at Object.execute (/usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+nodes-base_asn1.js@5.4.1_date-fns@2.30.0_promise-ftp-common@1.1.5_zod@3.22.4/node_modules/n8n-nodes-base/dist/nodes/Set/v2/manual.mode.js:197:15)\n    at Object.execute (/usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+nodes-base_asn1.js@5.4.1_date-fns@2.30.0_promise-ftp-common@1.1.5_zod@3.22.4/node_modules/n8n-nodes-base/dist/nodes/Set/v2/SetV2.node.js:286:57)\n    at Workflow.runNode (/usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+workflow/node_modules/n8n-workflow/dist/Workflow.js:706:42)\n    at /usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+core_n8n-nodes-base@1.28.0/node_modules/n8n-core/dist/WorkflowExecute.js:656:68\n    at /usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+core_n8n-nodes-base@1.28.0/node_modules/n8n-core/dist/WorkflowExecute.js:1058:20"
						}
					}
				]
			},
			"pinData": {
				"Multiple matching items, pinned": [
					{
						"json": {
							"field": "the same"
						}
					}
				],
				"Incorrect pairedItem info, pinned1": [
					{
						"json": {
							"field": "the same"
						}
					}
				],
				"Break pairedItem chain, pinned": [
					{
						"json": {
							"field": "the same"
						}
					}
				]
			},
			"lastNodeExecuted": "Reference impossible with .item",
			"error": {
				"level": "error",
				"tags": {},
				"context": {
					"itemIndex": 0,
					"messageTemplate": "Invalid expression under â%%PARAMETER%%â",
					"functionality": "pairedItem",
					"nodeCause": "Impossible",
					"type": "paired_item_no_connection",
					"parameter": "fields.values"
				},
				"functionality": "regular",
				"name": "NodeOperationError",
				"timestamp": 1707471743662,
				"node": {
					"parameters": {
						"mode": "manual",
						"duplicateItem": false,
						"fields": {
							"values": [
								{
									"name": "name",
									"type": "stringValue",
									"stringValue": "={{ $('Impossible').item.json.name }}"
								}
							]
						},
						"include": "all",
						"options": {}
					},
					"id": "4cbbee96-dd4c-4625-95b9-c68faef3e9a8",
					"name": "Reference impossible with .item",
					"type": "n8n-nodes-base.set",
					"typeVersion": 3.2,
					"position": [1420, 2000]
				},
				"description": "The expression uses data in the node <strong>âImpossibleâ</strong> but there is no path back to it. Please check this node is connected to it (there can be other nodes in between).",
				"message": "Invalid expression",
				"stack": "NodeOperationError: Invalid expression\n    at Object.execute (/usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+nodes-base_asn1.js@5.4.1_date-fns@2.30.0_promise-ftp-common@1.1.5_zod@3.22.4/node_modules/n8n-nodes-base/dist/nodes/Set/v2/manual.mode.js:197:15)\n    at Object.execute (/usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+nodes-base_asn1.js@5.4.1_date-fns@2.30.0_promise-ftp-common@1.1.5_zod@3.22.4/node_modules/n8n-nodes-base/dist/nodes/Set/v2/SetV2.node.js:286:57)\n    at Workflow.runNode (/usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+workflow/node_modules/n8n-workflow/dist/Workflow.js:706:42)\n    at /usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+core_n8n-nodes-base@1.28.0/node_modules/n8n-core/dist/WorkflowExecute.js:656:68\n    at /usr/local/lib/node_modules/n8n/node_modules/.pnpm/file+packages+core_n8n-nodes-base@1.28.0/node_modules/n8n-core/dist/WorkflowExecute.js:1058:20"
			}
		},
		"executionData": {
			"contextData": {},
			"nodeExecutionStack": [
				{
					"node": {
						"parameters": {
							"mode": "manual",
							"duplicateItem": false,
							"fields": {
								"values": [
									{
										"name": "name",
										"type": "stringValue",
										"stringValue": "={{ $('Impossible').item.json.name }}"
									}
								]
							},
							"include": "all",
							"options": {}
						},
						"id": "4cbbee96-dd4c-4625-95b9-c68faef3e9a8",
						"name": "Reference impossible with .item",
						"type": "n8n-nodes-base.set",
						"typeVersion": 3.2,
						"position": [1420, 2000]
					},
					"data": {
						"main": [
							[
								{
									"json": {
										"id": "23423532",
										"name": "Jay Gatsby",
										"email": "gatsby@west-egg.com",
										"notes": "Keeps asking about a green light??",
										"country": "US",
										"created": "1925-04-10"
									},
									"pairedItem": {
										"item": 0
									}
								},
								{
									"json": {
										"id": "23423533",
										"name": "JosÃ© Arcadio BuendÃ­a",
										"email": "jab@macondo.co",
										"notes": "Lots of people named after him. Very confusing",
										"country": "CO",
										"created": "1967-05-05"
									},
									"pairedItem": {
										"item": 1
									}
								},
								{
									"json": {
										"id": "23423534",
										"name": "Max Sendak",
										"email": "info@in-and-out-of-weeks.org",
										"notes": "Keeps rolling his terrible eyes",
										"country": "US",
										"created": "1963-04-09"
									},
									"pairedItem": {
										"item": 2
									}
								},
								{
									"json": {
										"id": "23423535",
										"name": "Zaphod Beeblebrox",
										"email": "captain@heartofgold.com",
										"notes": "Felt like I was talking to more than one person",
										"country": null,
										"created": "1979-10-12"
									},
									"pairedItem": {
										"item": 3
									}
								},
								{
									"json": {
										"id": "23423536",
										"name": "Edmund Pevensie",
										"email": "edmund@narnia.gov",
										"notes": "Passionate sailor",
										"country": "UK",
										"created": "1950-10-16"
									},
									"pairedItem": {
										"item": 4
									}
								}
							]
						]
					},
					"source": {
						"main": [
							{
								"previousNode": "Customer Datastore (n8n training)"
							}
						]
					}
				},
				{
					"node": {
						"parameters": {
							"mode": "manual",
							"duplicateItem": false,
							"fields": {
								"values": [
									{
										"name": "name",
										"type": "stringValue",
										"stringValue": "={{ $('Impossible').first().json.name }}"
									}
								]
							},
							"include": "all",
							"options": {}
						},
						"id": "6d47bd08-810a-4ade-be57-635adc1df47f",
						"name": "Reference impossible with .first()",
						"type": "n8n-nodes-base.set",
						"typeVersion": 3.2,
						"position": [1420, 2320]
					},
					"data": {
						"main": [
							[
								{
									"json": {
										"id": "23423532",
										"name": "Jay Gatsby",
										"email": "gatsby@west-egg.com",
										"notes": "Keeps asking about a green light??",
										"country": "US",
										"created": "1925-04-10"
									},
									"pairedItem": {
										"item": 0
									}
								},
								{
									"json": {
										"id": "23423533",
										"name": "JosÃ© Arcadio BuendÃ­a",
										"email": "jab@macondo.co",
										"notes": "Lots of people named after him. Very confusing",
										"country": "CO",
										"created": "1967-05-05"
									},
									"pairedItem": {
										"item": 0
									}
								},
								{
									"json": {
										"id": "23423534",
										"name": "Max Sendak",
										"email": "info@in-and-out-of-weeks.org",
										"notes": "Keeps rolling his terrible eyes",
										"country": "US",
										"created": "1963-04-09"
									},
									"pairedItem": {
										"item": 0
									}
								},
								{
									"json": {
										"id": "23423535",
										"name": "Zaphod Beeblebrox",
										"email": "captain@heartofgold.com",
										"notes": "Felt like I was talking to more than one person",
										"country": null,
										"created": "1979-10-12"
									},
									"pairedItem": {
										"item": 0
									}
								},
								{
									"json": {
										"id": "23423536",
										"name": "Edmund Pevensie",
										"email": "edmund@narnia.gov",
										"notes": "Passionate sailor",
										"country": "UK",
										"created": "1950-10-16"
									},
									"pairedItem": {
										"item": 0
									}
								}
							]
						]
					},
					"source": {
						"main": [
							{
								"previousNode": "Customer Datastore (n8n training)"
							}
						]
					}
				},
				{
					"node": {
						"parameters": {
							"conditions": {
								"options": {
									"caseSensitive": true,
									"leftValue": "",
									"typeValidation": "strict"
								},
								"conditions": [
									{
										"id": "1fff886f-3d13-4fbf-b0fb-7e2f845937c0",
										"leftValue": "={{ false }}",
										"rightValue": "",
										"operator": {
											"type": "boolean",
											"operation": "true",
											"singleValue": true
										}
									}
								],
								"combinator": "and"
							},
							"options": {}
						},
						"id": "56dd65f0-d67a-42ce-a876-77434f621dc3",
						"name": "Impossible if",
						"type": "n8n-nodes-base.if",
						"typeVersion": 2,
						"position": [1000, 2000]
					},
					"data": {
						"main": [
							[
								{
									"json": {},
									"pairedItem": {
										"item": 0
									}
								}
							]
						]
					},
					"source": {
						"main": [
							{
								"previousNode": "When clicking ‘Execute workflow’"
							}
						]
					}
				},
				{
					"node": {
						"parameters": {
							"mode": "manual",
							"duplicateItem": false,
							"fields": {
								"values": [
									{
										"name": "",
										"type": "stringValue",
										"stringValue": "={{ $('non existent') }}"
									}
								]
							},
							"include": "all",
							"options": {}
						},
						"id": "327d7f7b-61a5-4d60-9542-d61f84e7c83a",
						"name": "Reference non-existent node",
						"type": "n8n-nodes-base.set",
						"typeVersion": 3.2,
						"position": [1000, 2320]
					},
					"data": {
						"main": [
							[
								{
									"json": {},
									"pairedItem": {
										"item": 0
									}
								}
							]
						]
					},
					"source": {
						"main": [
							{
								"previousNode": "When clicking ‘Execute workflow’"
							}
						]
					}
				}
			],
			"metadata": {},
			"waitingExecution": {},
			"waitingExecutionSource": {}
		}
	},
	"mode": "manual",
	"startedAt": "2024-02-09T09:42:23.598Z",
	"stoppedAt": "2024-02-09T09:42:23.663Z",
	"status": "running"
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/errors_workflow.json
================================================
{
	"name": "WorkflowDataProxy errors",
	"nodes": [
		{
			"parameters": {},
			"id": "b5122d27-4bb5-4100-a69b-03b1dcac76c7",
			"name": "When clicking ‘Execute workflow’",
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1,
			"position": [740, 1680]
		},
		{
			"parameters": {
				"operation": "getAllPeople"
			},
			"id": "bf471582-900d-47af-848c-2d4218798775",
			"name": "Customer Datastore (n8n training)",
			"type": "n8n-nodes-base.n8nTrainingCustomerDatastore",
			"typeVersion": 1,
			"position": [1180, 1680]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"name": "name",
							"stringValue": "={{ $json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "1de94b04-c87b-4ef1-b5d7-5078f9e33220",
			"name": "Edit Fields",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1400, 1680]
		},
		{
			"parameters": {
				"content": "These expression should always be red — there is no way of getting the input data even if you execute. Text should be:",
				"height": 349.2762683040461,
				"width": 339
			},
			"id": "c277f7c6-8a7a-41e9-9484-78e90bd205bf",
			"name": "Sticky Note",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [1020, 1040]
		},
		{
			"parameters": {
				"fieldsToAggregate": {
					"fieldToAggregate": [
						{
							"fieldToAggregate": "name"
						}
					]
				},
				"options": {}
			},
			"id": "f6606ff5-4d66-4efb-8dad-de7662f20867",
			"name": "Aggregate",
			"type": "n8n-nodes-base.aggregate",
			"typeVersion": 1,
			"position": [1820, 860]
		},
		{
			"parameters": {
				"content": "This error should be\n\n[Can't determine which item to use]",
				"height": 255,
				"width": 177
			},
			"id": "71fbae4a-f5b3-4db1-9684-83c4d2037099",
			"name": "Sticky Note1",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 760]
		},
		{
			"parameters": {
				"content": "[No path back to node]",
				"height": 209,
				"width": 150
			},
			"id": "24e878cb-a681-4c00-bec1-83188aa20eb7",
			"name": "Sticky Note2",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [1020, 1132]
		},
		{
			"parameters": {
				"content": "[No input connected]",
				"height": 201,
				"width": 150
			},
			"id": "4bd26f55-87b5-4ad1-b3f1-ae2786941114",
			"name": "Sticky Note3",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [1200, 1132]
		},
		{
			"parameters": {
				"jsCode": "\nreturn [\n  {\n    \"field\": \"the same\"\n  }\n];"
			},
			"id": "6538818e-c5b3-422b-920c-d5d52533578b",
			"name": "Break pairedItem chain",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1820, 1120]
		},
		{
			"parameters": {
				"content": "This error should be\n\n[Can't determine which item to use]",
				"height": 255,
				"width": 177
			},
			"id": "42641e54-60e1-46d7-bcb4-b55a83f89f6b",
			"name": "Sticky Note4",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 1020]
		},
		{
			"parameters": {
				"jsCode": "\nreturn [\n  {\n    \"json\": {\n      \"field\": \"the same\"\n    },\n    \"pairedItem\": 99\n  }\n];"
			},
			"id": "05583883-ab4a-42c2-9edb-8e8cf3c9d074",
			"name": "Incorrect pairedItem info",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1820, 1680]
		},
		{
			"parameters": {
				"content": "This error should be\n\n[Can't determine which item to use]",
				"height": 255,
				"width": 177
			},
			"id": "aea58e9e-5a00-4a86-a0bc-b077a07cd1f4",
			"name": "Sticky Note5",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 1580]
		},
		{
			"parameters": {
				"content": "If the pinned node is executed, make grey and use text:\n[For preview, unpin node ‘<node_name>’ and execute]",
				"height": 255,
				"width": 237.63786881219818
			},
			"id": "3fdf6bdc-8065-421b-9ecf-6453946356a4",
			"name": "Sticky Note6",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 1840]
		},
		{
			"parameters": {
				"jsCode": "\nreturn [\n  {\n    \"json\": {\n      \"field\": \"the same\"\n    },\n    \"pairedItem\": [1, 2, 3, 4]\n  }\n];"
			},
			"id": "f8de7b0a-79c1-4b7a-a183-feb94f2f8625",
			"name": "Multiple matching items",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1820, 2200]
		},
		{
			"parameters": {
				"content": "This error should be\n\n[Can't determine which item to use]",
				"height": 255,
				"width": 177
			},
			"id": "601c050a-7909-4708-be8d-4de248b68392",
			"name": "Sticky Note7",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 2100]
		},
		{
			"parameters": {
				"content": "This should be grey, with text\n\n[For preview, unpin node ‘<node_name>’ and execute]",
				"height": 291.70186796527776,
				"width": 177
			},
			"id": "dfdcfaf4-a76b-4307-97a6-3fd7772e9fa8",
			"name": "Sticky Note8",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 2360]
		},
		{
			"parameters": {
				"jsCode": "\nreturn [\n  {\n    \"json\": {\n      \"field\": \"the same\"\n    },\n    \"pairedItem\": [1, 2, 3, 4]\n  }\n];"
			},
			"id": "8f2a9642-68e7-4dc6-a6c2-2018919327a3",
			"name": "Multiple matching items, pinned",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1820, 2500]
		},
		{
			"parameters": {
				"content": "If the pinned node isn't executed (e.g. if you execute one of the other code nodes in the same column), the expression is green!",
				"height": 128.93706220621976,
				"width": 177
			},
			"id": "65cf9b4c-a96d-46f5-b9bb-f6d88d1fbc44",
			"name": "Sticky Note9",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2220, 1940]
		},
		{
			"parameters": {
				"jsCode": "\nreturn [\n  {\n    \"json\": {\n      \"field\": \"the same\"\n    },\n    \"pairedItem\": 99\n  }\n];"
			},
			"id": "0bdfe0d2-7de2-472d-bc0a-2d0eff0e08c7",
			"name": "Incorrect pairedItem info, pinned1",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1820, 1940]
		},
		{
			"parameters": {
				"jsCode": "\nreturn [\n  {\n    \"field\": \"the same\"\n  }\n];"
			},
			"id": "b080a98e-d983-414a-b925-bdfc7ab2c3b6",
			"name": "Break pairedItem chain, pinned",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1820, 1420]
		},
		{
			"parameters": {
				"content": "This should be grey, with text\n\n[For preview, unpin node ‘<node_name>’ and execute]",
				"height": 291.70186796527776,
				"width": 177
			},
			"id": "ce083193-1944-4c6c-925d-9e23c5194d98",
			"name": "Sticky Note11",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [2000, 1280]
		},
		{
			"parameters": {
				"content": "We should also change the output pane error on execution in this case.\n\nERROR: No path back to '<node_name>' node\nDescription: Please make sure it is connected to this node (there can be other nodes in between)",
				"height": 209,
				"width": 301.59467203049536
			},
			"id": "755e07f0-3f18-4b08-ad30-79221a76507a",
			"name": "Sticky Note10",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [1080, 1360]
		},
		{
			"parameters": {
				"conditions": {
					"options": {
						"caseSensitive": true,
						"leftValue": "",
						"typeValidation": "strict"
					},
					"conditions": [
						{
							"id": "1fff886f-3d13-4fbf-b0fb-7e2f845937c0",
							"leftValue": "={{ false }}",
							"rightValue": "",
							"operator": {
								"type": "boolean",
								"operation": "true",
								"singleValue": true
							}
						}
					],
					"combinator": "and"
				},
				"options": {}
			},
			"id": "56dd65f0-d67a-42ce-a876-77434f621dc3",
			"name": "Impossible if",
			"type": "n8n-nodes-base.if",
			"typeVersion": 2,
			"position": [1000, 2000]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"name": "test",
							"stringValue": "xzy"
						}
					]
				},
				"options": {}
			},
			"id": "11eadfc8-d14d-407c-b6d5-6e59b2e427a1",
			"name": "Impossible",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1180, 1980]
		},
		{
			"parameters": {
				"content": "Should be an error when using .item:\n\n[No path back to node]",
				"height": 237.7232010163043,
				"width": 150
			},
			"id": "c3a3fdc2-66fa-4562-a359-45bdece2f625",
			"name": "Sticky Note12",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [1400, 1880]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"name": "name",
							"stringValue": "={{ $('Impossible').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "4cbbee96-dd4c-4625-95b9-c68faef3e9a8",
			"name": "Reference impossible with .item",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1420, 2000]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"name": "name",
							"stringValue": "={{ $('Impossible').first().json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "6d47bd08-810a-4ade-be57-635adc1df47f",
			"name": "Reference impossible with .first()",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1420, 2320]
		},
		{
			"parameters": {
				"content": "When using .first(), .last() or .all() and the node isn't executed, show grey warning:\n\n[Execute ‘<node_name>’ for preview]",
				"height": 330.27573762439613,
				"width": 229.78666948973432
			},
			"id": "1fcf2562-0789-41ad-8c92-44bcdd5d44e6",
			"name": "Sticky Note13",
			"type": "n8n-nodes-base.stickyNote",
			"typeVersion": 1,
			"position": [1400, 2180]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('non existent') }}"
						}
					]
				},
				"options": {}
			},
			"id": "327d7f7b-61a5-4d60-9542-d61f84e7c83a",
			"name": "Reference non-existent node",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1000, 2320]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Customer Datastore (n8n training)').item.json.email }}"
						}
					]
				},
				"options": {}
			},
			"id": "38e3a736-4e13-4c23-af16-e50e605c4fb5",
			"name": "NoPathBack",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1040, 1184]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $json.email }}"
						}
					]
				},
				"options": {}
			},
			"id": "2a7eaf81-6d64-488d-baf6-cc2f962908af",
			"name": "NoInputConnection",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [1220, 1180]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "166ee813-1db8-43a6-ace4-990c41dfeaea",
			"name": "PairedItemInfoMissing",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 1120]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "a2dca54c-03ef-4a16-bf29-71eb0012cf0b",
			"name": "PairedItemInfoMissingPinned",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 1420]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "0a1f566b-8dcf-4e28-81c4-faeadcdc02fb",
			"name": "IncorrectPairedItem",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 1680]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.to }}"
						}
					]
				},
				"options": {}
			},
			"id": "4d76b75f-5896-48ba-bb2f-8a2574ec1b8b",
			"name": "IncorrectPairedItemPinned",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 1940]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "c4636b5c-c13a-441b-a59c-23962b2757b3",
			"name": "PairedItemMultipleMatches2",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 2200]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "6d687cf8-5309-4d44-aab3-aa023a42fa27",
			"name": "PairedItemMultipleMatches",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 860]
		},
		{
			"parameters": {
				"fields": {
					"values": [
						{
							"stringValue": "={{ $('Edit Fields').item.json.name }}"
						}
					]
				},
				"options": {}
			},
			"id": "d87a7aa4-b4c7-4fad-897d-a7ce0657bef3",
			"name": "IncorrectPairedItemPinned2",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.2,
			"position": [2040, 2500]
		}
	],
	"pinData": {
		"Multiple matching items, pinned": [
			{
				"json": {
					"field": "the same"
				}
			}
		],
		"Incorrect pairedItem info, pinned1": [
			{
				"json": {
					"field": "the same"
				}
			}
		],
		"Break pairedItem chain, pinned": [
			{
				"json": {
					"field": "the same"
				}
			}
		]
	},
	"connections": {
		"When clicking ‘Execute workflow’": {
			"main": [
				[
					{
						"node": "Customer Datastore (n8n training)",
						"type": "main",
						"index": 0
					},
					{
						"node": "Impossible if",
						"type": "main",
						"index": 0
					},
					{
						"node": "Reference non-existent node",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Customer Datastore (n8n training)": {
			"main": [
				[
					{
						"node": "Edit Fields",
						"type": "main",
						"index": 0
					},
					{
						"node": "Reference impossible with .item",
						"type": "main",
						"index": 0
					},
					{
						"node": "Reference impossible with .first()",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Edit Fields": {
			"main": [
				[
					{
						"node": "Aggregate",
						"type": "main",
						"index": 0
					},
					{
						"node": "Break pairedItem chain",
						"type": "main",
						"index": 0
					},
					{
						"node": "Incorrect pairedItem info",
						"type": "main",
						"index": 0
					},
					{
						"node": "Multiple matching items",
						"type": "main",
						"index": 0
					},
					{
						"node": "Incorrect pairedItem info, pinned1",
						"type": "main",
						"index": 0
					},
					{
						"node": "Multiple matching items, pinned",
						"type": "main",
						"index": 0
					},
					{
						"node": "Break pairedItem chain, pinned",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Aggregate": {
			"main": [
				[
					{
						"node": "PairedItemMultipleMatches",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Break pairedItem chain": {
			"main": [
				[
					{
						"node": "PairedItemInfoMissing",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Incorrect pairedItem info": {
			"main": [
				[
					{
						"node": "IncorrectPairedItem",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Multiple matching items": {
			"main": [
				[
					{
						"node": "PairedItemMultipleMatches2",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Multiple matching items, pinned": {
			"main": [
				[
					{
						"node": "IncorrectPairedItemPinned2",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Incorrect pairedItem info, pinned1": {
			"main": [
				[
					{
						"node": "IncorrectPairedItemPinned",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Break pairedItem chain, pinned": {
			"main": [
				[
					{
						"node": "PairedItemInfoMissingPinned",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Impossible if": {
			"main": [
				[
					{
						"node": "Impossible",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	},
	"active": false,
	"settings": {
		"executionOrder": "v1"
	},
	"versionId": "f6276c80-c1d1-485b-9d07-894868bcd701",
	"meta": {
		"templateCredsSetupCompleted": true,
		"instanceId": "2e88d456a76a9edc44cbcda082bb44ddef9555356ef691b0c6a45099d5095a45"
	},
	"id": "BmXv9neCtTggKXuG",
	"tags": []
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/from_ai_multiple_items_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"When clicking ‘Execute workflow’": [
					{
						"hints": [],
						"startTime": 1733478795595,
						"executionTime": 0,
						"source": [],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {},
										"pairedItem": {
											"item": 0
										}
									}
								]
							]
						}
					}
				],
				"Code": [
					{
						"hints": [
							{
								"message": "To make sure expressions after this node work, return the input items that produced each output item. <a target=\"_blank\" href=\"https://docs.n8n.io/data/data-mapping/data-item-linking/item-linking-code-node/\">More info</a>",
								"location": "outputPane"
							}
						],
						"startTime": 1733478795595,
						"executionTime": 2,
						"source": [
							{
								"previousNode": "When clicking ‘Execute workflow’"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"full_name": "Mr. Input 1",
											"email": "input1@n8n.io"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"full_name": "Mr. Input 2",
											"email": "input2@n8n.io"
										},
										"pairedItem": {
											"item": 0
										}
									}
								]
							]
						}
					}
				],
				"Google Sheets1": [
					{
						"startTime": 1733478796468,
						"executionTime": 1417,
						"executionStatus": "success",
						"source": [null],
						"data": {
							"ai_tool": [
								[
									{
										"json": {
											"response": [
												{
													"full name": "Mr. Input 1",
													"email": "input1@n8n.io"
												},
												{},
												{}
											]
										}
									}
								]
							]
						},
						"inputOverride": {
							"ai_tool": [
								[
									{
										"json": {
											"full_name": "Mr. Input 1",
											"email": "input1@n8n.io"
										}
									}
								]
							]
						},
						"metadata": {
							"subRun": [
								{
									"node": "Google Sheets1",
									"runIndex": 0
								},
								{
									"node": "Google Sheets1",
									"runIndex": 1
								}
							]
						}
					},
					{
						"startTime": 1733478799915,
						"executionTime": 1271,
						"executionStatus": "success",
						"source": [null],
						"data": {
							"ai_tool": [
								[
									{
										"json": {
											"response": [
												{
													"full name": "Mr. Input 1",
													"email": "input1@n8n.io"
												},
												{},
												{}
											]
										}
									}
								]
							]
						},
						"inputOverride": {
							"ai_tool": [
								[
									{
										"json": {
											"full_name": "Mr. Input 2",
											"email": "input2@n8n.io"
										}
									}
								]
							]
						}
					}
				],
				"Agent single list with multiple tool calls": [
					{
						"hints": [],
						"startTime": 1733478795597,
						"executionTime": 9157,
						"source": [
							{
								"previousNode": "Code"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"output": "The user \"Mr. Input 1\" with the email \"input1@n8n.io\" has been successfully added to your Users sheet."
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"output": "The user \"Mr. Input 2\" with the email \"input2@n8n.io\" has been successfully added to your Users sheet."
										},
										"pairedItem": {
											"item": 1
										}
									}
								]
							]
						}
					}
				]
			},
			"pinData": {},
			"lastNodeExecuted": "Agent single list with multiple tool calls"
		},
		"executionData": {
			"contextData": {},
			"nodeExecutionStack": [],
			"metadata": {
				"Google Sheets1": [
					{
						"subRun": [
							{
								"node": "Google Sheets1",
								"runIndex": 0
							},
							{
								"node": "Google Sheets1",
								"runIndex": 1
							}
						]
					}
				]
			},
			"waitingExecution": {},
			"waitingExecutionSource": {}
		}
	},
	"mode": "manual",
	"startedAt": "2024-02-08T15:45:18.848Z",
	"stoppedAt": "2024-02-08T15:45:18.862Z",
	"status": "running"
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/from_ai_multiple_items_workflow.json
================================================
{
	"id": "8d7lUG8IdEyvIUim",
	"name": "Multiple items tool",
	"active": false,
	"nodes": [
		{
			"parameters": {
				"mode": "runOnceForAllItems",
				"language": "javaScript",
				"jsCode": "return [\n  { \"full_name\": \"Mr. Input 1\", \"email\": \"input1@n8n.io\" }, \n  { \"full_name\": \"Mr. Input 2\", \"email\": \"input2@n8n.io\" }\n]",
				"notice": ""
			},
			"id": "cb19a188-12ae-4d46-86df-4a2044ec3346",
			"name": "Code",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [-160, 480]
		},
		{
			"parameters": { "notice": "", "model": "gpt-4o-mini", "options": {} },
			"id": "c448b6b4-9e11-4044-96e5-f4138534ae52",
			"name": "OpenAI Chat Model1",
			"type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
			"typeVersion": 1,
			"position": [40, 700]
		},
		{
			"parameters": {
				"descriptionType": "manual",
				"toolDescription": "Add row to Users sheet",
				"authentication": "oAuth2",
				"resource": "sheet",
				"operation": "append",
				"columns": {
					"mappingMode": "defineBelow",
					"value": {
						"full name": "={{ $fromAI('full_name') }}",
						"email": "={{ $fromAI('email') }}"
					},
					"matchingColumns": [],
					"schema": [
						{
							"id": "full name",
							"displayName": "full name",
							"required": false,
							"defaultMatch": false,
							"display": true,
							"type": "string",
							"canBeUsedToMatch": true
						},
						{
							"id": "email",
							"displayName": "email",
							"required": false,
							"defaultMatch": false,
							"display": true,
							"type": "string",
							"canBeUsedToMatch": true
						}
					]
				},
				"options": { "useAppend": true }
			},
			"id": "d8b40267-9397-45b6-8a64-ee7e8f9eb8a8",
			"name": "Google Sheets1",
			"type": "n8n-nodes-base.googleSheetsTool",
			"typeVersion": 4.5,
			"position": [240, 700]
		},
		{
			"parameters": {
				"aiAgentStarterCallout": "",
				"agent": "toolsAgent",
				"promptType": "define",
				"text": "=Add this user to my Users sheet:\n{{ $json.toJsonString() }}",
				"hasOutputParser": false,
				"options": {},
				"credentials": ""
			},
			"id": "0d6c1bd7-cc91-4571-8fdb-c875a1af44c7",
			"name": "Agent single list with multiple tool calls",
			"type": "@n8n/n8n-nodes-langchain.agent",
			"typeVersion": 1.7,
			"position": [40, 480]
		}
	],
	"connections": {
		"When clicking ‘Execute workflow’": {
			"main": [[{ "node": "Code", "type": "main", "index": 0 }]]
		},
		"Code": {
			"main": [
				[{ "node": "Agent single list with multiple tool calls", "type": "main", "index": 0 }]
			]
		},
		"OpenAI Chat Model1": {
			"ai_languageModel": [
				[
					{
						"node": "Agent single list with multiple tool calls",
						"type": "ai_languageModel",
						"index": 0
					}
				]
			]
		},
		"Google Sheets1": {
			"ai_tool": [
				[{ "node": "Agent single list with multiple tool calls", "type": "ai_tool", "index": 0 }]
			]
		}
	},
	"pinData": {}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/multiple_inputs_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"Manual Trigger": [
					{
						"startTime": 1749486952181,
						"executionIndex": 0,
						"source": [],
						"hints": [],
						"executionTime": 2,
						"executionStatus": "success",
						"data": { "main": [[{ "json": {}, "pairedItem": { "item": 0 } }]] }
					}
				],
				"Set main variable": [
					{
						"startTime": 1749486952183,
						"executionIndex": 1,
						"source": [{ "previousNode": "Manual Trigger" }],
						"hints": [],
						"executionTime": 2,
						"executionStatus": "success",
						"data": { "main": [[{ "json": { "main_variable": 2 }, "pairedItem": { "item": 0 } }]] }
					}
				],
				"Set variable_1": [
					{
						"startTime": 1749486952185,
						"executionIndex": 2,
						"source": [{ "previousNode": "Set main variable" }],
						"hints": [],
						"executionTime": 0,
						"executionStatus": "success",
						"data": {
							"main": [[{ "json": { "variable_1": "1234" }, "pairedItem": { "item": 0 } }]]
						}
					}
				],
				"Set variable_2": [
					{
						"startTime": 1749486952186,
						"executionIndex": 3,
						"source": [{ "previousNode": "Set main variable" }],
						"hints": [],
						"executionTime": 0,
						"executionStatus": "success",
						"data": {
							"main": [[{ "json": { "variable_2": "2345" }, "pairedItem": { "item": 0 } }]]
						}
					}
				],
				"Set variable_3": [
					{
						"startTime": 1749486952187,
						"executionIndex": 4,
						"source": [{ "previousNode": "Set main variable" }],
						"hints": [],
						"executionTime": 0,
						"executionStatus": "success",
						"data": {
							"main": [[{ "json": { "variable_3": "3456" }, "pairedItem": { "item": 0 } }]]
						}
					}
				],
				"Merge": [
					{
						"startTime": 1749486952197,
						"executionIndex": 5,
						"source": [null, null, { "previousNode": "Set variable_3" }],
						"hints": [],
						"executionTime": 12,
						"executionStatus": "success",
						"data": {
							"main": [
								[{ "json": { "variable_3": "3456" }, "pairedItem": { "item": 0, "input": 2 } }]
							]
						}
					}
				],
				"Output": [
					{
						"startTime": 1749486952210,
						"executionIndex": 6,
						"source": [{ "previousNode": "Merge" }],
						"hints": [],
						"executionTime": 4,
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": { "final_variable_2": "3456", "main": "2" },
										"pairedItem": { "item": 0 }
									}
								]
							]
						}
					}
				]
			},
			"pinData": {},
			"lastNodeExecuted": "Output"
		},
		"executionData": {
			"contextData": {},
			"nodeExecutionStack": [],
			"metadata": {},
			"waitingExecution": {},
			"waitingExecutionSource": {}
		}
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/multiple_inputs_workflow.json
================================================
{
	"name": "Paired item",
	"nodes": [
		{
			"parameters": {
				"numberInputs": 3
			},
			"type": "n8n-nodes-base.merge",
			"typeVersion": 3.1,
			"position": [560, 300],
			"id": "2b68168b-1494-4c4b-b416-b4fb6bb0afd8",
			"name": "Merge",
			"alwaysOutputData": true
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "63830a30-a4cc-4a66-9d01-8f0a058d4d43",
							"name": "variable_1",
							"value": "1234",
							"type": "string"
						}
					]
				},
				"options": {}
			},
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [200, 100],
			"id": "a1d151cc-8f44-43c6-962f-baecb879d33c",
			"name": "Set variable_1"
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "63830a30-a4cc-4a66-9d01-8f0a058d4d43",
							"name": "variable_2",
							"value": "2345",
							"type": "string"
						}
					]
				},
				"options": {}
			},
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [200, 300],
			"id": "404ff876-b524-4873-8dc0-36664639907a",
			"name": "Set variable_2"
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "63830a30-a4cc-4a66-9d01-8f0a058d4d43",
							"name": "variable_3",
							"value": "3456",
							"type": "string"
						}
					]
				},
				"options": {}
			},
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [200, 500],
			"id": "d403e979-7651-4acf-8e08-1d342b7abe7f",
			"name": "Set variable_3"
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "89862e7d-0c44-4d6a-897e-a249c06f6346",
							"name": "final_variable_2",
							"value": "={{ $('Set variable_3').item.json.variable_3 }}",
							"type": "string"
						},
						{
							"id": "060e841c-c236-41ae-9396-e23566825f47",
							"name": "main",
							"value": "={{ $('Set main variable').item.json.main_variable }}",
							"type": "string"
						}
					]
				},
				"options": {}
			},
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [840, 300],
			"id": "16514f79-e309-465c-b571-7d81e268d7f0",
			"name": "Output"
		},
		{
			"parameters": {},
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1,
			"position": [-240, 300],
			"id": "3a8a9543-567c-443c-8742-fa0a8d9fb2e7",
			"name": "Manual Trigger"
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "6bb9d060-adee-429f-884d-5009ab1a1811",
							"name": "main_variable",
							"value": 2,
							"type": "number"
						}
					]
				},
				"options": {}
			},
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [-20, 300],
			"id": "b6ec9c0f-de04-45d3-a402-3969251a6914",
			"name": "Set main variable"
		}
	],
	"pinData": {},
	"connections": {
		"Merge": {
			"main": [
				[
					{
						"node": "Output",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Set variable_1": {
			"main": [[]]
		},
		"Set variable_2": {
			"main": [[]]
		},
		"Set variable_3": {
			"main": [
				[
					{
						"node": "Merge",
						"type": "main",
						"index": 2
					}
				]
			]
		},
		"Manual Trigger": {
			"main": [
				[
					{
						"node": "Set main variable",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Set main variable": {
			"main": [
				[
					{
						"node": "Set variable_2",
						"type": "main",
						"index": 0
					},
					{
						"node": "Set variable_1",
						"type": "main",
						"index": 0
					},
					{
						"node": "Set variable_3",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	},
	"active": false,
	"settings": {
		"executionOrder": "v1"
	},
	"versionId": "5678abcc-b267-4b5b-ba1b-5f7bb1b085ec",
	"meta": {
		"instanceId": "27cc9b56542ad45b38725555722c50a1c3fee1670bbb67980558314ee08517c4"
	},
	"id": "TakJu1jBtMGTFXEA",
	"tags": []
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/multiple_outputs_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"When clicking ‘Execute workflow’": [
					{
						"hints": [],
						"startTime": 1718369813697,
						"executionTime": 0,
						"source": [],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"name": "First item",
											"code": 1
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"name": "Second item",
											"code": 2
										},
										"pairedItem": {
											"item": 0
										}
									}
								]
							]
						}
					}
				],
				"If": [
					{
						"hints": [],
						"startTime": 1718369813698,
						"executionTime": 1,
						"source": [
							{
								"previousNode": "When clicking ‘Execute workflow’"
							}
						],
						"executionStatus": "success",
						"data": {
							"main": [
								[],
								[
									{
										"json": {
											"name": "First item",
											"code": 1
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"name": "Second item",
											"code": 2
										},
										"pairedItem": {
											"item": 1
										}
									}
								]
							]
						}
					}
				]
			}
		}
	},
	"mode": "manual",
	"startedAt": "2024-02-08T15:45:18.848Z",
	"stoppedAt": "2024-02-08T15:45:18.862Z",
	"status": "running"
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/multiple_outputs_workflow.json
================================================
{
	"meta": {
		"instanceId": "060d2be233778dc6349e0f3fa8d972652e8dff467638325ffc56812c6b66ef1a"
	},
	"nodes": [
		{
			"parameters": {},
			"id": "656d6d8d-1af6-4af7-ab53-7c4e495ee51c",
			"name": "When clicking ‘Execute workflow’",
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1,
			"position": [-300, 1880]
		},
		{
			"parameters": {
				"conditions": {
					"options": {
						"caseSensitive": true,
						"leftValue": "",
						"typeValidation": "strict"
					},
					"conditions": [
						{
							"id": "1fff886f-3d13-4fbf-b0fb-7e2f845937c0",
							"leftValue": "={{ false }}",
							"rightValue": "",
							"operator": {
								"type": "boolean",
								"operation": "true",
								"singleValue": true
							}
						}
					],
					"combinator": "and"
				},
				"options": {}
			},
			"id": "204feab7-f5e9-458f-8fdb-4b762b184147",
			"name": "If",
			"type": "n8n-nodes-base.if",
			"typeVersion": 2,
			"position": [40, 1880]
		},
		{
			"parameters": {
				"assignments": {
					"assignments": []
				},
				"options": {}
			},
			"id": "ab122060-f8da-475e-b6c6-d9e486289e1f",
			"name": "Edit Fields",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.3,
			"position": [360, 2080]
		}
	],
	"connections": {
		"When clicking ‘Execute workflow’": {
			"main": [
				[
					{
						"node": "If",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"If": {
			"main": [
				[],
				[
					{
						"node": "Edit Fields",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	},
	"pinData": {}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/partial_data_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"Start": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [
								[
									{
										"json": {}
									}
								]
							]
						},
						"source": []
					}
				],
				"Function": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [[]]
						},
						"source": [
							{
								"previousNode": "Start"
							}
						]
					}
				],
				"Rename": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [[]]
						},
						"source": [
							{
								"previousNode": "Function"
							}
						]
					}
				],
				"End": [
					{
						"startTime": 1,
						"executionTime": 1,
						"data": {
							"main": [[]]
						},
						"source": [
							{
								"previousNode": "Rename"
							}
						]
					}
				]
			}
		}
	},
	"mode": "manual",
	"startedAt": "2024-02-08T15:45:18.848Z",
	"stoppedAt": "2024-02-08T15:45:18.862Z",
	"status": "running"
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/partial_data_workflow.json
================================================
{
	"name": "",
	"nodes": [
		{
			"name": "Start",
			"type": "test.set",
			"parameters": {},
			"typeVersion": 1,
			"id": "uuid-1",
			"position": [100, 200]
		},
		{
			"name": "Function",
			"type": "test.set",
			"parameters": {
				"functionCode": "// Code here will run only once, no matter how many input items there are.\n// More info and help: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.function/\nconst { DateTime, Duration, Interval } = require(\"luxon\");\n\nconst data = [\n  {\n  \"length\": 105\n  },\n  {\n  \"length\": 160\n  },\n  {\n  \"length\": 121\n  },\n  {\n  \"length\": 275\n  },\n  {\n  \"length\": 950\n  },\n];\n\nreturn data.map(fact => ({json: fact}));"
			},
			"typeVersion": 1,
			"id": "uuid-2",
			"position": [280, 200]
		},
		{
			"name": "Rename",
			"type": "test.set",
			"parameters": {
				"value1": "data",
				"value2": "initialName"
			},
			"typeVersion": 1,
			"id": "uuid-3",
			"position": [460, 200]
		},
		{
			"name": "Set",
			"type": "test.set",
			"parameters": {},
			"typeVersion": 1,
			"id": "uuid-4",
			"position": [640, 200]
		},
		{
			"name": "End",
			"type": "test.set",
			"parameters": {},
			"typeVersion": 1,
			"id": "uuid-5",
			"position": [640, 200]
		}
	],
	"pinData": {},
	"connections": {
		"Start": {
			"main": [
				[
					{
						"node": "Function",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Function": {
			"main": [
				[
					{
						"node": "Rename",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Rename": {
			"main": [
				[
					{
						"node": "End",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/pindata_paireditem_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"When clicking ‘Execute workflow’": [
					{
						"hints": [],
						"startTime": 1737031584297,
						"executionTime": 1,
						"source": [],
						"executionStatus": "success",
						"data": { "main": [[{ "json": {}, "pairedItem": { "item": 0 } }]] }
					}
				],
				"DebugHelper": [
					{
						"hints": [],
						"startTime": 1737031584299,
						"executionTime": 1,
						"source": [{ "previousNode": "When clicking ‘Execute workflow’" }],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"uid": "3c54ac5d-5c75-409d-9975-76ee151e5fc9",
											"email": "Troy.Volkman@gmail.com",
											"firstname": "Betty",
											"lastname": "Wolf",
											"password": "c~837Nv"
										},
										"pairedItem": { "item": 0 }
									},
									{
										"json": {
											"uid": "5b0d9bd7-2ecf-47fb-b484-3eb1e76fa901",
											"email": "Martha.Moore@hotmail.com",
											"firstname": "Shannon",
											"lastname": "Champlin",
											"password": "48FF,6dnx"
										},
										"pairedItem": { "item": 0 }
									},
									{
										"json": {
											"uid": "76437ebe-d406-447a-ab89-3b10f5183480",
											"email": "Wanda_Witting@hotmail.com",
											"firstname": "Alma",
											"lastname": "Conn",
											"password": "6$G2R3nT"
										},
										"pairedItem": { "item": 0 }
									}
								]
							]
						}
					}
				],
				"Edit Fields": [
					{
						"hints": [],
						"startTime": 1737031584301,
						"executionTime": 0,
						"source": [{ "previousNode": "DebugHelper" }],
						"executionStatus": "success",
						"data": {
							"main": [
								[
									{
										"json": {
											"uid": "d42c6385-12f2-4486-92b5-eebd2e95d161",
											"email": "Joanna_Willms@yahoo.com",
											"firstname": "Laurie",
											"lastname": "Krajcik",
											"password": "k%Y2I9oq",
											"test": "1"
										}
									},
									{
										"json": {
											"uid": "53fc09df-5463-4f48-9fda-6500b1b77c82",
											"email": "Elaine_Feeney@gmail.com",
											"firstname": "Tracy",
											"lastname": "Mraz",
											"password": "t48s3-r",
											"test": "1"
										}
									}
								]
							]
						}
					}
				],
				"Set": [
					{
						"hints": [],
						"startTime": 1737031584301,
						"executionTime": 0,
						"source": [{ "previousNode": "Edit Fields" }],
						"data": {
							"main": [
								[
									{
										"json": {
											"uid": "d42c6385-12f2-4486-92b5-eebd2e95d161",
											"email": "Joanna_Willms@yahoo.com",
											"firstname": "Laurie",
											"lastname": "Krajcik",
											"password": "k%Y2I9oq",
											"test": "1"
										},
										"pairedItem": {
											"item": 0
										}
									},
									{
										"json": {
											"uid": "53fc09df-5463-4f48-9fda-6500b1b77c82",
											"email": "Elaine_Feeney@gmail.com",
											"firstname": "Tracy",
											"lastname": "Mraz",
											"password": "t48s3-r",
											"test": "1"
										},
										"pairedItem": {
											"item": 1
										}
									}
								]
							]
						}
					}
				]
			},
			"pinData": {
				"Edit Fields": [
					{
						"json": {
							"uid": "d42c6385-12f2-4486-92b5-eebd2e95d161",
							"email": "Joanna_Willms@yahoo.com",
							"firstname": "Laurie",
							"lastname": "Krajcik",
							"password": "k%Y2I9oq",
							"test": "1"
						}
					},
					{
						"json": {
							"uid": "53fc09df-5463-4f48-9fda-6500b1b77c82",
							"email": "Elaine_Feeney@gmail.com",
							"firstname": "Tracy",
							"lastname": "Mraz",
							"password": "t48s3-r",
							"test": "1"
						}
					}
				]
			},
			"lastNodeExecuted": "Set"
		},
		"executionData": {
			"contextData": {},
			"nodeExecutionStack": [
				{
					"node": {
						"parameters": {
							"mode": "runOnceForAllItems",
							"language": "javaScript",
							"jsCode": "for (let i = 0; i < $input.all().length; i++) {   $(\"DebugHelper\").itemMatching(i) }  return []",
							"notice": ""
						},
						"type": "n8n-nodes-base.code",
						"typeVersion": 2,
						"position": [720, 0],
						"id": "d4e8b6a2-cd73-452d-b5f0-986753f5dc4a",
						"name": "Set"
					},
					"data": {
						"main": [
							[
								{
									"json": {
										"uid": "d42c6385-12f2-4486-92b5-eebd2e95d161",
										"email": "Joanna_Willms@yahoo.com",
										"firstname": "Laurie",
										"lastname": "Krajcik",
										"password": "k%Y2I9oq",
										"test": "1"
									},
									"pairedItem": { "item": 0 }
								},
								{
									"json": {
										"uid": "53fc09df-5463-4f48-9fda-6500b1b77c82",
										"email": "Elaine_Feeney@gmail.com",
										"firstname": "Tracy",
										"lastname": "Mraz",
										"password": "t48s3-r",
										"test": "1"
									},
									"pairedItem": { "item": 1 }
								}
							]
						]
					},
					"source": { "main": [{ "previousNode": "Edit Fields" }] }
				}
			],
			"metadata": {},
			"waitingExecution": {},
			"waitingExecutionSource": {}
		}
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/pindata_paireditem_workflow.json
================================================
{
	"nodes": [
		{
			"parameters": {},
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1,
			"position": [0, 0],
			"id": "df3ea0b2-913b-4736-a3c6-f61b35abd1e1",
			"name": "When clicking ‘Execute workflow’"
		},
		{
			"parameters": {
				"category": "randomData",
				"randomDataCount": 3
			},
			"type": "n8n-nodes-base.debugHelper",
			"typeVersion": 1,
			"position": [280, 0],
			"id": "e31f942c-876a-43ae-b883-0b7566d44750",
			"name": "DebugHelper"
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "049c69e3-969d-4df9-bf93-e44c1da06ba1",
							"name": "test",
							"value": "1",
							"type": "string"
						}
					]
				},
				"includeOtherFields": true,
				"options": {}
			},
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [500, 0],
			"id": "eb20f04e-875f-4a2d-853c-f2e30014b821",
			"name": "Edit Fields"
		},
		{
			"type": "n8n-nodes-base.set",
			"typeVersion": 2,
			"position": [720, 0],
			"id": "d4e8b6a2-cd73-452d-b5f0-986753f5dc4a",
			"name": "Set"
		}
	],
	"connections": {
		"When clicking ‘Execute workflow’": {
			"main": [
				[
					{
						"node": "DebugHelper",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"DebugHelper": {
			"main": [
				[
					{
						"node": "Edit Fields",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Edit Fields": {
			"main": [
				[
					{
						"node": "Set",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	},
	"pinData": {
		"Edit Fields": [
			{
				"uid": "d42c6385-12f2-4486-92b5-eebd2e95d161",
				"email": "Joanna_Willms@yahoo.com",
				"firstname": "Laurie",
				"lastname": "Krajcik",
				"password": "k%Y2I9oq",
				"test": "1"
			},
			{
				"uid": "53fc09df-5463-4f48-9fda-6500b1b77c82",
				"email": "Elaine_Feeney@gmail.com",
				"firstname": "Tracy",
				"lastname": "Mraz",
				"password": "t48s3-r",
				"test": "1"
			}
		]
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/pindata_run.json
================================================
{
	"data": {
		"resultData": {
			"runData": {}
		}
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/pindata_workflow.json
================================================
{
	"meta": {
		"instanceId": "a786b722078489c1fa382391a9f3476c2784761624deb2dfb4634827256d51a0"
	},
	"nodes": [
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "3058c300-b377-41b7-9c90-a01372f9b581",
							"name": "firstName",
							"value": "Joe",
							"type": "string"
						},
						{
							"id": "bb871662-c23c-4234-ac0c-b78c279bbf34",
							"name": "lastName",
							"value": "Smith",
							"type": "string"
						}
					]
				},
				"options": {}
			},
			"id": "baee2bf4-5083-4cbe-8e51-4eddcf859ef5",
			"name": "PinnedSet",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.3,
			"position": [1120, 380]
		},
		{
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "a482f1fd-4815-4da4-a733-7beafb43c500",
							"name": "test",
							"value": "={{ $('PinnedSet').all().json }}\n{{ $('PinnedSet').item.json.firstName }}\n{{ $('PinnedSet').first().json.firstName }}\n{{ $('PinnedSet').itemMatching(0).json.firstName }}\n{{ $('PinnedSet').itemMatching(1).json.firstName }}\n{{ $('PinnedSet').last().json.firstName }}\n{{ $('PinnedSet').all()[0].json.firstName }}\n{{ $('PinnedSet').all()[1].json.firstName }}\n\n{{ $input.first().json.firstName }}\n{{ $input.last().json.firstName }}\n{{ $input.item.json.firstName }}\n\n{{ $json.firstName }}\n{{ $data.firstName }}\n\n{{ $items()[0].json.firstName }}",
							"type": "string"
						}
					]
				},
				"options": {}
			},
			"id": "2a543169-e2c1-4764-ac63-09534310b2b9",
			"name": "NotPinnedSet1",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.3,
			"position": [1360, 380]
		},
		{
			"parameters": {},
			"id": "f36672e5-8c87-480e-a5b8-de9da6b63192",
			"name": "Start",
			"type": "n8n-nodes-base.manualTrigger",
			"position": [920, 380],
			"typeVersion": 1
		}
	],
	"connections": {
		"PinnedSet": {
			"main": [
				[
					{
						"node": "NotPinnedSet1",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Start": {
			"main": [
				[
					{
						"node": "PinnedSet",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	},
	"pinData": {
		"PinnedSet": [
			{
				"firstName": "Joe",
				"lastName": "Smith"
			},
			{
				"firstName": "Joan",
				"lastName": "Summers"
			}
		]
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/rawParameter_run.json
================================================
{
	"data": {
		"startData": {},
		"resultData": {
			"runData": {
				"_custom": {
					"type": "reactive",
					"stateTypeName": "Reactive",
					"value": {
						"Manual trigger": [
							{
								"_custom": {
									"type": "reactive",
									"stateTypeName": "Reactive",
									"value": {
										"hints": [],
										"startTime": 1738314562475,
										"executionTime": 1,
										"source": [],
										"executionStatus": "success",
										"data": { "main": [[{ "json": {}, "pairedItem": { "item": 0 } }]] }
									}
								}
							}
						],
						"Edit Fields": [
							{
								"_custom": {
									"type": "reactive",
									"stateTypeName": "Reactive",
									"value": {
										"hints": [],
										"startTime": 1738314562477,
										"executionTime": 0,
										"source": [{ "previousNode": "Manual trigger" }],
										"executionStatus": "success",
										"data": {
											"main": [[{ "json": { "foo": "test" }, "pairedItem": { "item": 0 } }]]
										}
									}
								}
							}
						],
						"Execute Workflow": [
							{
								"hints": [],
								"startTime": 1738314562478,
								"executionTime": 2,
								"source": [{ "previousNode": "Edit Fields" }],
								"executionStatus": "error",
								"error": {
									"level": "error",
									"tags": { "packageName": "cli" },
									"extra": { "workflowId": "1.2" },
									"message": "Workflow does not exist.",
									"stack": "Error: Workflow does not exist.\n    at getWorkflowData (/Users/miloradfilipovic/workspace/n8n/packages/cli/src/workflow-execute-additional-data.ts:124:10)\n    at Object.executeWorkflow (/Users/miloradfilipovic/workspace/n8n/packages/cli/src/workflow-execute-additional-data.ts:155:4)\n    at ExecuteContext.executeWorkflow (/Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/node-execution-context/base-execute-context.ts:120:18)\n    at ExecuteContext.execute (/Users/miloradfilipovic/workspace/n8n/packages/nodes-base/nodes/ExecuteWorkflow/ExecuteWorkflow/ExecuteWorkflow.node.ts:397:50)\n    at WorkflowExecute.runNode (/Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/workflow-execute.ts:1097:8)\n    at /Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/workflow-execute.ts:1503:27\n    at /Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/workflow-execute.ts:2064:11"
								}
							}
						]
					}
				}
			},
			"pinData": {},
			"lastNodeExecuted": "Execute Workflow",
			"error": {
				"level": "error",
				"tags": { "packageName": "cli" },
				"extra": { "workflowId": "1.2" },
				"message": "Workflow does not exist.",
				"stack": "Error: Workflow does not exist.\n    at getWorkflowData (/Users/miloradfilipovic/workspace/n8n/packages/cli/src/workflow-execute-additional-data.ts:124:10)\n    at Object.executeWorkflow (/Users/miloradfilipovic/workspace/n8n/packages/cli/src/workflow-execute-additional-data.ts:155:4)\n    at ExecuteContext.executeWorkflow (/Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/node-execution-context/base-execute-context.ts:120:18)\n    at ExecuteContext.execute (/Users/miloradfilipovic/workspace/n8n/packages/nodes-base/nodes/ExecuteWorkflow/ExecuteWorkflow/ExecuteWorkflow.node.ts:397:50)\n    at WorkflowExecute.runNode (/Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/workflow-execute.ts:1097:8)\n    at /Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/workflow-execute.ts:1503:27\n    at /Users/miloradfilipovic/workspace/n8n/packages/core/src/execution-engine/workflow-execute.ts:2064:11"
			}
		},
		"executionData": {
			"contextData": {},
			"nodeExecutionStack": [
				{
					"node": {
						"parameters": {
							"operation": "call_workflow",
							"source": "database",
							"workflowId": {
								"__rl": true,
								"mode": "id",
								"value": "=1.2",
								"cachedResultName": "=1.2"
							},
							"workflowInputs": {
								"mappingMode": "defineBelow",
								"value": {},
								"matchingColumns": [],
								"schema": [],
								"attemptToConvertTypes": false,
								"convertFieldsToString": true
							},
							"mode": "once",
							"options": {}
						},
						"type": "n8n-nodes-base.executeWorkflow",
						"typeVersion": 1.2,
						"position": [120, -100],
						"id": "62717ac7-614d-4e3f-b2ec-1e28688068c4",
						"name": "Execute Workflow"
					},
					"data": { "main": [[{ "json": { "foo": "test" }, "pairedItem": { "item": 0 } }]] },
					"source": { "main": [{ "previousNode": "Edit Fields" }] }
				}
			],
			"metadata": {},
			"waitingExecution": {},
			"waitingExecutionSource": {}
		},
		"mode": "manual",
		"startedAt": "2024-02-08T15:45:18.848Z",
		"stoppedAt": "2024-02-08T15:45:18.862Z",
		"status": "success"
	}
}



================================================
FILE: packages/workflow/test/fixtures/WorkflowDataProxy/rawParameter_workflow.json
================================================
{
	"nodes": [
		{
			"id": "804e5ba7-4b1d-48c2-abfa-a36717a9fa66",
			"name": "Manual trigger",
			"type": "n8n-nodes-base.manualTrigger",
			"typeVersion": 1,
			"position": [-320, -100],
			"parameters": {}
		},
		{
			"id": "f995b1a2-8a49-4f0c-ae0d-8fb4c600cdef",
			"name": "Edit Fields",
			"type": "n8n-nodes-base.set",
			"typeVersion": 3.4,
			"position": [-100, -100],
			"parameters": {
				"assignments": {
					"assignments": [
						{
							"id": "f4d80089-a3d7-470f-8c07-dec07e37f339",
							"name": "foo",
							"value": "={{ test }}",
							"type": "string"
						}
					]
				},
				"options": {}
			}
		},
		{
			"id": "62717ac7-614d-4e3f-b2ec-1e28688068c4",
			"name": "Execute Workflow",
			"type": "n8n-nodes-base.executeWorkflow",
			"typeVersion": 1.2,
			"position": [120, -100],
			"parameters": {
				"workflowId": {
					"__rl": true,
					"value": "={{ $json.foo }}",
					"mode": "id"
				},
				"workflowInputs": {
					"mappingMode": "defineBelow",
					"value": {},
					"matchingColumns": [],
					"schema": [],
					"attemptToConvertTypes": false,
					"convertFieldsToString": true
				},
				"options": { "waitForSubWorkflow": "={{ true }}" }
			}
		}
	],
	"connections": {
		"Manual trigger": {
			"main": [
				[
					{
						"node": "Edit Fields",
						"type": "main",
						"index": 0
					}
				]
			]
		},
		"Edit Fields": {
			"main": [
				[
					{
						"node": "Execute Workflow",
						"type": "main",
						"index": 0
					}
				]
			]
		}
	},
	"pinData": {}
}



================================================
FILE: packages/workflow/test/graph/graph-utils.test.ts
================================================
import {
	getInputEdges,
	getOutputEdges,
	getRootNodes,
	getLeafNodes,
	parseExtractableSubgraphSelection,
	hasPath,
	buildAdjacencyList,
} from '../../src/graph/graph-utils';
import type { IConnection, IConnections, NodeConnectionType } from '../../src/index';

function makeConnection(
	node: string,
	index: number = 0,
	type: NodeConnectionType = 'main',
): IConnection {
	return {
		node,
		index,
		type,
	};
}

describe('graphUtils', () => {
	describe('getInputEdges', () => {
		it('should return edges leading into the graph', () => {
			const graphIds = new Set(['B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
			]);

			const result = getInputEdges(graphIds, adjacencyList);
			expect(result).toEqual([['A', makeConnection('B')]]);
		});

		it('should return an empty array if there are no input edges', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set()],
			]);

			const result = getInputEdges(graphIds, adjacencyList);
			expect(result).toEqual([]);
		});
	});

	describe('getOutputEdges', () => {
		it('should return edges leading out of the graph', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set()],
			]);

			const result = getOutputEdges(graphIds, adjacencyList);
			expect(result).toEqual([['B', makeConnection('C')]]);
		});

		it('should return an empty array if there are no output edges', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
			]);

			const result = getOutputEdges(graphIds, adjacencyList);
			expect(result).toEqual([]);
		});
	});

	describe('getRootNodes', () => {
		it('should return root nodes of the graph', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
			]);

			const result = getRootNodes(graphIds, adjacencyList);
			expect(result).toEqual(new Set(['A', 'C']));
		});

		it('should return all nodes if there are no incoming edges', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>();

			const result = getRootNodes(graphIds, adjacencyList);
			expect(result).toEqual(new Set(['A', 'B']));
		});
	});

	describe('getLeafNodes', () => {
		it('should return leaf nodes of the graph', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set()],
			]);

			const result = getLeafNodes(graphIds, adjacencyList);
			expect(result).toEqual(new Set(['C']));
		});

		it('should return all nodes if there are no outgoing edges', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set()],
				['B', new Set()],
			]);

			const result = getLeafNodes(graphIds, adjacencyList);
			expect(result).toEqual(new Set(['A', 'B']));
		});
	});

	describe('parseExtractableSubgraphSelection', () => {
		it('should return successfully for a valid extractable subgraph', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['C', new Set([makeConnection('A')])],
				['A', new Set([makeConnection('B')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: 'A', end: undefined });
		});

		it('should return successfully for multiple edges into single input node', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['X', new Set([makeConnection('A')])],
				['Y', new Set([makeConnection('A')])],
				['A', new Set([makeConnection('B')])],
				['B', new Set()],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: 'A', end: undefined });
		});

		it('should return successfully for multiple edges from single output nodes', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('X'), makeConnection('Y')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: undefined, end: 'B' });
		});

		it('should return errors for input edge to non-root node', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['X', new Set([makeConnection('B')])],
				['A', new Set([makeConnection('B')])],
				['B', new Set()],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual([
				{
					errorCode: 'Input Edge To Non-Root Node',
					node: 'B',
				},
			]);
		});

		it('should return errors for output edge from non-leaf node', () => {
			const graphIds = new Set(['A', 'B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B'), makeConnection('X')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual([
				{
					errorCode: 'Output Edge From Non-Leaf Node',
					node: 'A',
				},
			]);
		});

		it('should return successfully for multiple root nodes with 1 input', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('C')])],
				['B', new Set([makeConnection('C')])],
				['X', new Set([makeConnection('A')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: 'A', end: undefined });
		});

		it('should return an error for multiple root nodes with inputs', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('C')])],
				['B', new Set([makeConnection('C')])],
				['X', new Set([makeConnection('A')])],
				['Y', new Set([makeConnection('B')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual([
				{
					errorCode: 'Multiple Input Nodes',
					nodes: new Set(['A', 'B']),
				},
			]);
		});

		it('should return successfully for multiple leaf nodes with 1 output', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B'), makeConnection('C')])],
				['C', new Set([makeConnection('X')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: undefined, end: 'C' });
		});

		it('should return an error for multiple leaf nodes with outputs', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B'), makeConnection('C')])],
				['B', new Set([makeConnection('X')])],
				['C', new Set([makeConnection('X')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual([
				{
					errorCode: 'Multiple Output Nodes',
					nodes: new Set(['B', 'C']),
				},
			]);
		});

		it('should return an error for a non-continuous selection', () => {
			const graphIds = new Set(['A', 'D']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('D')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual([
				{
					errorCode: 'No Continuous Path From Root To Leaf In Selection',
					start: 'D',
					end: 'A',
				},
			]);
		});

		it('should allow loop with node itself', () => {
			const graphIds = new Set(['A']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('A')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: undefined, end: undefined });
		});
		it('should allow loop with node itself with input and output', () => {
			const graphIds = new Set(['B']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('B'), makeConnection('C')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: 'B', end: 'B' });
		});
		it('should allow loop within selection', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('A')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: undefined, end: undefined });
		});
		it('should allow loop within selection with input', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('A')])],
				['D', new Set([makeConnection('B')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: 'B', end: undefined });
		});
		it('should allow loop within selection with two inputs', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('A')])],
				['D', new Set([makeConnection('B')])],
				['E', new Set([makeConnection('B')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual({ start: 'B', end: undefined });
		});
		it('should not allow loop within selection with inputs to different nodes', () => {
			const graphIds = new Set(['A', 'B', 'C']);
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('A')])],
				['D', new Set([makeConnection('B')])],
				['E', new Set([makeConnection('C')])],
			]);

			const result = parseExtractableSubgraphSelection(graphIds, adjacencyList);
			expect(result).toEqual([
				{ errorCode: 'Input Edge To Non-Root Node', node: 'B' },
				{ errorCode: 'Input Edge To Non-Root Node', node: 'C' },
			]);
		});
	});
	describe('hasPath', () => {
		it('should return true for a direct path between start and end', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
			]);

			const result = hasPath('A', 'C', adjacencyList);
			expect(result).toBe(true);
		});

		it('should return false if there is no path between start and end', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['C', new Set([makeConnection('D')])],
			]);

			const result = hasPath('A', 'D', adjacencyList);
			expect(result).toBe(false);
		});

		it('should return true for a path with multiple intermediate nodes', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('D')])],
			]);

			const result = hasPath('A', 'D', adjacencyList);
			expect(result).toBe(true);
		});

		it('should return false if the start node is not in the adjacency list', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('D')])],
			]);

			const result = hasPath('A', 'D', adjacencyList);
			expect(result).toBe(false);
		});

		it('should return false if the end node is not in the adjacency list', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
			]);

			const result = hasPath('A', 'D', adjacencyList);
			expect(result).toBe(false);
		});

		it('should return true for a cyclic graph where a path exists', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('C')])],
				['C', new Set([makeConnection('A')])],
			]);

			const result = hasPath('A', 'C', adjacencyList);
			expect(result).toBe(true);
		});

		it('should return false for a cyclic graph where no path exists', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('B')])],
				['B', new Set([makeConnection('A')])],
				['C', new Set([makeConnection('D')])],
			]);

			const result = hasPath('A', 'D', adjacencyList);
			expect(result).toBe(false);
		});

		it('should return true for a self-loop', () => {
			const adjacencyList = new Map<string, Set<IConnection>>([
				['A', new Set([makeConnection('A')])],
			]);

			const result = hasPath('A', 'A', adjacencyList);
			expect(result).toBe(true);
		});
	});
	describe('buildAdjacencyList', () => {
		it('should build an adjacency list from connections by source node', () => {
			const connectionsBySourceNode: IConnections = {
				A: {
					main: [
						[
							{ node: 'B', index: 0, type: 'main' },
							{ node: 'C', index: 1, type: 'main' },
						],
					],
				},
				B: {
					main: [[{ node: 'D', index: 0, type: 'main' }]],
				},
			};

			const result = buildAdjacencyList(connectionsBySourceNode);

			expect(result).toEqual(
				new Map<string, Set<IConnection>>([
					['A', new Set([makeConnection('B', 0), makeConnection('C', 1)])],
					['B', new Set([makeConnection('D', 0)])],
				]),
			);
		});

		it('should handle an empty connections object', () => {
			const connectionsBySourceNode = {};

			const result = buildAdjacencyList(connectionsBySourceNode);

			expect(result).toEqual(new Map());
		});

		it('should handle connections with multiple types', () => {
			const connectionsBySourceNode: IConnections = {
				A: {
					main: [[{ node: 'B', index: 0, type: 'main' }]],
					ai_tool: [[{ node: 'C', index: 1, type: 'ai_tool' }]],
				},
			};

			const result = buildAdjacencyList(connectionsBySourceNode);

			expect(result).toEqual(
				new Map<string, Set<IConnection>>([
					['A', new Set([makeConnection('B', 0, 'main'), makeConnection('C', 1, 'ai_tool')])],
				]),
			);
		});

		it('should handle connections with multiple indices', () => {
			const connectionsBySourceNode: IConnections = {
				A: {
					main: [[{ node: 'B', index: 0, type: 'main' }], [{ node: 'C', index: 1, type: 'main' }]],
				},
			};

			const result = buildAdjacencyList(connectionsBySourceNode);

			expect(result).toEqual(
				new Map<string, Set<IConnection>>([
					['A', new Set([makeConnection('B', 0), makeConnection('C', 1)])],
				]),
			);
		});
	});
});



================================================
FILE: packages/workflow/test/node-parameters/parameter-type-validation.test.ts
================================================
import {
	validateNodeParameters,
	assertParamIsString,
	assertParamIsNumber,
	assertParamIsBoolean,
	assertParamIsArray,
	assertParamIsOfAnyTypes,
} from '../../src/node-parameters/parameter-type-validation';
import type { INode } from '../../src/interfaces';

describe('Type assertion functions', () => {
	const mockNode: INode = {
		id: 'test-node-id',
		name: 'TestNode',
		type: 'n8n-nodes-base.testNode',
		typeVersion: 1,
		position: [0, 0],
		parameters: {},
	};

	describe('assertIsNodeParameters', () => {
		it('should pass for valid object with all required parameters', () => {
			const value = {
				name: 'test',
				age: 25,
				active: true,
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
				age: { type: 'number' as const, required: true },
				active: { type: 'boolean' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should pass for valid object with optional parameters present', () => {
			const value = {
				name: 'test',
				description: 'optional description',
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
				description: { type: 'string' as const },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should pass for valid object with optional parameters missing', () => {
			const value = {
				name: 'test',
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
				description: { type: 'string' as const },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should pass for valid array parameters', () => {
			const value = {
				tags: ['tag1', 'tag2'],
				numbers: [1, 2, 3],
				flags: [true, false],
			};

			const parameters = {
				tags: { type: 'string[]' as const, required: true },
				numbers: { type: 'number[]' as const, required: true },
				flags: { type: 'boolean[]' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should pass for valid resource-locator parameter', () => {
			const value = {
				resource: {
					__rl: true,
					mode: 'list',
					value: 'some-value',
				},
			};

			const parameters = {
				resource: { type: 'resource-locator' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should pass for valid object parameter', () => {
			const value = {
				config: {
					setting1: 'value1',
					setting2: 42,
				},
			};

			const parameters = {
				config: { type: 'object' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should pass for parameter with multiple allowed types', () => {
			const value = {
				multiType: 'string value',
			};

			const parameters = {
				multiType: { type: ['string', 'number'] as Array<'string' | 'number'>, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();

			// Test with number value
			const value2 = {
				multiType: 42,
			};

			expect(() => validateNodeParameters(value2, parameters, mockNode)).not.toThrow();
		});

		it('should throw for null value', () => {
			const parameters = {
				name: { type: 'string' as const, required: true },
			};

			expect(() => validateNodeParameters(null, parameters, mockNode)).toThrow(
				'Value is not a valid object',
			);
		});

		it('should throw for non-object value', () => {
			const parameters = {
				name: { type: 'string' as const, required: true },
			};

			expect(() => validateNodeParameters('not an object', parameters, mockNode)).toThrow(
				'Value is not a valid object',
			);
			expect(() => validateNodeParameters(123, parameters, mockNode)).toThrow(
				'Value is not a valid object',
			);
			expect(() => validateNodeParameters(true, parameters, mockNode)).toThrow(
				'Value is not a valid object',
			);
		});

		it('should throw for missing required parameter', () => {
			const value = {
				// name is missing
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Required parameter "name" is missing',
			);
		});

		it('should throw for parameter with wrong type', () => {
			const value = {
				name: 123, // should be string
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "name" does not match any of the expected types: string',
			);
		});

		it('should throw for invalid array parameter', () => {
			const value = {
				tags: 'not an array',
			};

			const parameters = {
				tags: { type: 'string[]' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "tags" does not match any of the expected types: string[]',
			);
		});

		it('should throw for array with wrong element type', () => {
			const value = {
				tags: ['valid', 123, 'also valid'], // 123 is not a string
			};

			const parameters = {
				tags: { type: 'string[]' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "tags" does not match any of the expected types: string[]',
			);
		});

		it('should throw for invalid resource-locator parameter', () => {
			const value = {
				resource: {
					// missing required properties
					mode: 'list',
				},
			};

			const parameters = {
				resource: { type: 'resource-locator' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "resource" does not match any of the expected types: resource-locator',
			);
		});

		it('should throw for invalid object parameter', () => {
			const value = {
				config: 'not an object',
			};

			const parameters = {
				config: { type: 'object' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "config" does not match any of the expected types: object',
			);
		});

		it('should throw for parameter that matches none of the allowed types', () => {
			const value = {
				multiType: true, // should be string or number
			};

			const parameters = {
				multiType: { type: ['string', 'number'] as Array<'string' | 'number'>, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "multiType" does not match any of the expected types: string or number',
			);
		});

		it('should handle empty parameter definition', () => {
			const value = {
				extra: 'should be ignored',
			};

			const parameters = {};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should handle complex nested scenarios', () => {
			const value = {
				name: 'test',
				tags: ['tag1', 'tag2'],
				config: {
					enabled: true,
					timeout: 5000,
				},
				resource: {
					__rl: true,
					mode: 'id',
					value: '12345',
				},
				optionalField: undefined,
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
				tags: { type: 'string[]' as const, required: true },
				config: { type: 'object' as const, required: true },
				resource: { type: 'resource-locator' as const, required: true },
				optionalField: { type: 'string' as const },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should handle empty arrays', () => {
			const value = {
				emptyTags: [],
			};

			const parameters = {
				emptyTags: { type: 'string[]' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});

		it('should handle null values for optional parameters', () => {
			const value = {
				name: 'test',
				optionalField: null,
			};

			const parameters = {
				name: { type: 'string' as const, required: true },
				optionalField: { type: 'string' as const },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
				'Parameter "optionalField" does not match any of the expected types: string',
			);
		});

		it('should handle resource-locator with additional properties', () => {
			const value = {
				resource: {
					__rl: true,
					mode: 'list',
					value: 'some-value',
					extraProperty: 'ignored',
				},
			};

			const parameters = {
				resource: { type: 'resource-locator' as const, required: true },
			};

			expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
		});
	});

	describe('assertParamIsBoolean', () => {
		it('should pass for valid boolean values', () => {
			expect(() => assertParamIsBoolean('testParam', true, mockNode)).not.toThrow();
			expect(() => assertParamIsBoolean('testParam', false, mockNode)).not.toThrow();
		});

		it('should throw for non-boolean values', () => {
			expect(() => assertParamIsBoolean('testParam', 'true', mockNode)).toThrow(
				'Parameter "testParam" is not boolean',
			);
			expect(() => assertParamIsBoolean('testParam', 1, mockNode)).toThrow(
				'Parameter "testParam" is not boolean',
			);
			expect(() => assertParamIsBoolean('testParam', 0, mockNode)).toThrow(
				'Parameter "testParam" is not boolean',
			);
			expect(() => assertParamIsBoolean('testParam', null, mockNode)).toThrow(
				'Parameter "testParam" is not boolean',
			);
			expect(() => assertParamIsBoolean('testParam', undefined, mockNode)).toThrow(
				'Parameter "testParam" is not boolean',
			);
		});
	});

	describe('assertIsString', () => {
		it('should pass for valid string', () => {
			expect(() => assertParamIsString('testParam', 'hello', mockNode)).not.toThrow();
		});

		it('should throw for non-string values', () => {
			expect(() => assertParamIsString('testParam', 123, mockNode)).toThrow(
				'Parameter "testParam" is not string',
			);
			expect(() => assertParamIsString('testParam', true, mockNode)).toThrow(
				'Parameter "testParam" is not string',
			);
			expect(() => assertParamIsString('testParam', null, mockNode)).toThrow(
				'Parameter "testParam" is not string',
			);
			expect(() => assertParamIsString('testParam', undefined, mockNode)).toThrow(
				'Parameter "testParam" is not string',
			);
		});
	});

	describe('assertIsNumber', () => {
		it('should pass for valid number', () => {
			expect(() => assertParamIsNumber('testParam', 123, mockNode)).not.toThrow();
			expect(() => assertParamIsNumber('testParam', 0, mockNode)).not.toThrow();
			expect(() => assertParamIsNumber('testParam', -5.5, mockNode)).not.toThrow();
		});

		it('should throw for non-number values', () => {
			expect(() => assertParamIsNumber('testParam', '123', mockNode)).toThrow(
				'Parameter "testParam" is not number',
			);
			expect(() => assertParamIsNumber('testParam', true, mockNode)).toThrow(
				'Parameter "testParam" is not number',
			);
			expect(() => assertParamIsNumber('testParam', null, mockNode)).toThrow(
				'Parameter "testParam" is not number',
			);
			expect(() => assertParamIsNumber('testParam', undefined, mockNode)).toThrow(
				'Parameter "testParam" is not number',
			);
		});
	});

	describe('assertIsArray', () => {
		const isString = (val: unknown): val is string => typeof val === 'string';
		const isNumber = (val: unknown): val is number => typeof val === 'number';

		it('should pass for valid array with correct element types', () => {
			expect(() =>
				assertParamIsArray('testParam', ['a', 'b', 'c'], isString, mockNode),
			).not.toThrow();
			expect(() => assertParamIsArray('testParam', [1, 2, 3], isNumber, mockNode)).not.toThrow();
			expect(() => assertParamIsArray('testParam', [], isString, mockNode)).not.toThrow(); // empty array
		});

		it('should throw for non-array values', () => {
			expect(() => assertParamIsArray('testParam', 'not array', isString, mockNode)).toThrow(
				'Parameter "testParam" is not an array',
			);
			expect(() => assertParamIsArray('testParam', { length: 3 }, isString, mockNode)).toThrow(
				'Parameter "testParam" is not an array',
			);
		});

		it('should throw for array with incorrect element types', () => {
			expect(() => assertParamIsArray('testParam', ['a', 1, 'c'], isString, mockNode)).toThrow(
				'Parameter "testParam" has elements that don\'t match expected types',
			);
			expect(() => assertParamIsArray('testParam', [1, 'b', 3], isNumber, mockNode)).toThrow(
				'Parameter "testParam" has elements that don\'t match expected types',
			);
		});
	});

	describe('assertParamIsOfAnyTypes', () => {
		it('should pass for string value when string is in types array', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', 'hello', ['string'], mockNode),
			).not.toThrow();
		});

		it('should pass for number value when number is in types array', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', 42, ['number'], mockNode)).not.toThrow();
		});

		it('should pass for boolean value when boolean is in types array', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', true, ['boolean'], mockNode)).not.toThrow();
			expect(() =>
				assertParamIsOfAnyTypes('testParam', false, ['boolean'], mockNode),
			).not.toThrow();
		});

		it('should pass for string when multiple types include string', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', 'hello', ['string', 'number'], mockNode),
			).not.toThrow();
		});

		it('should pass for number when multiple types include number', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', 42, ['string', 'number'], mockNode),
			).not.toThrow();
		});

		it('should pass for boolean when multiple types include boolean', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', true, ['string', 'boolean'], mockNode),
			).not.toThrow();
		});

		it('should pass for value matching any of three types', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', 'test', ['string', 'number', 'boolean'], mockNode),
			).not.toThrow();
			expect(() =>
				assertParamIsOfAnyTypes('testParam', 123, ['string', 'number', 'boolean'], mockNode),
			).not.toThrow();
			expect(() =>
				assertParamIsOfAnyTypes('testParam', false, ['string', 'number', 'boolean'], mockNode),
			).not.toThrow();
		});

		it('should throw for string when types array does not include string', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', 'hello', ['number'], mockNode)).toThrow(
				'Parameter "testParam" must be number',
			);
		});

		it('should throw for number when types array does not include number', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', 42, ['string'], mockNode)).toThrow(
				'Parameter "testParam" must be string',
			);
		});

		it('should throw for boolean when types array does not include boolean', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', true, ['string'], mockNode)).toThrow(
				'Parameter "testParam" must be string',
			);
		});

		it('should throw for value that matches none of multiple types', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', 'hello', ['number', 'boolean'], mockNode),
			).toThrow('Parameter "testParam" must be number or boolean');
		});

		it('should throw for null value', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', null, ['string'], mockNode)).toThrow(
				'Parameter "testParam" must be string',
			);
			expect(() =>
				assertParamIsOfAnyTypes('testParam', null, ['string', 'number'], mockNode),
			).toThrow('Parameter "testParam" must be string or number');
		});

		it('should throw for undefined value', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', undefined, ['string'], mockNode)).toThrow(
				'Parameter "testParam" must be string',
			);
			expect(() =>
				assertParamIsOfAnyTypes('testParam', undefined, ['boolean', 'number'], mockNode),
			).toThrow('Parameter "testParam" must be boolean or number');
		});

		it('should throw for object when primitive types are expected', () => {
			expect(() =>
				assertParamIsOfAnyTypes('testParam', {}, ['string', 'number'], mockNode),
			).toThrow('Parameter "testParam" must be string or number');
			expect(() => assertParamIsOfAnyTypes('testParam', [], ['boolean'], mockNode)).toThrow(
				'Parameter "testParam" must be boolean',
			);
		});

		it('should handle special number values correctly', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', NaN, ['number'], mockNode)).not.toThrow();
			expect(() =>
				assertParamIsOfAnyTypes('testParam', Infinity, ['number'], mockNode),
			).not.toThrow();
			expect(() =>
				assertParamIsOfAnyTypes('testParam', -Infinity, ['number'], mockNode),
			).not.toThrow();
		});

		it('should handle empty string correctly', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', '', ['string'], mockNode)).not.toThrow();
		});

		it('should handle zero correctly', () => {
			expect(() => assertParamIsOfAnyTypes('testParam', 0, ['number'], mockNode)).not.toThrow();
		});

		it('should format error message correctly for single type', () => {
			expect(() => assertParamIsOfAnyTypes('myParam', 123, ['string'], mockNode)).toThrow(
				'Parameter "myParam" must be string',
			);
		});

		it('should format error message correctly for two types', () => {
			expect(() =>
				assertParamIsOfAnyTypes('myParam', 'test', ['number', 'boolean'], mockNode),
			).toThrow('Parameter "myParam" must be number or boolean');
		});

		it('should format error message correctly for three types', () => {
			expect(() =>
				assertParamIsOfAnyTypes('myParam', {}, ['string', 'number', 'boolean'], mockNode),
			).toThrow('Parameter "myParam" must be string or number or boolean');
		});

		it('should handle readonly array types correctly', () => {
			const types = ['string', 'number'] as const;
			expect(() => assertParamIsOfAnyTypes('testParam', 'hello', types, mockNode)).not.toThrow();
			expect(() => assertParamIsOfAnyTypes('testParam', 42, types, mockNode)).not.toThrow();
			expect(() => assertParamIsOfAnyTypes('testParam', true, types, mockNode)).toThrow(
				'Parameter "testParam" must be string or number',
			);
		});
	});

	describe('Edge cases and additional scenarios', () => {
		describe('validateNodeParameters edge cases', () => {
			it('should handle NaN values correctly', () => {
				const value = {
					number: NaN,
				};

				const parameters = {
					number: { type: 'number' as const, required: true },
				};

				// NaN is of type 'number' in JavaScript
				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle Infinity values correctly', () => {
				const value = {
					number: Infinity,
				};

				const parameters = {
					number: { type: 'number' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle mixed array types correctly', () => {
				const value = {
					mixed: [1, '2', 3], // Invalid: mixed types in array
				};

				const parameters = {
					mixed: { type: 'number[]' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
					'Parameter "mixed" does not match any of the expected types: number[]',
				);
			});

			it('should handle nested arrays', () => {
				const value = {
					nested: [
						[1, 2],
						[3, 4],
					], // Array of arrays
				};

				const parameters = {
					nested: { type: 'object' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle resource-locator with false __rl property', () => {
				const value = {
					resource: {
						__rl: false, // Should still be valid as it has the property
						mode: 'list',
						value: 'some-value',
					},
				};

				const parameters = {
					resource: { type: 'resource-locator' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle resource-locator missing __rl property', () => {
				const value = {
					resource: {
						mode: 'list',
						value: 'some-value',
						// __rl is missing
					},
				};

				const parameters = {
					resource: { type: 'resource-locator' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).toThrow(
					'Parameter "resource" does not match any of the expected types: resource-locator',
				);
			});

			it('should handle empty string as valid string parameter', () => {
				const value = {
					name: '',
				};

				const parameters = {
					name: { type: 'string' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle zero as valid number parameter', () => {
				const value = {
					count: 0,
				};

				const parameters = {
					count: { type: 'number' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle arrays with only false values', () => {
				const value = {
					flags: [false, false, false],
				};

				const parameters = {
					flags: { type: 'boolean[]' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});

			it('should handle three or more type unions', () => {
				const value = {
					multiType: 'string value',
				};

				const parameters = {
					multiType: {
						type: ['string', 'number', 'boolean'] as Array<'string' | 'number' | 'boolean'>,
						required: true,
					},
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();

				// Test with boolean value
				const value2 = {
					multiType: true,
				};

				expect(() => validateNodeParameters(value2, parameters, mockNode)).not.toThrow();
			});

			it('should handle array types in multi-type parameters', () => {
				const value = {
					flexParam: ['a', 'b', 'c'],
				};

				const parameters = {
					flexParam: {
						type: ['string', 'string[]'] as Array<'string' | 'string[]'>,
						required: true,
					},
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();

				// Test with single string
				const value2 = {
					flexParam: 'single string',
				};

				expect(() => validateNodeParameters(value2, parameters, mockNode)).not.toThrow();
			});

			it('should handle object with null prototype', () => {
				const value = Object.create(null);
				value.name = 'test';

				const parameters = {
					name: { type: 'string' as const, required: true },
				};

				expect(() => validateNodeParameters(value, parameters, mockNode)).not.toThrow();
			});
		});

		describe('assertParamIsArray edge cases', () => {
			const isString = (val: unknown): val is string => typeof val === 'string';

			it('should handle array-like objects', () => {
				const arrayLike = { 0: 'a', 1: 'b', length: 2 };

				expect(() => assertParamIsArray('testParam', arrayLike, isString, mockNode)).toThrow(
					'Parameter "testParam" is not an array',
				);
			});

			it('should handle sparse arrays', () => {
				const sparse = new Array(3);
				sparse[0] = 'a';
				sparse[2] = 'c';
				// sparse[1] is undefined

				// For loop implementation properly validates sparse arrays and throws on undefined elements
				expect(() => assertParamIsArray('testParam', sparse, isString, mockNode)).toThrow(
					'Parameter "testParam" has elements that don\'t match expected types',
				);
			});

			it('should handle arrays with explicit undefined values', () => {
				const arrayWithUndefined = ['a', undefined, 'c'];

				expect(() =>
					assertParamIsArray('testParam', arrayWithUndefined, isString, mockNode),
				).toThrow('Parameter "testParam" has elements that don\'t match expected types');
			});

			it('should handle very large arrays efficiently', () => {
				const largeArray = new Array(1000).fill('test');

				expect(() => assertParamIsArray('testParam', largeArray, isString, mockNode)).not.toThrow();
			});
		});
	});
});



================================================
FILE: packages/workflow/test/node-parameters/path-utils.test.ts
================================================
import { resolveRelativePath } from '../../src/node-parameters/path-utils';

describe('resolveRelativePath', () => {
	test.each([
		['parameters.level1.level2.field', '&childField', 'level1.level2.childField'],
		['parameters.level1.level2[0].field', '&childField', 'level1.level2[0].childField'],
		['parameters.level1.level2.field', 'absolute.path', 'absolute.path'],
		['parameters', '&childField', 'childField'],
		['parameters.level1.level2.field', '', ''],
		['', '&childField', 'childField'],
		['', '', ''],
		['parameters.level1.level2.field', 'relative.path', 'relative.path'],
	])(
		'should resolve relative path for fullPath: %s and candidateRelativePath: %s',
		(fullPath, candidateRelativePath, expected) => {
			const result = resolveRelativePath(fullPath, candidateRelativePath);
			expect(result).toBe(expected);
		},
	);
});


